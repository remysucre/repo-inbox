From franco@ucunix Mon Oct  8 14:09:35 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23567; Mon, 8 Oct 90 14:09:32 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:10 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07081; Mon, 8 Oct 90
 17:12:08 -0400
Date: Mon, 8 Oct 90 17:12:08 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082112.AA07081@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

bnf.inp
==================
% bnf.inp -- this is an included file in -*- LaTeX -*- mode
% in the file section-2.inp


\begin{figure}%[tbhp]
\begin{frameit}
\begin{quote}
\indent $\langle$declaration$\rangle$ ::= \hfil\break
\indent\indent $~$ $\langle$expression$\rangle$\hfil\break
\indent\indent $\vert$ {\small\tt (define} $\langle$variable$\rangle$
$\langle$expression$\rangle${\small\tt )}\hfil\break
\indent\indent $\vert$ {\small\tt (extend-syntax 
 (}$\langle$identifier$\rangle${\small\tt )
 [(}$\langle$identifier$\rangle~\langle$input-spec$\rangle${\small\tt )
 (}$\langle$expression$\rangle${\small\tt )]$^+$)}\hfil\break

\indent $\langle$expression$\rangle$ ::= \hfil\break
\indent\indent $~$ $\langle$constant$\rangle$\hfil\break
\indent\indent $\vert$ $\langle$variable$\rangle$\hfil\break
\indent\indent $\vert$ $\langle$application$\rangle$\hfil\break
\indent\indent $\vert$ {\small\tt (lambda (}$\langle$variable$\rangle
 ^*${\small\tt )} $\langle$expression$\rangle${\small\tt )}
 $\vert$ {\small\tt (lambda }$\langle$variable$\rangle
 $ $\langle$expression$\rangle${\small\tt )}\hfil\break

\indent\indent $\vert$ {\small\tt (if}
 $\langle$test$\rangle~\langle$consequent$\rangle~\langle$alternative$\rangle${\small\tt )}\hfil\break
\indent\indent $\vert$ {\small\tt (case} $\langle$tag$\rangle$ {\small\tt
 [(}$\langle$symbol$\rangle ^+{\small\tt
 )}~\langle$expression$\rangle${\small\tt ]}$^+${\small\tt [else}
 $\langle$expression$\rangle${\small\tt ])}\hfil\break
\indent\indent $\vert$ {\small\tt (cond
 [}$\langle$test$\rangle~\langle$expression$\rangle${\small\tt ]}$^+$ {\small\tt
 [else} $\langle$expression$\rangle${\small\tt ])}\hfil\break
\indent\indent $\vert$ {\small\tt (and} $\langle$expression$\rangle
 ^*${\small\tt )}\hfil\break
\indent\indent $\vert$ {\small\tt (or} $\langle$expression$\rangle ^*${\small\tt
 )}\hfil\break
\indent\indent $\vert$ {\small\tt (let
 ([}$\langle$variable$\rangle~\langle$value$\rangle${\small\tt ]}$^*${\small\tt
 )} $\langle$expression$\rangle${\small\tt )}\hfil\break
\indent\indent $\vert$ {\small\tt (letrec
 ([}$\langle$variable$\rangle~\langle$value$\rangle${\small\tt ]}$^*${\small\tt
 )} $\langle$expression$\rangle${\small\tt )}\hfil\break

\indent\indent $\vert$ {\small\tt (let*
 ([}$\langle$variable$\rangle~\langle$value$\rangle${\small\tt ]}$^*${\small\tt
 )} $\langle$expression$\rangle${\small\tt )}\hfil\break
\indent\indent $\vert$ {\small\tt (begin} $\langle$expression$\rangle
 ^+${\small\tt )}\hfil\break
\indent\indent $\vert$ {\small\tt (set!}
 $\langle$variable$\rangle~\langle$expression$\rangle${\small\tt )}\hfil\break

\indent\indent $\vert$ {\small\tt '}$\langle$S-expression$\rangle$\hfil\break

\vskip 10pt

\indent $\langle$application$\rangle$ ::= {\small\tt
 (}$\langle$expression$\rangle~
\langle$expression$\rangle ^*${\small\tt )}\hfil\break

\vskip 10pt

\indent $\langle$input-spec$\rangle$ ::= $\langle$S-expression$\rangle ^*$
\hfil\break

\vskip 10pt

\indent $\langle$consequent$\rangle ,~\langle$alternative$\rangle
 ,~\langle$value$\rangle ,~\langle$tag$\rangle$ ::=
 $\langle$expression$\rangle$\hfil\break
\end{quote}
\caption{BNF of Scheme as used in this chapter}
\vskip 6pt
\noindent
The superscripts $^*$ ($^+$) denote zero (one) or more occurrences of
the preceding form.  $\langle$condition$\rangle$ denotes a boolean
expression.
\label{fig:BNF}
\end{frameit}
\end{figure}

From franco@ucunix Mon Oct  8 14:09:57 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23577; Mon, 8 Oct 90 14:09:54 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:10 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07142; Mon, 8 Oct 90
 17:12:28 -0400
Date: Mon, 8 Oct 90 17:12:28 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082112.AA07142@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

sect-1.inp
=======
% section-1.inp -- this is an included file in -*- LaTeX -*- mode
% in the chapter on ``Scheme''

\section{History and Features of Scheme}

Scheme was developed in 1975 by Gerald J. Sussman and Guy L. Steele
Jr.\ \cite{SS}.  Their goal was to build a Lisp-like prototype of Carl
Hewitt's Actors system.  To their surprise, after removing several
layers of syntactic and semantic sugar, what remained was an extension
of an applicative order \lc\ supporting state and first class
continuations.  Since then there have been four revisions of the
language definition and an effort is underway to create an IEEE
standard for Scheme.  Scheme today still stands as an extended \lc\
with declarative and imperative components.  It is in use at numerous
universities and research centers as the first programming language
for students or at the core of research projects or software products.
A complete description of Scheme can be found in \cite{dyb,rrr}.

Due to its Lisp origin, the basic syntactic units of Scheme are fully
parenthesized expressions.  The basic control structure of Scheme is
procedure application.  Procedures are either represented as
\lam-expressions or are primitive, operating on numbers, strings,
symbols, cons pairs, lists (built out of cons pairs), vectors, and
global i/o streams.

Besides being applied to data types other than functions, Scheme
extends $\lambda$-calculus in three directions:
\begin{itemize}
\item with conditional expressions;
\item with sequencing and first-class access to control via
continuations;
\item with side-effects on variables, structures, and the outside
world.
\end{itemize}

Scheme is call-by-value, \ie, procedures are applied to the values of
their arguments, in contrast to ALGOL 60 and lazy languages.  A
convenient way to delay the evaluation of an expression is to define
it as a parameterless procedure.  Applying this procedure to no
arguments entails the evaluation of the delayed expression.  This
makes it simple to define \eg, streams, as illustrated by the solution
to the extended Hamming problem.

Scheme is block-structured and lexically scoped.  All the solutions in
this chapter make use of this property.

Procedures are first class objects.  They are either primitive or
result from evaluating a \lam-expression, and can be passed as
arguments, returned as results, and stored in data structures.

Because Scheme is lexically scoped, procedures can be viewed as
instances of the same \lam-expression, each with a local environment
and state.  This makes it easy to program in object-oriented style,
as illustrated in the solution to the doctors-patients problem.

The implementations of Scheme are properly tail-recursive.  Thus,
recursion is automatically turned into iteration in many cases
and this explains why the language does not provide explicit
loop constructs.  This property is exploited in the solution to the
doctors-patients problem where communication between patients,
doctors, and receptionists proceeds in round-robin fashion.

Because they are fully parenthesized, Scheme programs can be
represented as lists.  This makes it simple to treat programs as data
objects.  In particular, syntactic extensions (macros) are expressible
within the Scheme world without resorting to an outside abstract
syntax.

Scheme expressions are dynamically typed, \ie, type-checking is
performed at runtime.  This makes it possible to express programs that
have no type.

Scheme does not explicitly support any form of parallelism today.
However, by requiring that the order of evaluation of subexpressions
be arbitrary in applications, the Scheme designers are leaving open
some form of collateral evaluation.

Finally, Scheme inherits its representation of lists with cons pairs,
its implicit memory management relying on garbage collection, and its
quotation from Lisp.


From franco@ucunix Mon Oct  8 14:10:56 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23589; Mon, 8 Oct 90 14:10:52 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:11 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07171; Mon, 8 Oct 90
 17:12:44 -0400
Date: Mon, 8 Oct 90 17:12:44 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082112.AA07171@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

sect-2.inp
==========
% section-2.inp -- this is an included file in -*- LaTeX -*- mode
% in the chapter on ``Scheme''

\section{The Syntax of Scheme}

Figure \ref{fig:BNF} displays a BNF for Scheme suitable for the
purposes of this chapter.  Squared brackets stand for regular
parentheses -- experience shows that they improve the readability of
programs.

\input{bnf.inp}

There are three kinds of declarations: the definition of a global
variable; the definition of a syntactic extension; and plain
expressions.


\subsection{Global variables}

Global variables are defined in the global environment, and bound to
the value of the corresponding expression.  All procedures defined
globally are mutually recursive.  In particular, there is no need to
declare recursive procedures explicitly where they are global.  This
contrasts to declaring local procedures (with \svbt{letrec}).


\subsection{Syntactic extensions}

Syntactic extensions offer a macro facility based on specifying
expansions conditionally, depending on syntactic contexts selected by
pattern matching.  While not unanimously agreed upon in the Scheme
community, they provide a very convenient expressive power and are
sufficiently well-understood for serving the purposes of this chapter.
A complete description of \svbt{extend-syntax} can be found in
\cite{dyb,Koh}.

For example, let us now define the following syntactic extensions
\svbt{rec}, \svbt{when}, and \svbt{unless} that will be used in the
rest of this chapter.

%\begin{quote}
\begin{verbatim}
(extend-syntax (rec)          (extend-syntax (when)        (extend-syntax (unless)
  [(rec ide exp)                [(when test exp)             [(unless test exp)   
   (letrec ([ide exp])           (if test                     (if test            
     ide)])                          exp                          'undefined      
                                     'undefined)])                exp)])          
\end{verbatim}
%\end{quote}

\noindent
\svbt{rec} is a recursive declaration and evaluates to the recursively
declared procedure.  \svbt{when} and \svbt{unless} implement a
``one-arm'' conditional expression.


\subsection{Expressions}

An expression can be an expression from the \lc\ or be a declarative
or imperative extension to the \lc.

\subsubsection{Pure Scheme expressions}

Constants, variables, \lam-expressions, and applications give to
Scheme the full power of an applied, weakly typed, and applicative
order \lc.  Constants (strings, numbers, \etc) evaluate to ground
values.  Variables are denoted by values in the current environment.
\lam-expressions evaluate to first-class procedures where free
variables are bound lexically.  Expressions occurring in an
application are evaluated in any order.  The first one evaluates to a
procedure.  This procedure is applied to the values of the remaining
expressions.

\subsubsection{Conditional and declarative extensions}

Scheme provides conditional and declarative extensions to the \lc.
These include conditional expressions (\svbt{if}, \svbt{case},
\svbt{cond}), logic operations (\svbt{and}, \svbt{or}), and local
definitions (\svbt{let}, \svbt{letrec}).

\svbt{if} evaluates its test-expression.  If the result is not the
boolean value {\em false}, then the consequent is evaluated, otherwise
the alternative is evaluated.  \svbt{case} evaluates the tag
expression and returns the value of the first expression one of whose
associated symbols matches the tag.  The last symbol \svbt{else}
matches any value.  \svbt{cond} has the same semantics as in Lisp.
\svbt{and} returns {\em false} if one of its expressions evaluates to
{\em false}.  Sub-expressions in \svbt{and} (resp.\ \svbt{or}) are
evaluated from left to right until a {\em false} (resp.\ non-{\em
false}) value is found or until all the expressions are evaluated.
\svbt{and} (resp.\ \svbt{or}) expressions evaluate either to {\em
false} if an expression has evaluated to {\em false} (resp. if all
expressions have evaluated to {\em false}), or to the last (resp.\ the
first) non-{\em false} value.  \svbt{let} declares parallel local
bindings, and \svbt{letrec} declares mutually recursive local
bindings.

\subsubsection{Imperative extensions}

Scheme provides imperative extensions to the \lc.  These include
\svbt{let*}, \svbt{begin}, and \svbt{set!\ }.  \svbt{let*} declares
local bindings sequentially.  \svbt{begin} sub-expressions are
evaluated sequentially and the value of the last expression is
returned.  \svbt{set!\ } assigns the value of an expression to a
variable provided that this variable is declared in the lexical
environment.

\subsubsection{Primitive operators}

In addition to these special forms, Scheme provides primitive
procedures for processing ground constructs.  Their name is postfixed
with a question mark if they are predicates, and with an exclamation
mark if they perform a side-effect -- this convention is usually
followed by Scheme programmers in their own programs.

For example, \svbt{zero?\ } checks whether its argument is the number 0,
and \svbt{null?\ } checks whether its argument is an empty list.
\svbt{eqv?\ } checks whether its arguments are the same value.
\svbt{eq?\ } checks whether its arguments are the same object.

\svbt{cons}, \svbt{car}, and \svbt{cdr} are the usual list building
and decomposition operations.  \svbt{set-car!\ } and \svbt{set-cdr!\ }
update the two fields of a cons cell.

In addition, Scheme provides structural predicates.  For example,
\svbt{pair?\ } tests whether its argument is a cons cell, \svbt{number?\ }
tests whether its argument is a number, and so on.

Finally, the procedure \svbt{call-with-current-continuation} is passed a
unary procedure, and applies it to a procedural abstraction of the
current continuation.  Applying this continuation later to a value
will restore the current continuation and pass it this value.

\subsubsection{Representation of values}

The boolean constants {\it true} and {\it false} are represented by
\svbt{\#t} and \svbt{\#f}, respectively.

\subsubsection{Quotation}

Scheme inherits quotation from Lisp.  This meta-structural
facility allows one to specify {\em values} such as numbers, strings,
symbols, vectors -- or any list or vector of these -- within the {\em
text} of programs.  This of course strongly relies on the direct
representation of programs as data.


\subsection{Conclusion}

This section has presented the syntax and some of the semantics and
rationale of Scheme.  A formal description of its semantics can be
found in \cite{rrr}.


From franco@ucunix Mon Oct  8 14:11:32 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23606; Mon, 8 Oct 90 14:11:28 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:11 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07216; Mon, 8 Oct 90
 17:13:05 -0400
Date: Mon, 8 Oct 90 17:13:05 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082113.AA07216@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

sect-3.inp
======
% section-3.inp -- this is an included file in -*- LaTeX -*- mode
% in the chapter on ``Scheme''

\section{Hamming's Problem Extended}

Let $\{a, b, c, \ldots\}$ be an ordered list of prime numbers.  Hamming's
problem requests to produce the ordered stream containing integers matching
the product

\begin{center}
$a^i \times b^j \times c^k \ldots$
\end{center}

\noindent
where $i, j, k, \ldots$ are non-negative integers and at least one of
$i, j, k, \ldots$ is non-zero.


\subsection{Analysis of the modified problem}

Let $T$ be any integer and suppose Hamming's problem is modified
to return the ordered stream given by

\begin{center}
$T \times a^i \times b^j \times c^k \ldots$
\end{center}

\noindent
that is, the solution to the original Hamming's problem except that
all output tokens are multiplied by the integer $T$.  This stream is
equivalent to the stream beginning with the token $T \times a$ and
followed by the ordered stream of integers equal either to $T \times a
\times a^i \times b^j \times c^k \ldots$ or to $T \times b^{j'} \times
c^{k'} \ldots$, where $i, j, k, \ldots$ are non-negative and at least
one of $i,j,k, \ldots$ is non-zero, and $j', k', \ldots$ are
non-negative, and at least one of $j',k', \ldots$ is non-zero.

This observation is the basis of our recursive solution to Hamming's
extended problem.  We construct the output stream by appending the
result of merging the streams $T \times a \times a^i \times b^j \times
c^k \ldots$ and $T \times b^{j'} \times c^{k'} \ldots$ to the output
token $T \times a$.

\subsection{Scheme properties exploited by our solution}

The implementation of the solution requires the manipulation of
streams.  In particular, streams must be merged and assembled.
Although Scheme does not have the native ability to operate on or to
create streams, we can derive it by delaying the construction of
streams tails.

Let us first define the standard operations on streams viewed as lazy
lists.  Figure \ref{fig:stream-op} displays the corresponding
operators.  Accordingly, figure \ref{fig:stream-merge} displays a
procedure merging two streams of increasing integers.

\begin{figure}%[tbhp]
\begin{frameit}
\begin{quote}
\begin{verbatim}
(extend-syntax (force)
  [(force e) (e)])

(extend-syntax (delay)
  [(delay e) (lambda () e)])


(extend-syntax (empty-stream)
  [(empty-stream) '()])

(extend-syntax (null-stream?)
  [(null-stream? s) (null? s)])

(extend-syntax (car-stream)
  [(car-stream s) (car s)])

(extend-syntax (cdr-stream)
  [(cdr-stream s) (let ([d s])
                    (if (procedure? (cdr d))
                        (begin (set-cdr! d (force (cdr d))) (cdr d))
                        (cdr d)))])

(extend-syntax (cons-stream)
  [(cons-stream a d) (cons a (delay d))])

\end{verbatim}
\end{quote}
\caption{Stream operators,
         where \protect{\svbt{Stream = Pair(Num, Stream + [Unit -> Stream])}}
}
\label{fig:stream-op}
\end{frameit}
\end{figure}

\begin{figure}%[tbhp]
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define merge-streams   ;;; Stream(Int) x Stream(Int) -> Stream(Int)
  (lambda (s1 s2)
    (cond
      [(null-stream? s1)
       s2]
      [(null-stream? s2)
       s1]
      [else
       (let ([a1 (car-stream s1)] [a2 (car-stream s2)])
         (if (<= a1 a2)
             (cons-stream a1 (merge-streams (cdr-stream s1) s2))
             (cons-stream a2 (merge-streams s1 (cdr-stream s2)))))])))
\end{verbatim}
\end{quote}
\caption{Procedure merging two streams
}
\label{fig:stream-merge}
\end{frameit}
\end{figure}

This solution makes liberal use of functions as values and of
delaying the evaluation of values by expressing them as parameterless
procedures.  The resulting program is kept simple by using syntactic
extensions.


\subsection{Our solution}

The solution to this problem involves merging pairs of arbitrarily
long lists.  These lists are represented as streams.

\begin{figure}%[tbhp]
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define hamming         ;;; Int x Int x List(Int) -> Stream(Int)
  (lambda (T lp)
    (if (null? lp)
        (empty-stream)
        (let ([new-T (* T (car lp))])
          (cons-stream new-T
                       (merge-streams (hamming new-T lp)
                                      (hamming T (cdr lp))))))))
\end{verbatim}
\end{quote}
\caption{Procedure solving Hamming's extended problem
}
\label{fig:hamm-sol}
\end{frameit}
\end{figure}
\begin{figure}%[tbhp]
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define test            ;;; Unit -> Unspecified
  (lambda ()
    (print-stream! (hamming 1 '(2 5 11 53)) 300 60)))

(define print-stream!   ;;; Stream(Val) x Int -> Unspecified
  (lambda (s m n)
    (if (or (null-stream? s) (zero? n))
        (newline)
        (let ([tmp (car-stream s)])
          (begin
            (my-write! tmp)
            (when (< tmp m)
              (print-stream! (cdr-stream s) m (sub1 n))))))))

(define my-write!       ;;; Val -> Unspecified
  (lambda (v)
    (begin (write v) (display " "))))
\end{verbatim}
\end{quote}
\caption{A sample test of the procedures solving Hamming's extended problem
}
\label{fig:hamm-test}
\end{frameit}
\end{figure}

Procedure \svbt{hamming}, displayed in figure \ref{fig:hamm-sol}, is
passed an output token \svbt{T}, and an ordered list of
primes \svbt{lp} in increasing order.  \svbt{hamming} produces a stream
of integers in increasing order, equal to

\begin{center}
$T \times a^i \times b^j \times c^k \ldots\ $
\end{center}

\noindent
where $i, j, k, \ldots$ are non-negative integers, at least one of $i,
j, k, \ldots$ is non-zero, and $a, b, c, \ldots$ are elements of the
prime list \svbt{lp}.  This is equivalent to the stream beginning with
$T \times a$ and followed by the ordered stream of integers
equal either to
        $T \times a \times a^i \times b^j \times c^k \ldots$
or equal to
        $T \times b^{j'} \times c^{k'} \ldots$,
where $i, j, k, \ldots$ are non-negative, at least one of $i, j, k,
\ldots$ is non-zero, $j', k', \ldots$ are non-negative, and at least
one of $j', k', \ldots$ is non-zero.  Hence \svbt{hamming} needs to merge
two streams.

Figure \ref{fig:hamm-test} displays a set of procedures to test this
solution.  The important procedure here is \svbt{print-stream!\ } which
takes as input an integer $m$ specifying the largest stream element to
be output and an integer $n$ specifying the maximum number of stream
elements to be printed.

\subsection{What have we learned in this section?}

The solution to Hamming's problem can be expressed recursively using
streams.  Although recursion is natural in Scheme, an explicit
representation of streams was needed.  It is simple to make these
streams fully lazy (to avoid multiple representations of the same
stream), but experience shows that the resulting program does not
improve much in this example.


From franco@ucunix Mon Oct  8 14:12:04 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23611; Mon, 8 Oct 90 14:12:00 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:11 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07241; Mon, 8 Oct 90
 17:13:31 -0400
Date: Mon, 8 Oct 90 17:13:31 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082113.AA07241@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

sect-4.inp
=========
%sect-4.inp  -*- LaTeX -*-

\section{The Paraffin Problem}

The problem is to find all isomers of the chemical composition
${\rm C}_{n}{\rm H}_{2n+2}$.  The problem reduces to finding all trees of
$n$ vertices and maximum degree 4.  Each vertex or node in such a tree
represents a carbon atom (there is no need to represent hydrogen atoms).

\subsection{The input and output specification}

The program \svbt{para} shown in Figure \ref{fig:para} takes as input an
integer $n$.  The output is a list of trees of maximum degree four and no two
trees in the list are isomorphic.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(extend-syntax (construct-trees)
 [(construct-trees A n type nodes height-list)
  (map (lambda (x) (done type A n x (sizer 1 nodes x))) height-list)])

(define para
  (lambda (n)
    (let ([A (create-array n)]
          [B (make-vector (1+ n) '())]
          [t2 (ceiling (/ n 2))])
      (begin
        (map (lambda (x)
               (let ([tem (trees B x)])
                 (begin
                   (split-t A tem x n)
                   (vector-set! B x tem))))
             (incr-ord-list n))
        (construct-trees A n 'even (- n 1) (height-proc t2 2))
        (construct-trees A n 'odd  (- n 2) (height-proc t2 2))
        (construct-trees A n 'odd  (- n 2) (height-proc t2 3))
        (construct-trees A n 'odd  (- n 2) (height-proc t2 4))
        '()))))
\end{verbatim}
\end{quote}
\caption{The main procedure}
\label{fig:para}
\end{frameit}
\end{figure}

\subsection{Representation of trees}

Each tree in the output list is actually a collection of two or more subtrees.
Each subtree is enclosed between angle brackets like these \svbt{<>} for
readability.
%The symbols \svbt{<()>} at the left margin have a special meaning as
%described below.
The number of nodes of all subtrees is $n$.  The difference
in height between the two highest subtrees is always zero.  In the case that
the longest path between terminal nodes is even, so that the number of nodes
on that path is odd, the tree is split at the center node into up to four
subtrees enclosed in brackets.  The symbols \svbt{<()>} in the left margin
indicate such a split and represents the singleton subtree consisting only
of the center node.  When the longest path is odd, so that the number of
nodes on the path is even, there is a center edge and the split is into two
subtrees connected by that edge.

The subtrees themselves are defined recursively as follows. A subtree of one
node is represented as \svbt{()}.  A subtree with root having one child is
\svbt{( {\rm *subtree of the child*} )}.  A subtree with root having two
children is represented as
\svbt{( {\rm *subtree of the left child* *subtree of the right child*} )}.
A subtree with root having three children is represented as
\svbt{( {\rm *subtree of left child* *subtree of middle child*
*subtree of right child*} )}.  Thus, the subtree \svbt{(() () ())} is a four
node subtree, one of which has degree three and the subtree \svbt{(((())))} is
a four node subtree that has all nodes in line.

\subsection{Collecting subtrees}

A two dimensional array is used to save all lists of subtrees of height $h$
which contain $n$ nodes for each pair $(n,h)$.  Each list contains no duplicate
trees.

\subsection{Uniqueness of the trees}

Paraffin trees are assembled from collections of subtrees which together obey
the following restrictions.  The sum of the nodes in all subtrees is $n$.
Excluding the special \svbt{<()>} at the boundary of the left margin, the height
the subtrees from left to right is nonincreasing and the first two have the
same height.  All possible combinations of subtrees matching each height
specification are joined to form individual paraffin trees.  In the case that
subtrees are the same height and the number of nodes is the same then the
combination of subtrees is ordered to prevent paraffin tree duplicates.

\subsection{Rough description of the algorithm}

The algorithm has two phases.  The objective of the first phase is to collect
lists of unique trees of maximum degree four with root of maximum degree
three, one list for every combination of tree height and size (in number of
nodes).  Each list is saved as an element of an array: the $i,j$ location of the
array contains the list of unique trees of size $i$ and height $j$.  The
objective of the second phase is to sweep through the array assembling groups
of subtrees which together represent paraffin trees.

The first phase is handled by procedure \svbt{split-t}
(Figure \ref{fig:split-t}) which is called from \svbt{para}.
The input to \svbt{split-t} is a list \svbt{l} of trees each containing
exactly $n$ nodes
and the number $n$.  For each tree in \svbt{l}, \svbt{split-t} determines its
height $h$ and
adds it to the existing list of trees having $n$ nodes and height $h$ which is
stored in the array at location $(n,h)$.  The input list \svbt{l} is obtained
from another procedure called \svbt{build-trees} (Figure \ref{fig:new-trees})
which is called from \svbt{trees} (Figure \ref{fig:new-trees}).
The procedure \svbt{sizer} (Figure \ref{fig:size-iter}) as invoked from
\svbt{trees} produces triples which represent legal sizes of the
subtrees.  The procedure \svbt{build-trees} takes as input the number $n$ and
produces a list of unique trees of maximum degree four, with maximum root
degree three.  Each node in such trees has at most three children.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define split-t
  (lambda (A l x n)
    (if (null? l)
        '()
        (let* ([tree (car l)] [h (1+ (height tree))])
          (begin
            (when (< h (1+ (/ n 2)))
              (array-set! A x h (cons tree (array-ref A x h))))
            (split-t A (cdr l) x n))))))
\end{verbatim}
\end{quote}
\caption{Split n-node trees by height and save in array}
\label{fig:split-t}
\end{frameit}
\end{figure}


\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define combine
  (lambda (x y f)
    (if (or (null? x) (null? y))
        '()
        (append (map (lambda (z) (append (list (car x)) z)) y)
                (combine (cdr x) (f y) f)))))

(define assemble
  (lambda (a b c d f-a f-b f-c)
    (cond
      [(null? a) '()]
      [(and (null? b) (null? c) (null? d))
       (map (lambda (y) (list y)) a)]
      [else (let ([argb (if (null? b) b (f-a b))]
                  [lst (assemble b c d '() f-b f-c f-c)])
              (append (combine (list (car a)) lst f-a)
                      (assemble (cdr a) argb c d f-a f-b f-c)))])))

(define bracket-parts
  (lambda (l)
    (if (null? l)
        '()
        (begin
          (display '<) (display (car l)) (display '>)
          (bracket-parts (cdr l))))))

(define print-tree
  (lambda (type a b c d f-a f-b f-c)
    (let ([assem-list (assemble a b c d f-a f-b f-c)])
      (if (null? assem-list)
          '()
          (map (lambda (l)
                 (begin
                   (when (eq? type 'odd)
                     (display "<()>"))
                   (bracket-parts l)
                   (newline)))
               assem-list)))))
\end{verbatim}
\end{quote}
\caption{Procedures for assembling and printing output trees}
\label{fig:output}
\end{frameit}
\end{figure}

Using each triple, a collection of right, middle, and left subtrees are
obtained recursively as \svbt{trees-a}, \svbt{trees-b}, and \svbt{trees-c}
within \svbt{build-tree}.  These are joined by
\svbt{assemble} (Figure \ref{fig:output}) to create the complete subtree.

The inputs to \svbt{assemble} are lists of subtrees (\svbt{a}, \svbt{b},
\svbt{c}, \svbt{d}) and operators (instantiated as \svbt{cons} or \svbt{cdr}).
\svbt{assemble} groups sets of subtrees into a list
representing another subtree where the children of the root are roots of the
input subtrees.

\begin{figure}
\begin{frameit}
%\begin{quote}
\begin{verbatim}
(define done
  (lambda (type A n hght-list size-list)
    (begin
      (let ([height-a (car hght-list)]
            [height-b (cadr hght-list)]
            [height-c (if (< (length hght-list) 3) 0 (caddr hght-list))]
            [height-d (if (< (length hght-list) 4) 0 (cadddr hght-list))])
        (map (lambda (y)
               (let ([size-a (car y)]
                     [size-b (cadr y)]
                     [size-c (if (< (length y) 3) 0 (caddr y))]
                     [size-d (if (< (length y) 4) 0 (cadddr y))])
                 (let ([tree-a (array-ref A size-a height-a)]
                       [tree-b (array-ref A size-b height-b)]
                       [tree-c (array-ref A size-c height-c)]
                       [tree-d (array-ref A size-d height-d)])
                   (when (and (not (null? tree-a))
                              (not (null? tree-b))
                              (or (not (null? tree-c)) (< (length y) 3))
                              (or (not (null? tree-d)) (< (length y) 4)))
                       (let ([f1 (if (and (= size-a size-b) (= height-a height-b))
                                     cdr id)]
                             [f2 (if (and (= size-b size-c) (= height-b height-c))
                                     cdr id)]
                             [f3 (if (and (= size-c size-d) (= height-c height-d))
                                     cdr id)])
                         (print-tree
                           type tree-a tree-b tree-c tree-d f1 f2 f3))))))
             size-list))
      '())))
\end{verbatim}
%\end{quote}
\caption{From height and size lists, assemble trees from array subtrees}
\label{fig:done}
\end{frameit}
\end{figure}

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define list-max
  (lambda (l)
    (if (null? l) 0 (max (car l) (list-max (cdr l))))))

(define height
  (lambda (l)
    (if (null? l) 0 (1+ (list-max (map height l))))))
\end{verbatim}
\end{quote}
\caption{Procedures for finding the height of a tree}
\label{fig:tree-height}
\end{frameit}
\end{figure}

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define last-items
  (lambda (l)
    (if (= 2 (length l)) l (last-items (cdr l)))))

(define sizer
  (lambda (n x h-spec)
    (let* ([items (last-items h-spec)]
           [next-last (car items)]
           [last (cadr items)]
           [new-h-spec (reverse (cdr (reverse h-spec)))])
      (if (= (length h-spec) 2)
          (if (< x n)
             '()
             (cons (cons x (list n)) (sizer (1+ n) (1- x) h-spec)))
          (let ([bnd (if (= last next-last) n 1)])
            (if (< x 1)
                '()
                (append (map (lambda (y) (append y (list n)))
                             (sizer bnd (- x bnd) new-h-spec))
                        (sizer (1+ n) (1- x) h-spec))))))))
\end{verbatim}
\end{quote}
\caption{Procedures for defining size iterators}
\label{fig:size-iter}
\end{frameit}
\end{figure}
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define id (lambda (x) x))
\end{verbatim}
\end{quote}
\caption{The Identity Procedure}
\label{fig:ident-proc}
\end{frameit}
\end{figure}
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define array-ref
  (lambda (A n m) (vector-ref (vector-ref A n) m)))

(define array-set!
  (lambda (A n m val) (vector-set! (vector-ref A n) m val)))

(define create-array
  (lambda (n)
    (let ([f (decr-ord-list (1+ n))])
      (apply vector (map (lambda (x) (make-vector (1+ n) '())) f)))))
\end{verbatim}
\end{quote}
\caption{Procedures for array manipulation}
\label{fig:array-manip}
\end{frameit}
\end{figure}
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define incr-ord-list
  (lambda (n)
    ((rec up (lambda (acc x) (if (zero? x) acc (up (cons x acc) (1- x)))))
     '() n)))

(define decr-ord-list ;** (decr-ord-list 6) -> (6 5 4 3 2 1 0)
  (lambda (n)
    (if (zero? n) '(0) (cons n (decr-ord-list (1- n))))))

(define decr-ord-pair ;** (decr-ord-pair 4) -> ((3 3)(3 2)(3 1)(3 0)(2 2)...
  (lambda (n)
    (if (zero? n)
        (list (list 0 0))
        (append (map (lambda (x) (list n x)) (decr-ord-list n))
                (decr-ord-pair (1- n))))))

(define decr-elements
  (lambda (n)
    (map list (decr-ord-list n))))

(define height-proc
  (lambda (n h)
    (cond
      [(< n 0)
       '()]
      [(= h 2)
       (cons (list n n) (height-proc (1- n) h))]
      [else
       (let ([map-list (if (= h 3) (decr-elements n) (decr-ord-pair n))])
         (append (map (lambda (y) (append (list n n) y)) map-list)
                 (height-proc (1- n) h)))])))
\end{verbatim}
\end{quote}
\caption{Procedures for height iterators}
\label{height-iter}
\end{frameit}
\end{figure}

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define get-trees (lambda (B n) (vector-ref B n)))

(define build-trees
  (lambda (B l)
    (if (null? l)
        '()
        (let* ([subtree-config (car l)]
               [nodes-c (car subtree-config)]
               [nodes-b (cadr subtree-config)]
               [nodes-a (caddr subtree-config)]
               [trees-c (get-trees B nodes-c)]
               [trees-b (get-trees B nodes-b)]
               [trees-a (get-trees B nodes-a)]
               [op1 (if (= nodes-a nodes-b) cdr id)]
               [op2 (if (= nodes-b nodes-c) cdr id)])
           (append (assemble trees-c trees-b trees-a '() op2 op1 id)
                   (build-trees B (cdr l)))))))

(define trees
  (lambda (B n)
    (cond
      [(= 1 n) (list '())]
      [(zero? n) '()]
      [else (build-trees B (sizer 0 (1- n) '(1 1 1)))])))
\end{verbatim}
\end{quote}
\caption{Procedures to make a list of trees from a given subtree configuration}
\label{fig:new-trees}
\end{frameit}
\end{figure}


Upon completion of the first phase the array \svbt{A} contains all lists of
trees that are needed to assemble the output trees.  Within \svbt{para},
procedure \svbt{done} (Figure \ref{fig:done})
is invoked four times to assemble the appropriate collections of trees from
the array (actually using \svbt{construct-trees} in Figure \ref{fig:para}).
One call handles paraffin trees with an even number of nodes on
its longest path.  The other calls handle the cases where there is a center
node in the longest path and it has two, three, and four neighbors.  The
procedure \svbt{done} retrieves from the array the appropriate combinations
of subtrees to assemble into paraffin trees.  It gets a height and size
specification as input.  The procedures for supplying this specification
are \svbt{height-list} (Figure \ref{fig:tree-height}), and \svbt{sizer}.
The procedure \svbt{sizer} is used by \svbt{done} to select
the sizes of the subtrees to assemble into paraffin trees.  These procedures
produce, from
a height specification and a number of nodes $n$, a list of all triples of
integers summing to $n-1$. The numbers in the triples indicate the number of
nodes in the right, middle and left subtrees, respectively.  Uniqueness of
the trees produced by \svbt{trees} is ensured, in part, by the uniqueness of the
triples with respect to height configuration. The assembling is done by the
procedure \svbt{assemble} which is supervised by \svbt{print-tree}
(Figure \ref{fig:output}).  The output format is handled by
\svbt{bracket-parts} (Figure \ref{fig:output}).

The remaining procedures provide support for the procedures described above.


\subsection{Problem with append}

A problem with this solution is the repeated use of the list operation
\svbt{append}.  For one point, because most of the lists are
intermediate data structures, its imperative counterpart
\svbt{append!\ } could be used.  However, even \svbt{append!\ } requires
traversing its first argument.  To circumvent this overhead, one can
maintain a tail pointer to each intermediate list and attach the
second list by side-effect.  Since this optimization technique does
not bring much conceptually to solving the paraffin problem, we only
mention it and have refrained from actually implementing it in the
figures above.


From franco@ucunix Mon Oct  8 14:12:31 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23616; Mon, 8 Oct 90 14:12:27 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:12 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07271; Mon, 8 Oct 90
 17:13:55 -0400
Date: Mon, 8 Oct 90 17:13:55 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082113.AA07271@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

sect-5.inp
======
%sect-5.inp  -*- LaTeX -*-
\section{The Doctor-Patient Problem}

This simulation involves the interaction of several independent {\it actors}.
Scheme does not have the ability to deal with such computational agents directly.
Therefore we have built an event-manager for scheduling and initiating
occurrences of sickness, patient releases, etc.\ based on information obtained
directly from procedures that represent the actors.  The
interaction of actors is simulated as invocations of corresponding actor
procedures.  Except for communications with the event-manager, invocations
never return to their parent callers.  This mimics real life: a person
becomes sick, then proceeds to a receptionist, then is treated by a doctor,
then goes home and so on.  This is possible in Scheme because all
implementations of the language are required to treat tail-recursion as
iteration.

\subsection{Principal program components}

The principal components of our solution to this problem are a
\svbt{patient-maker} (Figure \ref{fig:actor-maker}), a \svbt{doctor-maker}
(Figure \ref{fig:actor-maker}), a \svbt{receptionist} (Figure \ref{fig:recep}),
and an \svbt{event-manager} (Figure \ref{fig:event}). The
\svbt{patient-maker} and the \svbt{doctor-maker} produce one instance
of a patient procedure or doctor procedure for each patient and
doctor.  These procedures are anonymous.  However, since procedures are
not only denotable values but are also expressible as well, they do not
need to be named to be passed to the \svbt{event-manager} and
\svbt{receptionist}.  The \svbt{receptionist} pairs patients and
doctors.  The \svbt{event-manager} schedules events and drives the
simulation when an event occurs.
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define person-maker
  (lambda (name)
    (let ([this-time 'infinity])
      (lambda msg
         (case (1st msg)
           [(name) name]
           [(time) this-time]
           [(time!) (set! this-time (2nd msg))]
           [else (error msg "Error in person-maker")])))))

(define patient-maker
  (lambda (name)
    (let ([person (person-maker name)])
      (rec patient (lambda msg
                     (case (1st msg)
                       [(event) (receptionist 'enqueue-patient patient)]
                       [(new-sick-patient)
                        (begin
                          (patient 'time! (rand))
                          (event-mgr 'record patient))]
                       [else (apply person msg)]))))))

(define doctor-maker
  (lambda (name)
    (let ([treated '*] [person (person-maker name)])
      (rec doctor (lambda msg
                    (case (1st msg)
                      [(event)
                       (begin
                         (treated 'new-sick-patient)
                         (receptionist 'release-patient doctor treated))]
                      [(assign-patient)
                       (begin
                         (doctor 'time! (rand))
                         (set! treated (2nd msg))
                         (event-mgr 'record doctor))]
                      [else (apply person msg)]))))))

\end{verbatim}
\end{quote}
\caption{Procedures for creating actors}
\label{fig:actor-maker}
\end{frameit}
\end{figure}
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define receptionist
  (let ([patient-Q (queue)] [doctor-list (queue)])
    (let ([p-empty? (patient-Q 'empty?)]
          [d-empty? (doctor-list 'empty?)]
          [p-dequeue! (patient-Q 'dequeue!)]
          [d-dequeue! (doctor-list 'dequeue!)]
          [p-enqueue! (patient-Q 'enqueue!)]
          [d-enqueue! (doctor-list 'enqueue!)])
       (letrec ([treat-waiting-patients-if-docs-available
                 (lambda ()
                   (when (and (not (p-empty?)) (not (d-empty?)))
                     (let ([doctor (d-dequeue!)] [patient (p-dequeue!)])
                       (begin
                         (doctor 'assign-patient patient)
                         (SHOW-PAIR-DOC-PAT doctor patient)
                         (treat-waiting-patients-if-docs-available)))))])
         (lambda msg
           (begin
             (case (1st msg)
               [(enqueue-patient)
                (let ([patient (2nd msg)])
                  (begin
                    (SHOW-PERSON-SICK patient)
                    (if (d-empty?)
                        (p-enqueue! patient)
                        (let ([doctor (d-dequeue!)])
                          (begin
                            (doctor 'assign-patient patient)
                            (SHOW-PAIR-DOC-PAT doctor patient))))))]
               [(release-patient)
                (let ([doctor (2nd msg)] [patient (3rd msg)])
                  (begin
                    (SHOW-RELEASE patient doctor)
                    (d-enqueue! doctor)
                    (treat-waiting-patients-if-docs-available)))]
               [(init) (for-each d-enqueue! (2nd msg))])
            (event-mgr 'next-event)))))))
\end{verbatim}
\end{quote}
\caption{The receptionist}
\label{fig:recep}
\end{frameit}
\end{figure}
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define event-mgr
  (let ([event-Q (queue)])
    (let ([insert! (event-Q 'insert!)]
          [dequeue! (event-Q 'dequeue!)]
          [update-all! (event-Q 'update-all!)])
      (lambda msg
        (case (1st msg)
          [(record) (insert! (2nd msg) 'time)]
          [(next-event)
           (let ([person (dequeue!)])
             (begin
               (update-all!
                 (let ([next-time (person 'time)])
                   (lambda (p) (p 'time! (- (p 'time) next-time)))))
               (unless (eq? person stop-patient)
                 (person 'event))))])))))
\end{verbatim}
\end{quote}
\caption{The event manager}
\label{fig:event}
\end{frameit}
\end{figure}

\subsubsection{The patient maker}

Each patient procedure has three functions: to call the receptionist when
the patient becomes sick, to compute a new time-to-sickness which is
passed to the event-manager, and to give personal information to procedures
which request it. The choice of function is determined by a message which is
passed to the procedure as an argument. Local to a patient procedure are a
patient's name and time-to-sickness.  The patient's name is specified in a
list of patient names that is supplied by the user as an argument to the
startup procedure called \svbt{doctors-patients-problem}
(Figure \ref{fig:test}). The initial
time-to-sickness is computed within the startup procedure and passed to the
event-manager.  One special procedure named \svbt{stop-patient}
(Figure \ref{fig:test}) is given a
time-to-sickness which corresponds to the duration of the simulation.  When
it is the turn of \svbt{stop-patient} to become ``sick'', the simulation
terminates.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define stop-patient (patient-maker 'stop))

(define doctors-patients-problem
  (lambda (patients doctors)
    (begin
      (stop-patient 'time! 100)
      (event-mgr 'record stop-patient)
      (for-each (lambda (p) ((patient-maker p) 'new-sick-patient)) patients)
      (receptionist 'init (map doctor-maker doctors)))))

(define test
  (lambda ()                                                 
    (doctors-patients-problem '("John" "Jim" "Joe" "Joy") '("Grace" "Sam"))))
\end{verbatim}
\end{quote}
\caption{A sample test}
\label{fig:test}
\end{frameit}
\end{figure}

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define queue
  (lambda ()
    (let ([front '()] [rear '()] [secure (lambda (expr) 'done)])
      (letrec ([enqueue!
                (lambda (item)
                  (secure (let ([list-of-item (cons item '())])
                            (if (null? front)
                                (begin (set! rear list-of-item)
                                       (set! front list-of-item))
                                (begin (set-cdr! rear list-of-item)
                                       (set! rear list-of-item))))))]
               [update-all! (lambda (proc) (for-each proc front))]
               [empty? (lambda () (null? front))]
               [dequeue!
                (lambda ()
                  (if (null? front)
                      (begin (write "The queue is empty.") (newline))
                      (let ([item (car front)])
                        (begin (set! front (cdr front))
                               (when (null? front) (set! rear '()))
                               item))))]
               [insert!
                (lambda (item field)
                  (let ([this-time (item field)])
                    (if (or (null? front) (< this-time ((car front) field)))
                        (if (null? front)
                            (enqueue! item)
                            (let ([c (cons item front)])
                              (set! front c)))
                        ((rec loop (lambda (before after)
                                     (cond
                                       [(null? after) (enqueue! item)]
                                       [(< this-time ((car after) field))
                                        (let ([c (cons item after)])
                                          (set-cdr! before c))]
                                       [else (loop after (cdr after))])))
                         front (cdr front)))))])
        (lambda (msg)
          (case msg
            [(update-all!) update-all!]
            [(enqueue!) enqueue!]
            [(dequeue!) dequeue!]
            [(insert!) insert!]
            [(empty?) empty?]
            [else (error "Bad command to queue:" msg)]))))))
\end{verbatim}
\end{quote}
\caption{The queue handler}
\label{fig:queue}
\end{frameit}
\end{figure}
\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define rand
  (let ([q 1])
    (lambda ()
      (if (eq? q 15) (set! q 1) (set! q (+ q 1))) q)))

(define SHOW-RELEASE
  (lambda (patient doctor)
    (begin
      (display "Dr. ")
      (display (doctor 'name))
      (display " releases ")
      (display (patient 'name))
      (display ".")
      (newline))))

(define SHOW-PERSON-SICK
  (lambda (patient)
    (begin
      (display (patient 'name))
      (display " has just gotten sick.")
      (newline))))

(define SHOW-PAIR-DOC-PAT
  (lambda (doc patient)
    (begin
      (display "Dr. ")
      (display (doc 'name))
      (display " treats ")
      (display (patient 'name))
      (display ".  Time to treatment end is ")
      (display (doc 'time))
      (display ".")
      (newline))))

(define 1st car)
(define 2nd cadr)
(define 3rd caddr)
\end{verbatim}
\end{quote}
\caption{Miscellaneous help procedures}
\end{frameit}
\end{figure}

\subsubsection{The doctor maker}

Each doctor procedure has three functions: to call the receptionist when
the patient he/she is paired with is about to be released, to compute a new
time-to-release which is passed to the event-manager, and to give personal
information to requesting procedures.  A message chooses the function.  Local
to a doctor procedure are a doctor's name and time-to-release.  The name of a
doctor is specified in a list of doctor's names which is an argument to the
startup procedure.

\subsubsection{The receptionist}

The receptionist does the bookkeeping necessary for doctor-patient pairing and
release.  A doctor-list and patient-queue are used to facilitate this
bookkeeping.  When no further pairings or release are possible at a
particular epoch, the receptionist calls the event-manager to initiate the
next event.

\subsubsection{The event manager}

The event-manager maintains a list of events and the times at which they will
occur in the order they are due to occur.  The event-manager has two functions:
to record future events in the event-list and to invoke the first procedure
in the event-list when the next event is due to occur.  A call from a doctor
or patient procedure results in that procedure being placed in the event-list
according to a time that accompanies the call.  A doctor procedure in the
event-list represents the future event that his/her patient is released.
A patient procedure in the event-list represents the future event that the
patient becomes ill.  The event-manager immediately returns after recording
an event.  When called from the receptionist, the event-manager invokes the
first procedure in the event-list.

\subsection{Our solution}

Initially, the startup procedure \svbt{doctors-patients-problem} is invoked
with a list of patient names and a list of doctor names as arguments.  A
\svbt{stop-patient} is given a time and it is recorded in the event-list by the
event-manager.  Then, for each patient name in the patient list, a patient
procedure is created and used to record itself and its first time-to-sickness
in the event-list.  A call to the receptionist to set up its doctor list
completes the startup procedure.  The second argument to {\tt receptionist} in
this case is a list of doctor procedures, one for each doctor in the list of
doctor names.  The receptionist places these doctor procedures in its
doctor-list.

The simulation proceeds as a round-robin of procedure calls.  All calls
to the receptionist result in a call to the event-manager.  When called from
the receptionist, the event-manager invokes the first procedure in the
event-list.  If it is a patient procedure the patient has become sick.  Thus,
the receptionist is invoked with instructions to pair the patient with an
available doctor when one becomes available.  If it is a doctor procedure the
patient being treated by that doctor has been released.  Thus, the paired
patient procedure is invoked with instructions to pass its next
time-to-sickness to the event-manager (which records the procedure and its
time-to-sickness in the event-list) and the receptionist is invoked with
instructions to make the doctor available.  If the patient-queue is
not empty, the receptionist pairs available doctors with as many waiting
patients as can be accomodated.  Each pairing results in a call to the paired
doctor procedure which computes a time-to-release that is recorded along
with the doctor procedure by the event-manager in the event-list.  When the
receptionist finishes all possible new pairings, it calls the event-manager
again and the cycle repeats.

\subsection{Queue control}

In order to support the doctor-list, patient-queue, and event-list operations,
we have included a queue-making procedure called \svbt{queue}
(Figure \ref{fig:queue}).  When invoked,
this procedure returns an empty queue and all the functions needed to maintain
it.  Access to each of these functions is by means of another call with an
argument specifying it.  For example, consider the sequence given in Figure
\ref{fig:seq}.
The variable \svbt{event-Q} is a procedure of one argument which contains
queue pointers \svbt{front} and \svbt{rear}, both initialized to nil.
\svbt{dequeue!}\ is a procedure of no arguments that removes the first
item from the queue and returns its value.  \svbt{person} is an item
that has been dequeued; it is either a doctor procedure or a patient
procedure. \svbt{next-time} is a time that has been returned by \svbt{person}.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
  ...
  (let ([event-Q (queue)])
    (let ([dequeue! (event-Q 'dequeue)]
          ...)
      ...
      (let ([person (dequeue!)])
        ...
        (let ([next-time (person 'time)])
          ...))))
   ...
\end{verbatim}
\end{quote}
\caption{Sample sequence}
\label{fig:seq}
\end{frameit}
\end{figure}

Additional ``queue'' functions are as follows.  \svbt{enqueue!}\ is a procedure
of one argument called \svbt{item} that is efficiently appended to the
queue by means of the \svbt{rear} pointer.  \svbt{empty?}\ is a procedure of
no arguments that returns {\it true} if and only if the queue is empty.
\svbt{insert!}\ is a procedure of two arguments called \svbt{item} and
\svbt{field} that is used by the event-manager to put \svbt{item} into the
queue at a place that keeps the queue in increasing order on \svbt{field}.
\svbt{item} is assumed to be a procedure (a doctor or a patient) and
\svbt{field} is a time.  \svbt{update-all!}\ is a procedure of one argument
called \svbt{proc} that is applied to each element in the queue.  It is used
by the event-manager to reduce the times associated with procedures in the
event-queue when a new event occurs.


From franco@ucunix Mon Oct  8 19:03:35 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA25744; Mon, 8 Oct 90 19:03:31 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 22:04 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA17403; Mon, 8 Oct 90
 22:06:02 -0400
Date: Mon, 8 Oct 90 22:06:02 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: John.Franco@UC.EDU, feo@lll-crg.llnl.gov
Message-Id: <9010090206.AA17403@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

sect-6.inp
===========
%sect-6.inp  -*- LaTeX -*-
\section{The Skyline-Matrix Problem}

We solve this problem by triangularizing the matrix from the lower right
corner to the upper left corner and then collecting terms from the upper
left corner to the lower right corner. The elements of the $b$-vector are
adjusted separately while triangularizing.  This is only because it looks
more pleasing visually.  We pay little penalty for this in extra
code since it is easy in Scheme to abstract the operations of adding two rows
and two scalars to one procedure.  Triangularization and $b$-vector
adjustment is accomplished by the procedure \svbt{skyline}
(Figure \ref{fig:skyline}) which zeros all
matrix elements of the rightmost matrix column by adding multiples of the last
row to higher rows containing non-zero elements in that column and recurses on
a matrix and $b$-vector that is one variable smaller.  Procedure \svbt{result}
(Figure \ref{fig:skyline}) does the collecting.

\begin{figure}
\begin{frameit}
%\begin{quote}
\begin{verbatim}
(define skyline
  (lambda (row-list row-skyline col-skyline b-list n)
   (if (null? row-list)
       '()
       (let* ([row-len (- (add1 n) (car row-skyline))]
              [col-len (- (add1 n) (car col-skyline))]
              [z ((multiplier-list (caar row-list))
                  (sub1 col-len) (cdr row-list))]
              [new-col-sky ((fix-skyline (car col-skyline)) row-len col-skyline)]
              [new-row-sky ((fix-skyline (car row-skyline)) col-len row-skyline)]
              [new-row-lst ((new-row (car row-list) col-skyline)
                            (sub1 col-len) (cdr row-list) z)]
              [new-b-list (cons (car b-list)
                                ((new-b-lst (car b-list))
                                 (sub1 col-len) (cdr b-list) z))])
         (cons (car row-list)
               (cons (car new-b-list)
                     (skyline new-row-lst
                              (cdr new-row-sky)
                              (cdr new-col-sky)
                              (cdr new-b-list)
                              (sub1 n))))))))

(define result
  (lambda (s-list)
    ((rec loop
          (lambda (sol s-list)
            (if (null? s-list)
                sol
                (let ([sum-prod (dot-prod (cdadr s-list) sol)])
                  (loop (cons (/ (- (car s-list) sum-prod) (caadr s-list)) sol)
                        (cdr (cdr s-list)))))))
     '() (reverse s-list))))
\end{verbatim}
%\end{quote}
\caption{The main procedures for the skyline-matrix problem}
\label{fig:skyline}
\end{frameit}
\end{figure}

\subsection{Input specification}

The input to \svbt{skyline} is a \svbt{row-list} of lists of non-zero row
elements, a \svbt{row-skyline} list, a \svbt{column-skyline} list, and a
\svbt{b-list}.  The order of the rows in the \svbt{row-list} is from bottom to
top and the order of elements in each list is reversed.  The elements of the
\svbt{row-skyline} list specify the left non-zero boundaries of the rows in
order from bottom to top.  The elements in the \svbt{column-skyline} list
specify the top non-zero boundaries of the columns in reverse order.  The
\svbt{b-list} is the reverse of the $b$-vector.  Thus, the following input

\begin{quote}
\begin{verbatim}
             (let ([row-list '((4 2 6) (8 6 1 16) (2 10) (12 14))]
                   [row-skyline '(2 1 2 1)]
                   [column-skyline '(3 1 2 1)]
                   [b-list '(10 4 2 1)])
               ...)
\end{verbatim}
\end{quote}

\noindent
represents the following linear system

\[ \left(\begin{array}{cccc} 14 & 0 & 12 & 0 \\ 0 & 10 & 2 & 0 \\
   16 & 1 & 6 & 8 \\ 0 & 6 & 2 & 4 \end{array} \right)X = \left(
   \begin{array}{c} 1 \\ 2 \\ 4 \\ 10 \end{array} \right). \]

\subsection{Output specification}

The output of \svbt{skyline} is a list which contains alternations of
lists of numbers and single numbers.  The single numbers are \svbt{b-list}
elements;  they may have changed due to row addition.  The lists are
consecutive matrix elements, in reverse order, at and to the left of the
diagonal; they also may have changed due to row addition.  From right to left,
the \svbt{b-list} element of the last row is followed by the diagonal element
(as a singleton list) of the last row.  Then comes the changed \svbt{b-list}
element of the next-to-last row and the list of non-zero elements of the
next-to-last row and so on.

Procedure \svbt{result} recursively builds a solution vector $X$ from input
supplied by \svbt{skyline}.  Suppose \svbt{sol} is a partial
solution covering the last $i$ variables of $X$.  We can extend \svbt{sol} to a
partial solution covering the last $i+1$ variables of $X$ as follows:  take
the dot-product of \svbt{sol} and all but the first matrix element of the
$i+1^{st}$ element list (counting from the right) and call it
{\it sumprod}; let the first element of the list be called
{\it diagelem} and let the $i+1^{st}$ single number be called {\it belem}.
Then the $i+1^{st}$ variable from the bottom has the value
$({\it belem} - {\it sumprod})/{\it diagelem}$.  Procedure \svbt{result}
recursively builds a solution vector in this fashion.

\subsection{Description of the procedures}

\svbt{skyline} recursively builds a list of matrix-elements and \svbt{b-list}
pairs from successively smaller submatrices and \svbt{b-list}s. This requires
computing the following new arguments for the recursive call to \svbt{skyline}:
a \svbt{row-list}, a \svbt{row-skyline}, a \svbt{column-skyline}, and a
\svbt{b-list}.  Of these four, both \svbt{b-list} and \svbt{row-list} require a
list of multipliers, one for each non-zero matrix-element above the lower
right diagonal element, which will be used when adding the last row to the
rows above it.

The multiplier-list is built by the procedure \svbt{multiplier-list}
(Figure \ref{fig:help}).  The
size of the list is determined from the first element of the column skyline.
Let $q$ be the lower right matrix element and let $r_1,r_2,..$ be the
non-zero elements in the rightmost column in order above $q$.  Then the
multiplier-list produced is $(-r_1/q,-r_2/q,...)$.  When the last row is
multiplied by $-r_i/q$ and added to the $i^{th}$ row above the last, the
rightmost element of that row is zeroed.  The call to \svbt{multiplier-list}
in \svbt{skyline} is in the \svbt{let*}.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define dot-prod
  (rec alpha (lambda (A B)
               (if (null? A)
                   0
                   (+ (* (car A) (car B)) (alpha (cdr A) (cdr B)))))))

(define fix-skyline
  (lambda (m)
    (rec alpha (lambda (n lst)
                 (if (zero? n)
                     lst
                     (cons (min m (car lst))
                           (alpha (sub1 n) (cdr lst))))))))

(define multiplier-list
  (lambda (q)
    (rec alpha (lambda (n lst)
                 (if (zero? n)
                     '()
                     (cons (- 0 (/ (caar lst) q))
                           (alpha (sub1 n) (cdr lst))))))))

(define add-row
  (lambda (row-numb mult)
    (rec alpha
         (lambda (t-row col old-row)
           (if (null? t-row)
               old-row
               (if (or (> (car col) row-numb) (null? old-row))
                   (cons (+ (* mult (car t-row)) 0)
                         (alpha (cdr t-row) (cdr col) old-row))
                   (cons (+ (* mult (car t-row)) (car old-row))
                         (alpha (cdr t-row) (cdr col) (cdr old-row)))))))))
\end{verbatim}
\end{quote}
\caption{Some help procedures}
\label{fig:help}
\end{frameit}
\end{figure}

Both new \svbt{row-list} and \svbt{b-list} are similarly built from the
multiplier-list and the old \svbt{row-list} and \svbt{b-list}.  The
difference is that, in the case of the \svbt{row-list}, lists are added
whereas, in the case of the \svbt{b-list}, scalars are added.  We abstract
out the common part and call it \svbt{abstract-1}
(Figure \ref{fig:abs}).  This procedure takes
another procedure \svbt{f} as argument and returns a procedure
which takes two lists, \svbt{list-1} and \svbt{list-2}, and a number \svbt{n}
as arguments.  When invoked, the returned procedure walks down both
\svbt{list-1} and \svbt{list-2} for a number of steps specified by \svbt{n},
applies \svbt{f} to each pair of \svbt{list-1} and \svbt{list-2} elements
encountered, and returns a list of results concatenated with the remainder
of \svbt{list-1}.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define abstract-1
  (lambda (f)
    (rec alpha (lambda (n list-1 list-2)
                 (if (zero? n)
                     list-1
                     (cons (f n (car list-1) (car list-2))
                           (alpha (sub1 n) (cdr list-1) (cdr list-2))))))))

(define new-b-lst
  (lambda (b-value)
    (abstract-1 (lambda (i z x) (+ (* x b-value) z)))))

(define new-row
  (lambda (a col-skyline)
    (abstract-1 (lambda (i ol ml)
                  (cdr ((add-row (+ (sub1 i) (car col-skyline)) ml)
                        a col-skyline ol))))))
\end{verbatim}
\end{quote}
\caption{More help procedures}
\label{fig:abs}
\end{frameit}
\end{figure}

The procedure \svbt{new-b-lst} (Figure \ref{fig:abs}) builds a new
\svbt{b-list} by
invoking \svbt{abstract-1} with \svbt{f} a procedure which multiplies a
\svbt{b-value} by an element of \svbt{list-2} (list-2 is the multiplier list) an
adds the result to an element of \svbt{list-1} (list-1 is the old b-list).

The procedure \svbt{new-row} (Figure \ref{fig:abs}) builds a new \svbt{row-list}
invoking \svbt{abstract-1} with \svbt{f} a procedure which applies the
procedure returned by \svbt{add-row} to an element of \svbt{list-2} (again, the
multiplier-list) and an element of \svbt{list-1} (now a list of rows).
The procedure returned by \svbt{add-row} (Figure \ref{fig:help}) takes the
product of a multiplier
and all elements of the first row in the old \svbt{row-list} and adds the
resulting list to the elements of a row in the rest of the \svbt{row-list}.
Since elements of a row in the \svbt{row-list} may be separated by zeros in the
given matrix, the \svbt{column-skyline} must be used to determine the proper
alignment of row elements when performing the row additions.  Hence the old
\svbt{column-skyline} is an argument to this procedure.  The procedure does not
do anything special in the unlikely event that a new element in a row is zero;
such an element is recorded as a zero.

It remains to show how the new \svbt{column-skyline} and
\svbt{row-skyline} are built.  The procedure for fixing both is
\svbt{fix-skyline}.  This procedure adjusts elements of the old
\svbt{column-skyline} or \svbt{row-skyline} which are associated with columns
or rows affected by the most recent set of row additions.  Since new zero
elements are recorded as such, this procedure only causes each new
\svbt{column-skyline} or \svbt{row-skyline} element to be the minimum
of its old value and the value of the \svbt{column-skyline} or
\svbt{row-skyline} element corresponding to the zeroed column.

\begin{figure}
\begin{frameit}
\begin{quote}
\begin{verbatim}
(define main
  (lambda ()
    (let ([rows '((4 2 6)(8 6 1 16)(2 10)(12 14))]
          [row-sky '(2 1 2 1)]
          [b-list '(10 4 2 1)]
          [col-sky '(3 1 2 1)])
      (let ([s-list (skyline rows row-sky col-sky b-list (length rows))])
        (begin
          (display s-list) (newline) (newline)
          (result s-list))))))
\end{verbatim}
\end{quote}
\caption{A sample test}
\end{frameit}
\end{figure}


From franco@ucunix Mon Oct  8 14:13:20 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23633; Mon, 8 Oct 90 14:13:18 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:12 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07306; Mon, 8 Oct 90
 17:14:12 -0400
Date: Mon, 8 Oct 90 17:14:12 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082114.AA07306@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

myway.sty
=============
% page layout
\evensidemargin=0cm     %%% should it be 0pt?
%\oddsidemargin=0cm      %%% should it be 0.5in?
\oddsidemargin  0.5in
\topmargin=-2cm         %%% should it be 0.5in?
\headsep=0.5cm
\textheight=8.5in       %%% was 24cm
\textwidth=6in          %%% was 17.2cm
\columnwidth=\textwidth
\marginparwidth 0pt
\marginparsep 0pt
\topmargin   0.5in

% a smaller verbatim
\def\verbatim{\small \@verbatim \frenchspacing\@vobeyspaces \@xverbatim}
\let\endverbatim=\endtrivlist


% smaller headings
\def\section{\@startsection {section}{1}{\z@}{-3.5ex plus -1ex minus
    -.2ex}{2.3ex plus .2ex}{\large\bf}}

\def\subsection{\@startsection{subsection}{2}{\z@}{-3.25ex plus -1ex minus
 -.2ex}{1.5ex plus .2ex}{\normalsize\bf}}

From franco@ucunix Mon Oct  8 14:13:44 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23638; Mon, 8 Oct 90 14:13:42 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:13 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07338; Mon, 8 Oct 90
 17:14:43 -0400
Date: Mon, 8 Oct 90 17:14:43 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082114.AA07338@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

scheme.tex
==========
% scheme.tex -- main file of the chapter ``Scheme'' in -*- LaTeX -*-


\documentstyle[11pt,myway]{article}

\title{The Scheme Programming Language}

\author{John Franco,\thanks{
                Supported by the Air Force Office of
                Scientific Research under grant AFOSR 89-0186 and
                the FAW Ulm, Germany.
                }
        \\
        Department of Computer Science \\
        University of Cincinnati \\
        Mail Location 8 \\
        Cincinnati, OH 45221 \\
        \\
        Daniel P. Friedman\thanks{
                Supported by the National Science Foundation under
                grant CCR 87-02117 and by the Air Force Office of
                Scientific Research under grant AFOSR 89-0186.
                }
        \\
        Department of Computer Science \\
        Indiana University \\
        Bloomington, IN 47405 \\
	\\
	Olivier Danvy,\thanks{This work was carried out during the
                Fall 1989 semester while visiting the Computer
                Science Department of Indiana University.
                }
        \\
        Department of Computing and Information Sciences \\
        Kansas State University \\
        Manhattan, KS 66506 \\
%       \{danvy, franco, dfried\}@iuvax.cs.indiana.edu
}

\date{\ }

\begin{document}
\input{mydef.inp}
%\begin{sloppypar}

\maketitle

\input{sect-1.inp}
\input{sect-2.inp}
\input{sect-3.inp}
\input{sect-4.inp}
\input{sect-5.inp}
\input{sect-6.inp}
\input{concl.inp}
\input{references.inp}

%\end{sloppypar}
\end{document}


From franco@ucunix Mon Oct  8 14:14:14 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23647; Mon, 8 Oct 90 14:14:12 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:14 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07387; Mon, 8 Oct 90
 17:15:54 -0400
Date: Mon, 8 Oct 90 17:15:54 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082115.AA07387@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

mydef.inp
===========
% mydef.inp -- this is a standard -*- LaTeX -*- file 


% Latin abbreviations
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}
\newcommand{\etc}{{\em etc.}}
\newcommand{\vs}{{\em vs.}}
\newcommand{\cf}{{\em cf.}}
\newcommand{\etal}{{\em et al.}}
\newcommand{\via}{{\em via}}


% Some Greek letters
\newcommand{\g}{\gamma}
\newcommand{\r}{\rho}
\renewcommand{\l}{\lambda} % was: "l with a slash"; who needs it?

\newcommand{\lam}{$\lambda$}

\newcommand{\sbv}[1]{\hbox{\([\![\)}\hbox{\svbt{#1}}\hbox{\(]\!]\)}}
\newcommand{\sbtt}[1]{\hbox{\([\![\)}\hbox{\tt #1}\hbox{\(]\!]\)}}
\newcommand{\svbt}[1]{{\small\tt #1}}
\newcommand{\hsvbt}[1]{\hbox{\small\tt #1}}

\newcommand{\lc}{\(\lambda\)-calculus}
\newcommand{\smn}{S^m_n}
\newcommand{\smnt}{\(S^m_n\)-theorem}

%%% Karoline's mymath.sty

\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{proof}{Proof}
\newtheorem{conjecture}{Conjecture}
\newtheorem{principle}{Principle}


% -----------------------------------------------------------------------------
  %% doframeit draws a box around it argument by manipulating boxes.  It
  %% is used in the frame environments.
  %% 
  %%  Rene' Seindal (seindal@diku.dk) Fri Feb 12 16:03:07 1988
  %%  added \fboxrule and \fboxsep to \doframeit

\def\doframeit#1{\vbox{%
  \hrule height\fboxrule
    \hbox{%
      \vrule width\fboxrule \kern\fboxsep
      \vbox{\kern\fboxsep #1\kern\fboxsep }%
      \kern\fboxsep \vrule width\fboxrule }%
    \hrule height\fboxrule }}

  %% The frameit and Frameit environments formats text within a single 
  %% Anything can be framed, including verbatim text.

\def\frameit{\smallskip \advance \linewidth by -7.5pt \setbox0=\vbox \bgroup
\strut \ignorespaces }

\def\endframeit{\ifhmode \par \nointerlineskip \fi \egroup
\doframeit{\box0}}
% -----------------------------------------------------------------------------

From franco@ucunix Mon Oct  8 14:15:25 1990
Return-Path: <franco@ucunix>
Received: from ucbeh.san.uc.edu by lll-crg.llnl.gov (5.61/LLNL-1.17)
	id AA23662; Mon, 8 Oct 90 14:15:23 -0700
Received: from ucunix.san.uc.edu (129.137.32.116) by UCBEH.SAN.UC.EDU with
 PMDF-822; Mon, 8 Oct 1990 17:16 EST
Received: by ucunix.san.uc.edu (5.57/Ultrix2.4-C) id AA07952; Mon, 8 Oct 90
 17:17:44 -0400
Date: Mon, 8 Oct 90 17:17:44 -0400
From: John.Franco@UC.Edu (John Franco)
Subject: Re:  Chapter
To: feo@lll-crg.llnl.gov, franco@iuvax.cs.indiana.EDU
Message-Id: <9010082117.AA07952@ucunix.san.uc.edu>
X-Envelope-To: feo@lll-crg.llnl.GOV
Status: R

concl.inp
========
% concl.inp in -*- LaTeX -*-

\section{Conclusions and Issues}

As illustrated in this chapter, Scheme is an essentially simple,
flexible, and orthogonal language.  Using the lambda tool, we have
solved a series of problems based on the versatile features of Scheme
and illustrating streams, eagerness {\em vs.}\ laziness, procedures as
first-class objects, programming actors and programming with actors,
and the controlled use of side-effects.

Still this chapter does not illustrate the full potential of
programming with Scheme, most remarkably regarding continuations.  To
this effect, we kindly direct the interested reader to the Scheme
literature as regularly listed in the ACM publication Lisp Pointers.



