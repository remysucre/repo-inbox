From mani@vlsi.caltech.edu Thu Jun  8 20:10:29 1989
Return-Path: <mani@vlsi.caltech.edu>
Received: from vlsi.caltech.edu by lll-crg.llnl.gov (5.61/1.14)
	id AA10820; Thu, 8 Jun 89 19:58:17 -0700
Received: by vlsi.caltech.edu (5.59/1.2)
	id AA10303; Thu, 8 Jun 89 16:19:28 PDT
Date: Thu, 8 Jun 89 16:19:28 PDT
From: mani@vlsi.caltech.edu (K. Mani Chandy)
Message-Id: <8906082319.AA10303@vlsi.caltech.edu>
To: feo@lll-crg.llnl.gov
Subject:  Paper
Status: R

\documentstyle[12pt]{article}

\title{Program Composition Notation}
 \author{K. Mani Chandy, Stephen Taylor\\
       California Institute of Technology\\
       }
 \date{6 June 1989}

 \begin{document}
 \maketitle
\section{Introduction}
Program Composition Notation (PCN) is a 
notation for composing programs.
The programs that are composed may be expressed in base languages (such as
Fortran, Lisp, or Strand) or in PCN itself.
The PCN research effort has a narrow focus; our goals are described next.

\paragraph{Program Composition Operators}
The traditional method of constructing programs is by sequential composition.
We are evaluating the thesis that other forms of program composition are
helpful, and that programmers should be able to define their own composition
operators for program composition. 
A goal of our effort is to identify proof rules for the 
composition operators, and to evaluate their efficacy in reasoning about
programs.
 
\paragraph{Concurrent Computer Implementations}
We seek to develop programs that execute efficiently on 
multicomputers (i.e., distributed
memory machines), shared memory multiprocessors, and SIMD machines.
A project on implementing PCN on multicomputers is underway at Caltech.
A variant of this notation has been developed and
is being implemented on the Connection
Machine at UCLA by Rajive Bagrodia.

\paragraph{Methodology}
We wish to propose a unifying framework for developing numeric, symbolic and 
reactive programs. 
Our intent is to develop programs by stepwise refinement, starting with 
programs with simpler proofs and refining them if they are not
adequately efficient.
A goal is to use existing libraries of programs in different base languages
in program development.



PCN is an outgrowth of UNITY \cite{book} and Strand \cite{Steve}.
PCN is influenced by Hoare's pioneering work on composition, \cite{Hoare},
though our goals are more limited than Hoare's; our effort has the 
three goals listed above, whereas Hoare is concerned with a formal 
notation for describing all (discrete) systems.

We have taken liberties with the notation by using symbols that are
not on standard computer keyboards. 
Our intent is to describe program composition operators rather than
to describe a specific language.

\section{Data Types}
PCN has the basic data types: boolean, integer,
single and double precision floating point number, character, and string.
The initial value of a variable of a basic data type is arbitrary.


\subsection{The Synchronization Type}
PCN has a data type called \bf synch \rm, for synchronization.
The initial value of a synch variable is a special symbol, $\phi$,
that indicates that the variable is undefined.
Programmers have the obligation of proving that a synch variable is
assigned at most one value. Given such a proof,
a synch variable is either undefined ($\phi$), or it is defined
(by its non-$\phi$ value) and its definition remains unchanged.
A synch variable can be assigned a value of any type.

A variable that is not declared is assumed to be a synch type; the
scope of the variable is the block in which it is named.

\subsection{The Tuple Data Type}
PCN has a data type called {\em tuple} which
is a sequence of items between braces `$\{$' and 
`$\}$'.
The elements of a tuple can be of arbitrary data types including 
tuples themselves.
The $i$-th element of a tuple $x$ is denoted by $x[i]$.
The time taken to access the $i$-th element of a tuple is
independent of $i$.
A tuple is identical to a one-dimensional array, except that
the elements of a tuple need not all be of the same type.
The function, $sizeof$, applied to a tuple returns its size.
A tuple can be defined by enumeration, as in $\{5,3,4\}$, or by quantification,
as described next.


\subsection{Quantification}
A sequence of items can be defined using quantification.

A $quantified$-$form$ has the syntax:\\
$\ll$ $identifier$ \bf in \rm \\
  $integer$-$expression$ .. $integer$-$expresion$  ::
$lexical$-$unit$ $\gg$.

The quantified-form,
 $ \ll i\; in \; n \; .. \;  m :: exp \gg$ 
is a sequence
in which the lexical unit $exp$ 
appears once for each instance of $i$ where $n \leq i \leq m$, 
and in the $k$-th appearance of $exp$, 
all instances of $i$ in $exp$ are replaced by $k$.
\paragraph{Examples}

$ \ll i \; $in$ \; 0 .. 2  :: x[i]+y[i] \gg  $ is the sequence \\
 $x[0]+y[0], x[1]+y[1], x[2]+y[2]$.\\
$ \ll i \; $in$ \; 0 .. 2  :: 5 \gg $ is the sequence $5,5,5$.\\
$ \ll i \; $in$ \; 0 .. 2  :: x[i] := y[i], u[i] := v[i] \gg $ \\
is the sequence of statements: \\
$ x[0] := y[0],  u[0] := v[0], x[1] := y[1], u[1] := v[1], 
x[2] := y[2], u[2] := v[2]$.


A tuple can be defined by a quantified-form between braces; for
example:
$\{ \ll i \; $in$ [0 \; .. \; 2] :: x[i] \gg \}$
is the tuple
$\{x[0],x[1],x[2]\}$.

Quantified forms can be embedded one in another.
The notation \\
$  \ll i,j \; $in$ \; n \; .. \; m :: exp \gg$ is equivalent to \\
$\ll i \; $in$ \; n \; .. \; m :: \ll j \; in \; [n \; .. \; m] :: exp \gg \gg$.
\\ 
The notation:
$  \ll i \; $in$ \; ni \; .. \; mi , 
j \; in \; nj \; .. \; mj :: exp \gg$ is equivalent to \\
$\ll i \; $in$ \; ni \; .. \; mi :: \ll j \; in \; nj \; .. \; mj :: 
exp \gg \gg$.

\paragraph{Guarded Expressions}
A guarded expression has the syntax, $guard \rightarrow expression$, where
$guard$ is a boolean expression.
The value of a guarded expression, $g \rightarrow e$, is defined as follows.
If $g$ holds then the value of $g \rightarrow e$ is the value of $e$; 
if $\neg g$ then the value of $g \rightarrow e$ is $empty$.
The symbol $empty$ is the identity element in concatenation (of sequences).
For example $\{ \ll i,j $in$ 0\; ..\; 1 :: \;(i  \leq j)\; \rightarrow\; l[i,j],
\;\;(i > j)\; \rightarrow \;u[i,j] \gg \}$\\
 is the tuple:
$\{\; l[0,0],l[0,1],u[1,0],l[1,1]\; \}$.

\paragraph{Dyadic Operators on Quantifed Expressions}

A $reduced$-$form$ has the syntax: \\
$dyadic$-$operator$ \bf over \rm $quantified$-$form$ \\
and the syntactic unit in the quantified form must be a (guarded or unguarded)
boolean, arithmetic, or string expression
If the quantified form is the empty sequence, the reduced-form is
the identity element of the dyadic operator, otherwise it is: \\
$t[0] \nabla t[1] \nabla \ldots \nabla t[k]$ \\
where the sequence specified
by the quantified form is $t[0] \ldots t[k]$,
and $\nabla$ is the dyadic operator.



\paragraph{Examples}

\begin{eqnarray*}
\sum_{i=n}^{m} A[i] & = &
+  over    \ll i \; in \; n \;.. \;m \; :: A[i] \gg . \\
\prod_{i=n}^{m} A[i] & = &
*  over   \ll i \; in \; n \;..\; m \; ::\; A[i] \gg . \\
\bigvee_{i=n}^{m} A[i] & = &
\vee  over   \ll i \; in \; n \;..\; m \; ::\; A[i] \gg . \\
+  over  \ll i,j \; in \; 0 .. 2  :: \; i > j \; \rightarrow \; u[i,j], 
\; \; i < j \; \rightarrow l[i,j] \gg  \\
& = & l[0,1]+l[0,2]+u[1,0]+l[1,2]+u[2,0]+u[2,1].
\end{eqnarray*}

\end{document}
\subsection{Arrays, Records and Sets}
Complex types can be created from 
other types by means of arrays, and records (structures). 

The notation supports the data types of sets of basic types and sets of
records of basic types (but not sets of synch types).
Sets of tuples are used for relations.
Set operations are membership, insertion, deletion, difference,
intersection, and union.

PCN also allows quantifications over sets.
Quantifications over sets have the same syntax as quantification over sequences,
except that the range $n \; .. \;  m$ is replaced by a set identifier.
The quantified forms, in this case, represent sets.
The dyadic operators on quantified forms that represent sets must be
associative and commutative.
A set can be enumerated or defined using quantified forms, in the same
way as tuples, except that different braces are used to enclose a sequence.
Sets are implemented by hashing.
Sets are not discussed further in this paper.


\section{Composition}
Programs are constructed by composing blocks.
The operators used in composing programs are either primitive operators
or user-defined operators.
In this paper we restrict attention to four primitive program composition 
operators:\\
sequential (;), 
parallel ($\|$), 
choice (?), and 
fair ($\sim$) composition.


Parameters are passed by reference.
A program has a declaration and a block as in $C$.
A block may have a declaration of local variables, as in $C$.
A block has a body; its syntax is described next
in BNF.
All nonterminal symbols are in italics, and all terminal symbols are in
plain or boldface type.
The notation $\prec su \succ$, where $su$ is a syntactic unit represents
a list of zero or more instances of the syntactic unit
where multiple instances are separated by commas.

\begin{tabbing}
$block$ ::$\; \;$ \= $assignment$ $|$ \\
          \> $procedure$-$call$ $|$ \\
          \> $guard$ $\rightarrow$ $block$ $|$ \\
        \> $\{$ $primitive$-$composition$-$operator$ 
                $\prec block \succ$ $\}$  $|$\\
        \> $\{$ $user$-$defined$-$composition$-$operator$ 
             $\prec argument \succ$ $\}$ \\
\end{tabbing}
\subsection{Assignment}
\paragraph{Expressions}
The expressions on the right hand side of an assignment are as in an imperative
notation except that an expression may be a tuple, or an
expression may include terms that are reduced expressions.
The elements of a tuple on the right-hand side of an assignment 
can be constants or variables, but not expressions.

An assignment $x := e$ is executed as follows. Consider two cases: 
\begin{description}
    \item[Case 1] Variable $x$ is of type synch 
          and $e$ is a variable or a tuple.
    \item[Case 2] Variable $x$ is an ordinary variable or $e$ is an
         expression other than a variable or a tuple.
\end{description} 
\paragraph{Case 1}
The value of $x$ becomes the {\em expression}, $e'$,
where $e'$ is obtained from $e$ by replacing all instances of non-synch
variables in $e$ by their current values.
In all subsequent evaluations of expressions or pattern matches that name
$x$, all instances of $x$ are replaced by the expression $e'$.
For example, the execution of the assignment, $x := \{y,z\}$, where $x$ and $y$ 
are synch variables, and $z$ is an ordinary variable with value $0$,
defines $x$ as $\{y,0\}$.

\paragraph{Case 2}
The value of $e$ is determined, as described later;
if the value of $e$ is not $\phi$,
$x$ gets the value of $e$, 
otherwise the assignment is executed again.

(Informally speaking, the assignment is executed as follows: wait until
the value of $e$ is non-$\phi$;  $x$ gets the non-$\phi$ value of $e$.)

The value of an expression, $e$, is determined as follows: 
If $e$ names a variable with value $\phi$, the value
of $e$ is  $\phi$.
If $e$ does not name a variable with value $\phi$, then 
the value of $e$ is equal to the value of an expression $e'$,
where $e'$ is obtained from $e$ as follows: Replace the values
of all ordinary variables in $e$ by their (current) values and
replace all synch variables in $e$ by their definitions.
The value of $e$ is determined by determining the value of $e'$.
The evaluation of an expression terminates if the value of the
expression is $\phi$
or if the expression names only constants.

The evaluation of an expression will not terminate if circular 
definitions are used. An example of a circular definition is:
 $x$ is defined as $y$, and $y$ is
defined as $x$, where $x$ and $y$ are synch variables.


\subsection{Guarded Blocks}
The meaning of a block which has the syntax $guard$ $\rightarrow$ $block$ is
given next.
The syntax of a guard is: \\
\begin{tabbing}
$match$-$part$ ::\=  \kill
$guard$ :: \> $predicate$ $|$ \\
           \> $match$-$list$ $|$ \\
           \> $match$-$list$, $predicate$ \\
$match$-$list$ :: \> $\prec$ $match$ $\succ$  \\        
$match$ :: \> $\{$ $\prec$ $pattern$-$identifier$ $\succ$ $\}$
$\lhd$ $variable$-$identifier$
\end{tabbing}
A guard evaluates to one of three values: {\em suspends}, {\em success},
or {\em failure}. A guard is evaluated as follows.
The match list (if any) in a guard is evaluated
before the predicate part. The match list of the guard is discussed
next.

\paragraph{Pattern Matches}
A match is a syntactic convenience to refer to elements of
tuples.
The pattern-identifiers in a pattern are not variables.
Pattern-identifiers need not be declared in the program heading.
All pattern-identifiers in a pattern match list must be distinct.


The pattern-match list is evaluated from left to right.
Let the next pattern-match evaluated in the evaluation of a guard, $g$, be:
\[ \{t_{1}, .. ,t_{k} \} \lhd x \]
where $t_{i}$ is a pattern-identifier, for all $i$.
Evaluation of a guard continues as follows:
\begin{itemize}
   \item  If $x$ evaluates to $\phi$ then $g$ evaluates to $suspends$, and
   evaluation of $g$ terminates.
   \item  If $x$ evaluates to a $k$-tuple then 
   then all instances of the pattern identifier, $t_{i}$, 
     to the right of the pattern match in the
    statement (i.e., in the guard and in the block) are replaced
    by $x[i]$, and the evaluation of $g$ continues with the next
    pattern match, if any, in the pattern match list; if all pattern matches
    in the guard have been evaluated, guard evaluation continues with
    the evaluation of the predicate:
    if the predicate evaluates to $\phi$, 
    then the guard evaluates to {\em suspends}; 
    if the predicate evaluates to $true$ then the guard evaluates to
    {\em success}; 
    if the predicate evaluates to $false$, then
    the guard evaluates to {\em failure}.
   \item  Otherwise (i.e., if $x$ evaluates to a value that is not 
   $\phi$ and not a $k$-tuple)
   $g$ evaluates to $failure$, and evaluation of $g$ terminates.
\end{itemize}

The execution of a block $b$ with syntax $g \rightarrow c$
is as follows.
If $g$ evaluates to:
\begin{description}
   \item[success] then execute $c$; block $b$ terminates when
   $c$ does,
   \item[failure] then skip, i.e., the execution of $b$ terminates,
   \item[$\phi$] then execute block $b$ again.
\end{description}
Informally, the execution of block $b$ is: wait until $g$ has a non-$\phi$
value; if $g$ has value $success$ then execute $c$ else skip.


The meaning of an unguarded block is the same as that of a guarded
block with a guard that always evaluates to $success$.
Therefore, the proof rules for block $true$ $\rightarrow$ $c$, and for
block $c$, are identical.


\subsection{Sequential Composition}
The execution of a block $\{;$ $\prec block \succ$ $\}$ is as follows: 
the blocks composed by sequential
composition are executed in sequence.
A sequential composition block terminates when the last block in its
block-list, $\prec block \succ$, terminates.


\subsection{Parallel Composition}
The execution of the block,  $\{\|$ $\prec block \succ$ $\}$, is 
as follows:
all blocks composed by parallel composition are executed in parallel.
A parallel composition block terminates when all blocks that it composes
terminate.

Blocks that are executed in parallel  may read and write common
variables.
Reading or writing one item of a basic data type is an atomic action.

An interleaving semantics is used to reason about parallel composition.
The following progress condition is guaranteed: 
At all points in the computation, for each block composed by 
parallel composition, the block has terminated or a statement
in the block will be executed eventually.


\subsection{Choice Composition}
The execution of the block  $\{?$  $\prec block \succ$ $\}$ is 
described in this section.

Restrict attention to choice blocks of the form:
$\{? \; \prec guard \rightarrow block \succ \}$.
(An unguarded block is treat as a guarded block with a $true$ guard.)

The execution of a choice block is as follows:
\begin{enumerate}
   \item If at least one guard in the choice block 
    evaluates to {\em success} then execute
   any block with a guard that evaluates to $success$.
   \item If all guards in the choice block evaluate to {\em failure} then skip.
   \item Otherwise (i.e., if no guard in the choice block evaluates 
   to {\em success},  and at least one guard
   evaluates to {\em suspends}) then repeat execution of the choice block.
\end{enumerate}

The execution of a choice block terminates if the evaluation of a guard 
succeeds and the block corresponding to the guard terminates, or if
evaluation of all guards in the block list fail.


\subsection{Fair Composition}
Fair composition is identical to choice composition except that
if control flows from a fair composition block to itself an
infinite number of times, then each of the guards in the list of
blocks composed by fair composition is evaluated infinitely often.

Consider the following programs that are identical except that the
first is defined by choice composition, and the second by fair
composition. \\

\vspace{5mm} 

\noindent
\begin{tabbing}
$\{?$  $true \rightarrow \{ ; \; q(x), p(x) \}$ \hspace{1cm}\= $p(x)$ \kill
$p(x)$  \> $p(x)$ \\
integer: $x$; \> integer: $x$;\\
$\{?$ \> $\{\sim$ \\
$true \rightarrow \{ ; \; q(x), p(x) \} $ 
\> $true \rightarrow \{ ; \; q(x), p(x) \} $ \\
$true \rightarrow \{ ; \; r(x), p(x) \}  $ 
\> $true \rightarrow \{ ; \; r(x), p(x) \}  $ \\
$\}$ \> $\}$
\end{tabbing} 
Program $p$ executes either $q$ or $r$ and then recursively calls itself.

The choice composition program allows more computations than the fair
composition program.
In the fair composition program both $q$ {\em and} 
$r$ are executed infinitely
often;
thus, it is always the case that $q$ will be executed eventually, {\em and}
$r$ will be executed eventually.
In the choice composition program, $q$ is executed infinitely often {\em or}
$r$ is executed infinitely often.
Therefore, the choice composition also allows computations in which 
either $q$ or $r$ is never executed after some point in the program.


Note: The only reason that we employ both choice and fair composition
operators is that a program implemented by using choice composition
is more efficient than one using fair composition.  Also, for
many programs, choice composition suffices.

The meaning of control flow from one block to another is defined
in terms of composition operators, in the Appendix.
Control flow has the obvious intuitive meaning from imperative programming:
control flows from a block to the next one in sequential composition,
from a block to all those spawned by parallel composition, and
from a choice or fair composition block to the one that is selected
for execution.
\section{Examples}
In this section a few programs are developed to illustrate the
composition operators.
Documentation within programs is in \sl slanted font. \rm
We begin with a simple program $flip$ that has two integer arguments,
and $flip$ interchanges the values of its arguments.
The body of the program is a sequential composition block.

\vspace{5mm}

\noindent
\begin{tabbing}
$\; \; \; $ $w$ := $u$, $\;$ $u$ := $v$,  $\;$ $v$ := $w$
$\; \;$ \sl Block \rm \=  \kill
$flip(u,v)$\\
integer: $u$, $v$; $\; \;$  \>\sl Declare parameters of program. \rm \\
$\{; \; \;$  \> \sl Begin sequential composition block. \rm \\
integer: $w$; $\; \;$  \> \sl Declare local variables  of block. \rm \\
$\; \; \; $ $w$ := $u$, $\;$ $u$ := $v$,  $\;$ $v$ := $w$
$\; \;$ \> \sl Block-list \rm \\
$\} \; \;$  \> \sl End sequential composition block \rm \\
               \> \sl and end program. \rm
\end{tabbing}


Next consider a program $f$ with three arguments, an integer $n$, a 
one-dimensional array $x$ indexed $i$ where $0 \leq i < n$, and an
index $j$ where  $0 < j < n$. 
The program flips $x[j-1]$ and $x[j]$ if they are not in ascending order.


\begin{tabbing}
$f(n,j,x)$ \\
integer: $n$, $j$; \\
array $[0 \; .. \; n-1]$ of integer: x ; \\
$(x[j-1] > x[j]) \rightarrow  flip(x[j-1],x[j]) \;\;\;\;$
\sl Single statement program. \rm \\
\end{tabbing}

Next we write programs, $s0$, $s1$, $s2$, each 
with two arguments: $n$ and $x$
where $x$ is an array indexed $[0\;  .. \; n-1]$, 
and where the postcondition of
each program is that $x$ is in ascending order.
For purposes of exposition assume that the elements of $x$ are distinct.

\subsection{Simple Sort}



\paragraph{Choice Composition}
As in UNITY, the simplest sorting routine is to flip any pair
of elements of $x$ that are out of order, and then repeat the sort procedure.

\vspace{5mm}

\noindent
$ s0(n,x) $ \\
integer: $n$; \\
array $[0 \; .. \; n-1]$ of integer: $x$; \\ 
$ \{? $ 
$\ll i$ in $ 1 \; ..  \; n-1 $ :: 
$(x[i-1] > x[i]) \rightarrow \{ ; flip(x[i-1],x[i]), s0(n,x)\}\gg$\\
$\}$


\paragraph{Sequential Composition}
The bubble sort is defined in the obvious way using sequential composition. 

\vspace{5mm}

\noindent
$s1(n,x) $\\
integer: $n$; \\
array $[0 \; .. \; n-1]$ of integer: $x$; \\
$\{;$ 
$\ll$ $t$ in $\;$  1 .. $n-1$ 
, $i$ in  $\;$  1 .. $n-t$ :: $f(n,i,x)$  $\gg$ $\}$ \\

\paragraph{Parallel Composition}
The odd-even transposition sort is defined using sequential and parallel
composition.
On every odd step, for all odd $i$, $x[i-1]$ and $x[i]$ are flipped if they
are out of order, and on even steps the same is done for even $i$.


\begin{tabbing}
$s2(n,x)$ \\
integer: $n$; \\
array $[0 \; .. \; n-1]$ of integer: $x$; \\
$\{;$
$\; \;$  \= $\ll$ $t$ in  0 $\;$ .. $\;$ $n$ :: \\
$ \; \; \; \{\| \; \; $  $\ll$ $i$ in  1 $\;$ .. $\;$ $n$ ::
$((t-i) $mod$ \; 2 \;= \;0) \rightarrow f(n,i,x)$ $\gg$ $\}$ \\
\> $\gg$ \\
$\}$
\end{tabbing}


Next we present the odd-even transposition sort program using 
synch variables.  
The parameters of the program are $n$ and two arrays, $x$ and $y$, indexed $i$, 
where $0 \leq i < n$. 
The program does not modify $n$ or $x$.
The postcondition of the program is that $y$ is the sort of $x$.
The program uses a local array $z$ indexed $t$, $i$ where $0 \leq t < n+2$.

\subparagraph{Specification}
The specification of the program
is the following set of equations:\\
\[ \forall \; i \; where 0 leq i leq n-1 :: z[0,i] = x[i] \]
\[ \forall \; i \; where 0 leq i leq n-1 :: y[i] = z[n+1,i]\]
\begin{eqnarray*}
\forall \; i,t \; where 0 leq i leq n-1, and where 0 \leq t \leq n :: \\
z[t+1,i] = & min(z[t,i],z[t,i+1]) \; if \; (i-t)\; mod \; 2 \; = 0, \\
         & max(z[t,i-1],z[t,i]) \; if \; (i-t) \; mod \; 2 \; \not = 0
\end{eqnarray*}       

\subparagraph{Program}
The program is a syntactic transformation of the specification:
\begin{tabbing}
$s3(n,x,y)$\\
integer: $n$; \\
array $[0 \; .. \; n-1]$ of integer: $x$, $y$;\\
$\{\|$ array $[0 \;  .. \; n+1, \; 0 \; .. \; n-1]$ of synch integer: $z$;  \\
  $\ll$ $i$ in $0$ .. $n-1$ :: \= $z[0,i]$ := $x[i]$, \\
\> $y[i]$ := $z[n+1,i]$, \\
      $\ll$ $t$ in $0$ .. $n$ :: \=
$z[t+1,i]$ := \=  $((i-t)\; $mod$ \; 2 \; = 0$ $\rightarrow$ 
min$(z[t,i],z[t,i+1])$,\\
\> \> $(i-t) \; $mod$ \; 2 \; \not = 0$ $\rightarrow$ max$(z[t,i],z[t,i-1]))$ \\
  $\gg \gg \}$
\end{tabbing}
\section{ Hamming's Problem}
Given a tuple $p$ of relatively prime numbers, and a positive integer
$n$, produce an output $z$ which is a list of multiples of numbers in $p$.
List $z$ has $n$ elements and is in increasing order.

The program uses the following local variables: 
Let $m$ be the size of tuple $p$.
Variable $x$ is an array $[ 0 \; .. \; m-1]$ of tuple, and $d$, $y$ are tuples.
The elements of array $x$, and variables $d$, $y$, are tuples that represent
lists.

\vspace{5cm}


The program is a parallel composition of:
\begin{itemize}
   \item A program, $mult$, that 
         defines an element of list $x[i]$ as the product of 
         the corresponding element of list $z$ and $p[i]$.
         There is one $mult$ program for each $i$.
   \item A program, $merge$, that merges the $m$ lists in $x$ to
         produce the list $y$. 
   \item List $d$ is defined as the number 1 followed by list $y$,
         i.e., $d = \{1,y\}$.
   \item A program $firstn$ that defines the output sequence $z$ as
         the first $n$ elements of list  $d$.
\end{itemize}

\vspace{5mm}

\begin{tabbing}
$hamming(p,n,z)$ \\ 
$\{\|$ \= \\ 
 \> array $[0 \; .. \; m-1]$ of synch: $x$; \\
 \>   $\ll$ $i$ in $0$ .. $m-1$ :: $mult(z,p[i],x[i])$ $\gg$, \\
 \>   $merge(x,m,0,m,y)$, \\
 \>   $d := \{1,y\}$ \\
 \>   $firstn(d,n,z)$ \\
$\}$ \\
\end{tabbing}

\paragraph{mult}
The first argument of $mult$ is an input list $z$, 
and its second is an input integer, $q$;
its output argument is a list $v$, obtained by multiplying each element
of $z$ by $q$.

The value of $v$ in program $mult(z,q,v)$ is defined as follows:
\begin{enumerate}
   \item If $z$ is the empty list, then $v$ is the empty list.
   \item If the head and tail of $z$ are $hz$ and $tz$, respectively, then
         $v = \{w, \; tv\}$, where 
         $w = hz*q$, and where $tv$  is defined by $mult(tz,q,tv)$.
\end{enumerate}

\begin{tabbing}
$mult(z,q,v)$ \\
integer: $q$;\\
$\{?$ $\; \;$ \= ,$\{ hz , tz \}$ \= $\lhd$ $z$ \= $\rightarrow$  \= \kill
$\{?$ 
\> $\{\}$ $\lhd$ $z$ \> \> $\rightarrow$ \>  $v := \{\}$ \\
\>,$\{ hz , tz \}$  $\lhd$ $z$ \> \>  $\rightarrow$ \>
$\{ \|$ $v$ := $\{ w , tv \}$, $w := hz*q$, $mult(tz,q,tv)$ $\}$\\
$\}$
\end{tabbing}

\paragraph{merge}
Program merge has the following input parameters: the array, 
$x$, the integer $m$, and two indices $lo$ and $hi$.  
Program $merge$ merges the
lists $x[lo]$, .. , $x[hi-1]$.  It has a single output parameter $q$,
the merged list.

The program calls another program $m2$ which merges $two$ lists. 
Program $merge$ is implemented as a balanced binary tree of $m2$ programs. 

The output of program $merge$ is a function of its inputs.
Output $q$ is defined as follows:
\begin{enumerate}
   \item If $hi-lo=1$, then the output list $q$ is the same as the input list
   $x[lo]$.
   \item If $hi-lo=2$, then the output list $q$ is defined by 
   $m2(x[l0],x[hi],q)$, where $m2$ merges its two input lists $x[lo]$ and
   $x[hi]$ to produce its output list $q$.
   \item If $hi-lo > 2$, then output list $q$ is defined as follows:\\
   Define $mid$ as $(lo+hi)/2$. Note: $lo < mid < hi$. \\
   Define list, $lopart$, by $merge(x,m,lo,mid,lopart)$. \\
   Define list, $hipart$, by $merge(x,m,mid,hi,hipart)$. \\
   Define $q$ by $m2(lopart,hipart,q)$. 
   
   Output $q$ is a merge of $lopart$ and
   $hipart$, where  $lopart$ and
   $hipart$ are merges of the lists in $x[i]$ for $lo \leq i < mid$,
   and $mid \leq i < hi$, respectively.
\end{enumerate}   


\begin{tabbing}
$merge(x,m,lo,hi,q)$\\
integer: $m$, $lo$, $hi$; \\
array $[0 \; .. \; m-1]$ of synch tuple: $x$; \\
synch tuple: $q$ ;\\
$\{$ \= ? $\; \; \;$ \= $(hi - lo) = 1 \rightarrow q := x[lo]$ \\
 \> ,  \> $(hi - lo) = 2 \rightarrow m2(x[lo], x[lo+1],q)$ \\
 \> ,  \> $(hi - lo) > 2 \rightarrow$  \= $\{ \| $ \= 
                                                  synch integer $\; \; mid$; \\
                     \> \> \> \>                , $mid := (lo + hi) /2$ \\
                     \> \> \> \>                , $merge(x,m,lo,mid,lopart)$ \\
                     \> \> \> \>                , $merge(x,m,mid,hi,hipart)$ \\
                     \> \> \> \>                , $m2(lopart,hipart,q)$ \\
                    \> \> \>            $\}$ \\
$\}$
\end{tabbing}

\paragraph{m2}
Program $m2$ has two input tuples $u$ and $v$, and a single output
tuple $w$. 
Tuples $u$, $v$ and $w$ represent lists. 
Output $w$ is defined as follows:
\begin{enumerate}
   \item If an input, $u$ or $v$, is the empty list, then $w$ is the empty list.
   \item If $u = \{ hu , tu \}$ and $v = \{ hv , tv \}$, then
         there are 3 cases: \\
         If $hu < hv$, then $w = \{hu, tw\}$, 
         where $tw$ is defined by $m2(tu,v,tw)$.\\
         If $hv < hu$, then $w = \{hv, tw\}$, 
         where $tw$ is defined by $m2(u,tv,tw)$. \\
         If $hu = hv$, then $w = \{hu, tw\}$ 
         where $tw$ is defined by $m2(tu,tv,tw)$.
\end{enumerate}
\begin{tabbing}
$m2(u,v,w)$ \\
$\{?$ \\
$\; \; \; \;$ \= $\; \; \;$ \= 
$(\{\} \; \lhd \; u)$ $\rightarrow$ $w := \{\}$ \\
\> , \> $(\{\} \; \lhd \; v)$ $\rightarrow$ $w := \{\}$ \\
,\> $(\{ hu , tu \} \; \lhd \; u)$ , \=
$(\{ hv , tv \} \; \lhd \; v)$ $\rightarrow$ \\
\> $\{?$ \= \\
\> \> $hu < hv$ $\rightarrow$ $\{\| \; w := \{hu, tw\}, \; m2(tu,v,tw)\}$ \\
\> \> $hu > hv$ $\rightarrow$ $\{\| \; w := \{hv, tw\}, \; m2(u,tv,tw)\}$ \\
\> \> $hu = hv$ $\rightarrow$ $\{\| \; w := \{hu, tw\}, \; m2(tu,tv,tw)\}$ \\
\> $\}$
$\}$ 
\end{tabbing}

\paragraph{firstn}
Program $firstn$ has inputs, list $d$ and integer $n$, 
and it has output list $z$.
The output is the first $n$ elements of $d$.
The output is defined as follows:\\
If $n=0$ or $d$ is empty, then $z$ is empty. \\
If $n > 0$ and $d = \{hd,td\}$, then $z = \{hd,tz\}$ where $tz$ is
defined by $firstn(td,n-1,tz)$.
\begin{tabbing}
$firstn(d,n,z)$ \\
integer: $n$ ; \\
$\{?$ \= $(n = 0)$  $\rightarrow$ $z := \{\}$ \\
      \> $(d = \{\})$ $\rightarrow$ $z := \{\}$ \\
      \> $(\{hd,td\} \lhd d),(n>0)$ $\rightarrow$ \\
      \>$\;\;\; \;\{\|\; z := \{hd,tz\}, \; firstn(td,m,tz), \; m := n-1 \}$ \\
$\}$
\end{tabbing}

 



\section{Paraffins}
The interconnection structure of carbon molecules of a paraffin 
form a free tree in which a vertex has
at most four neighbors.
A free tree has one centroid or two centroids that are neighbors.
Therefore, a free tree in which each vertex has atmost four neighbors
can be represented by:
\begin{enumerate}
   \item A single centroid connected to at most four rooted trees, 
   where each vertex in each rooted tree has at most 3 sons, or
   \item Two centroids, each of which is a rooted tree,
   where each vertex in each rooted tree has at most 3 sons.
\end{enumerate} 
\b Therefore, the core of the problem is to represent all rooted trees,
in which each vertex has at most 3 sons. \rm


\subsection{Rooted Trees}
In this section we use the term `rooted tree' to mean a rooted tree in
which a vertex has at most 3 sons.
Rather than merely print all free trees we shall employ a simple data
structure to store all free trees of a given size.
In other words, we shall store all representation of paraffins
in a data structure, and we can carry out computations on paraffins.

Next, we describe the data structure employed to store all rooted trees
with at most $n$ vertices.
Let $t$ be an array of tuples.
Tuple $t[m]$ is the sequence of rooted trees with $m$ vertices, where $m > 1$. 

A rooted tree has 0 vertices, or it has 1 vertex, or it has
a root which has 3 children, where each child is a rooted tree.

A rooted tree with more than 1 vertex is represented {\em uniquely} by a 
tuple $\{i,u,j,v,k,w\}$,
where $i$, $j$, and $k$ are the number of vertices in the 3 children
of the root, and $u$, $v$ and $w$ are the indices
to the children in sequences $t[i]$, $t[j]$, $t[k]$, respectively.
Thus the first child is $t[i][u]$, and the second is $t[j][v]$,
and the third is $t[k][w]$.
The values $i$, $j$, $k$, satisfy $m-1 = i+j+k$, where $m$ is the
number of vertices in the tree.
Uniqueness is maintained by ensuring a lexicographic ordering between
$(i,u)$, $(j,v)$ and $(k,w)$.

\vspace{6cm}

Let $s[m]$ be the number of rooted trees with $m$ vertices.

\paragraph{Program to Generate Rooted Trees}
The program has input parameter $n$: All rooted trees with at most $n$
vertices are to be generated.
The program has output parameter $t$, the array of sequence of trees.
Consider the three children of a tree with $m+1$ vertices, where
$m>0$.
Consider a tree represented by the tuple $\{i,u,j,v,k,l\}$.
\subparagraph{First Child}
The first child must have at least $m/3$ vertices because the number of
vertices in the first child is at least the number of vertices in the
other two children.
The first child can have at most $m$ vertices.
Therefore $i$ can take on values in the range $ceiling(m/3)$ .. $m$.
The index, $u$, of the first child is in the range 0  to $s[i]-1$
\subparagraph{Second Child}
The second child must have at least $(m-i)/2$ vertices because it
has at least as many vertices as the third child, and the second and
third child together have $m-i$ vertices.
The second child can have at most $m-i$ vertices.
Therefore $j$ can take on values in the range $ceiling((m-i)/3)$ .. $(m-i)$.
If $i > j$,
the index, $v$, of the second child is in the range 0 to $s[j]-1$.
If $i = j$, to ensure that $(i,u)$ is lexicographically greater than or
equal to $(j,v)$, we require that $u \geq v$.
We can do this in several ways: We have chosen to ensure lexicographic
ordering by means of a guard $(i > j) \vee (u \leq v)$.
\subparagraph{Third Child}
The third child has precisely $m-i-j$ vertices.
If $j > k$,
the index, $w$, of the third child is in the range 0 to $s[k]-1$.
If $j = k$, to ensure that $(j,v)$ is lexicographically greater than or
equal to $(k,w)$, we require that $v \geq w$.


The program assigns a tuple to $t[m+1]$ in sequence for $m$ in 1 .. $n-1$.
The tuple assigned to $t[m+1]$ has a sequence of elements, each of
which is a tuple $\{i,u,j,v,k,w\}$.  
The tuple assigned to $t[m+1]$ is defined by quantification over
$i$, $j$, $k$, $u$, $v$, $w$, given in the paragraphs describing the
three children.


\begin{tabbing}
$rt(n,t)$ \\
integer: $n$; \\
array $[ 1$ .. $n]$ of tuple: $t$; \\
$\{;$ \\
$s[0]$ := 1 ,$s[1]$ := 1 \\
,$ \ll$ $m$ in $1$ .. $n-1$ ::
$t[m+1]$ :=  $\{$ \= $\ll$ $i$ in $(m/3)$ .. $m$, \\
           \> $j$ in $(m-i)/2$ .. $min(i,m-i)$,\\
           \> $k$ in $(m-i-j)$ .. $(m-i-j)$, \\
           $u$ in $0$ .. $s[i]-1$, 
           $v$ in $0$ .. $s[j]-1$,
           $w$ in $0$ .. $s[k]-1$  :: \\
$((i > j) \vee (u \leq v)) \wedge ((j > k) \vee (v \leq w )) 
\rightarrow \{i,u,j,v,k,w\}$ \\
\> $\gg \}$ \\
,$s[m]$ := $sizeof(t[m])$ \\
$\gg$ \\
\}
\end{tabbing}

Next we give the program for printing a rooted tree.
A simple program is to print $t[i]$ for all $i$;
however, representing a tree by a six-tuple may not give adequate
information about the structure of the tree; so we also propose 
another algorithm.
The program $p$ has input parameters $t$, the indices $i$, $j$ in $t$
of the tree to be printed, and for convenience, the level number, $l$, of
the tree and the son number,$s$, where sons are numbered 0,1,2.
\begin{tabbing}
$p(t,i,u,l,s)$ \\
array $[ 1$ .. $n]$ of tuple: $t$ ; \\
integer: $i$,$u$,$l$,$s$; \\
\{;
print(`level',$l$,`son',$s$, `number of vertices',$i$) \\
, $(i > 1) \rightarrow  \{$ ; $k$ in $[ 0$ .. $2]$ :: $p(t,t[i][u][2*k], 
t[i][u][1+2*k],l+1, k)$ \} \\
\}
\end{tabbing}

Next we give the program to print all free trees, of size $m+1$
 with a single centroid.
It is similar to the program that constructs all rooted trees, because
it generates all rooted trees in which the root has at most 4 sons,
and all other vertices have at most 3 sons.

\begin{tabbing}
$single(m)$ \\
integer: $m$ ; \\
$\{;$ \=
$\ll$      \= $i$ in $[(m/4)$ .. $m]$, \\
        \>   \> $j$ in $[(m-i)/3$ .. $min(i,m-i)]$,\\
         \>  \> $k$ in [$(m-i-j)/2$ .. $min(j,m-i-j)]$, \\
         \>  \> $l$ in [$(m-i-j-k)$ .. $(m-i-j-k)]$, \\
         $u$ in 0 .. $s[i]-1$,
         $v$ in 0 .. $s[j]-1$,\\
         $w$ in 0 .. $s[k]-1$,
         $x$ in 0 .. $s[l]-1$ :: \\
$((i > j) \vee (u > v)) \wedge ((j > k) \vee (v > w )) \wedge 
((k > l) \vee (w > x ))
\rightarrow $ \\
$\{ ; \;  p(t,i,u,1,0),p(t,j,v,1,1),p(t,k,w,1,2),p(t,l,x,1,3)\}$ \\
\> $\gg$  \\
\}
\end{tabbing}

Finally we give the program for printing all free trees with double
centroids.
\begin{tabbing}
$double(n)$ \\
integer: $n$ ; \\
$n \; $mod$ \; 2 \; \; = 0 \; \; \rightarrow$
\= $\{;$ 
\= $\ll$      \=  $u$ in $[0$ ..  $s[n/2] - 1]$, \\
    \>    \>    \> $v$ in $[u$ .. $s[n/2] - 1]$ :: \\
\> \> \> $ \rightarrow \{ ; \;  p(t,n/2,u,1,0),p(t,n/2,v,1,0) \}$ \\
\> \> $\gg$  \\
\> \}
\end{tabbing}
The program for printing all free trees of size up to $n$ is simply
the sequential composition of $single(m)$ and $double(m)$ for all
$m$ in $[1$ .. $n]$.


\section{Doctors' Office}
Let patients be indexed $i$ where $0 \leq i < np$.
Let $sick[i]$ be the road that the $i$-th patient takes to go to the
hospital.
All sick patients enter through a door, and thus form a single queue
for the receptionist.
The list of sick patients waiting for the receptionist
is called $admit$.
The entry door is modeled by the program $merge$ with 
input parameter --- the array $sick$ --- and
an output parameter: the list, $admit$.
Program $merge$ merges its input lists (i.e., elements of its input array)
to produce the output list.
A fair merge is used because every patient who gets to the entry door
passes through it eventually.

\vspace{6cm}

Let doctors be indexed $j$ where $0 \leq j < nd$.
The list of available doctors waiting at the receptionist's
desk is called $d$;
each entry in the list is the id of a doctor.

The receptionist takes elements of $admit$ and $d$ and
produces a list of sick-patient - doctor pairs.
This list is called $spd$.

The list of sick-patient - doctor pairs goes through a passage and 
each patient-doctor pair then enters
the appropriate doctor's office.
Let the list of patient-doctor pairs entering the office of the $j$-th doctor be
$office[j]$.
The passage is modeled by a program $fork$ with input parameter ---
the list  $spd$ --- and an output parameter: the array $office$.
Each entry in the input list of program $fork$ contains an index into
its output array; an entry in the input list is copied into the specified
output list.

The list of patient-doctor pairs leaving office $j$ is called $happy[j]$.
A patient is cured in arbitrary (finite) time.
The process of curing by doctor $j$
is modeled by a program $ran$ that has a single
input list --- $office[j]$ --- and a single output list
$happy[j]$. Elements from the input list of program $ran$ are
placed in its output list after an arbitrary finite number of steps.

Patient - doctor pairs leaving each of the doctor's offices pass through
a door and joins a single output list,
$cured$, of patient-doctor pairs.
The door is modeled by a program $merge$ with input, $happy$, and
output $cured$.

The receptionist processes the elements of $cured$: The doctor
identified by the doctor-field joins a list $fd$ of doctors who
have finished seeing the receptionist. The list $d$
of available doctors is the initial queue of available doctors followed by $fd$.
The patient identified by the patient-field in $cured$
 joins the list, $out$ of patients going home.
 
A patient at the head of list $out$ goes through the exit and then goes to
to his or her home; let the road home for patient $i$ be $healthy[i]$.
The exit is modeled by a program $fork$
which has input, $out$, and output, $healthy$.

A healthy person becomes sick in an arbitrary finite time.
Thus an entry in list $healthy[i]$ becomes an entry in list $sick[i]$
in arbitrary finite time.
We model patient $i$ falling ill by program $ran$ which has input
$healthy[i]$ and input $sick[i]$. 

\paragraph{Initial Conditions}
We assume that initially all patients are healthy and all doctors
are available.
Therefore, the input to $p[i]$ is the initial value $i$ (because patient
$i$ is healthy initially) followed by sequence $healthy[i]$ of returns
from the hospital after being cured.
The sequence of available doctors $d$ is the sequence of doctors in
increasing order of id ( i.e., the sequence $j$ for $j$ from 0 up to
$nd-1$) followed by $fd$, the sequence of doctors who finish seeing the
receptionist.
We define $d$ by a program $makelist$ that has inputs $nd$ and $fd$
and output $d$.



\begin{tabbing}
$hospital(admit, spd, out, np, nd)$ \\
integer: $np$, $nd$ ; \\
$\{ \|$ \= \\
     \> array $[ 0 \;$ .. $\; np-1]$ of synch: 
         $healthy$, $sick$; \\
     \> array  \= $[ 0 \;$  .. $\;  nd-1]$ of synch: 
                  $office$, $happy$; \\
  \>   \> $\ll i \; $in$ [0 \; .. \; np-1] :: 
  ran( \{ i , healthy[i] \} , sick[i]) \gg$ \\
  \>   \> ,$merge(sick,np,0,np,admit)$ \\
  \>  \>  ,$receptionist(admit,d,cured,spd,out,fd)$  \\
  \>  \>  ,$fork(spd,nd,office)$  \\
  \>  \>  ,$\ll j  \; in [ 0 \; .. \; nd-1] :: 
                   ran(office[j],happy[j]) \gg$ \\
  \>   \> ,$merge(happy,nd,0,nd,cured)$ \\
  \>   \> ,$fork(out,np,healthy)$ \\
  \>   \> ,$makelist(nd,fd,d)$ \\
$\}$
\end{tabbing}

\subsection{ran}
Program $ran$ has a single input sequence $x$ and a single output sequence $y$.
An element in the input sequence is placed in the output after 
an arbitrary (finite) number of steps.
In the following program, if the first guard is chosen, an element 
from $x$ is placed in $y$.
If the second guard is chosen, $y$ remains unchanged.
The first guard will be chosen eventually because the program is constructed
using fair composition.
(If we want to allow the possibility of healthy patients remaining
healthy forever, choice composition would be used in place of fair
composition.)
If the input is the empty list then the output is the empty list.


\begin{tabbing}
$ran(x,y)$ \\
$\{\sim$ \=
$(\{ hx , tx \} \lhd x)$ $\; \; \;$ \= $\rightarrow \{\| ran(tx,ty), \;
                  y := \{ hx , ty \} \}$ \\
,\> $(\{ hx , tx \} \lhd x)$ \> $\rightarrow  ran(x,y) $  \\ 
,$(\{\} \lhd x)$ \>  $\rightarrow y := \{\}$            
$\}$
\end{tabbing}


\subsection{merge}
We use a tree of merge programs, as in Hamming's problem, except that
the program for merging two sequences is different.
Here we give only the program, $m2$, for merging two sequences, because
the remainder of the program is identical to Hamming's problem.

Program $m2$ has two input lists $u$ and $v$, and a single output list $w$.
Program $m2$ defines a relation between $u$, $v$, and $w$,
by giving values of $w$ that satisfy the relation
for given values of $u$ and $v$.
List $w$ is defined in terms of $u$ and $v$ as follows:

\begin{enumerate}
\item If both $u$ and $v$ are empty lists then $w$ is the empty list.
\item If list $u$ is not empty then let $hu$ and $tu$ 
      be the head and tail (respectively) of  $u$ ; 
      list $w$ is defined as $\{hu,tw\}$, where $tw$ is defined
      by the relation $m2(tu,v,tw)$, {\em or}
\item if list $v$ is not empty then let $hv$ and $tv$ 
      be the head and tail of $v$ (respectively); 
      list $w$ is defined as $\{hv,tw\}$, where $tw$ is defined
      by the relation $m2(u,tv,tw)$.
\end{enumerate}
\begin{tabbing}
$m2(u,v,w)$ \\
$\{ \sim$ \\
$(\{\} \lhd u),(\{\} \lhd v) \rightarrow w:= \{\} $ \\
,$(\{ hu , tu \} \; \lhd \; u)  \rightarrow  
\{ \| \; \; m2(tu,v,tw),\; \; w := \{ hu , tw \} \}$ \\
,$(\{ hv , tv \} \; \lhd \; v)  \rightarrow  
\{ \| \; \; m2(u,tv,tw),\; \; w := \{ hv , tw \} \}$
$\}$
\end{tabbing}  

\subsection{fork}
Program $fork$ has two inputs: the tuple $x$ and index $m$.
Its output is an array $y$ of tuples; each of these tuples
represents a list.
Array $y$ is indexed $i$ where $0 \leq i < m$.
The input $x$ represents a list of 2-tuples $\{j,v\}$, where $0 \leq j < m$.

Program $fork$ defines output $y$ as a function of its inputs.
Output $y$ is defined as follows:
\begin{enumerate}
   \item If $x$ is the empty list,
         then for all $j$: $y[j]$ is the empty list.
   \item If the head element of $x$ is $\{hx,tx\}$, let $hx = \{j,v\}$;
         for all $i$ other than $j$, $y[i]$ is defined as $z[i]$, and
         $y[j]$ is defined as $\{w,z[j]\}$, where $z$ is defined by: 
         $fork(tx,m,z)$.
\end{enumerate}
 

\begin{tabbing}
$fork(x,m,y)$ \\
integer: $m$ ; \\
array $[$ 0 .. $m-1$ $]$ of synch: $y$ ; \\
$\{?$\\
$(\{\}  \lhd x) \rightarrow$ 
$\{ \|$ $\ll i \; $in$ \; [0  \; .. \; np-1]:: y[i] := \{\} \gg \}$ \\
,$(\{ hx  , tx \} \lhd x), (\{j,v\} \lhd hx) \rightarrow$  \\
$\; \; \; \;$ \= $\{ \|$ array $[$ 0 .. $m-1$ $]$ of synch tuple: $z$ ; \\
\> $\; \; \;$ $fork(tx,m,z),$ \\
\> $\; \; \;$ $\ll i \; $in$ \; [0  \; .. \; m-1]:: \;$ \= $(i \not = j) 
\rightarrow y[i] := z[i]$, \\
\> \> $(i  = j) \rightarrow y[i] := \{ hx  , z[i] \}$  \\
\> $\; \; \;$ $\gg$  \\
\> $\}$ \\
$\}$
\end{tabbing}

\subsection{Receptionist}
Program $receptionist$ defines a relation between its arguments by
defining values of its outputs, $spd$, $out$ and $fd$, for given values
of its inputs, $admit$, $d$ and $cured$, as follows:
\begin{enumerate}
   \item If any of the inputs is the empty list then all of the
         outputs are empty lists.
   \item If $admit =\{ i , ta \} $ and $d = \{ j , td \}$ 
         then $spd = \{ \{i,j\} , tspd \} $
         where $tspd$ is defined by 
         $receptionist(ta, td, cured, tspd, out, fd)$.
   \item If the head element of $cured$ is $\{i,j\}$, then
          $out = \{ i \; , tout \}$, and $fd =  \{ j \; , tfd \}$,
          where $tout$ and $tfd$ are defined by 
          $receptionist(admit,d,tc,spd,tout,tfd)$, where $tc$ is the
          tail of $c$.
\end{enumerate}
\begin{tabbing}
$receptionist(admit,d,cured,spd,out,fd)$ \\
$\{?$ 
$(sizeof(admit) = 0) \vee (sizeof(d) = 0) \vee (sizeof(cured) = 0) \rightarrow
\{\| \; \; spd := \{\}, \; out := \{\}, \; fd := \{\} \; \; \}$ \\
,$(\{ i , ta \} \lhd admit)$ 
,$(\{ j , td \} \lhd d) \rightarrow$ \\
\hspace{1cm} \= $\{ \| receptionist(ta, td, cured, tspd, out, fd)$ \\
\> $\; \; $ $spd := \{ \{i,j\} , tspd \} $\\
\> $\}$ \\
,$(\{ \{i,j\} \; , tc \} \lhd cured) \rightarrow$ \\
\> $\{ \| $ $receptionist(admit,d,tc,spd,tout,tfd)$ \\
\> $\; \;$  , $out := \{ i \; , tout \}$ \\
\> $\; \;$ , $fd :=  \{ j \; , tfd \}$ \\
\> $\}$ \\
$\}$
\end{tabbing}
\subsection{makelist}
Program $makelist$ has two input parameters, $nd$ and $fd$, and a single
output parameter $d$.
Parameters $fd$ and $d$ are lists, and $nd$ is an integer.
The program defines its output as a function of its inputs as follows:
\begin{enumerate}
   \item If $nd = 0$ then $d = \{0,fd\}$.
   \item If $nd > 0$ then $d$ is defined by $makelist(nd-1,d,\{nd,fd\})$.
\end{enumerate}

\begin{tabbing}
$makelist(nd,d,fd)$ \\
integer: $nd$; \\
$\{? \; \;$ \= $nd = 0 \; \rightarrow \; d := \{0,fd\}$ \\
$\;\;$,\> $nd \not = 0 \; \rightarrow \; $\\
        \> $\;\;\; \{\|makelist(m,d,t), m := nd-1, t := \{nd,fd\}\}$ \\
$\}$
\end{tabbing}

\section{Skyline Matrix}
\paragraph{Data Structures}
We shall first give the algorithm described in \cite{Eisenstat} and later
modify it (as in \cite{Eisenstat}) 
to avoid storing zeroes.
The problem is to obtain the $l$-$u$ decomposition of matrix $a$.
Let $L$,$U$ and $a$ be arrays $[$1 .. $n$, 1 ..$n]$ of reals.
Let $d$ be an array $[1$ .. $n]$ of reals.
The lower triangular array of the decomposition is stored in $L$, 
and the upper triangular array 
is stored in $U$, and the diagonal elements (of $l$) are stored in $d$. 

Let $r$, $c$ be arrays $[1 $ .. $n]$ of integers, \\
where $r[i] \leq i$, 
and for all $j$ where $j < r[i]$: $\; \;$ $a[i,j] = 0$, and \\
where $c[j] \leq j$, 
and for all $i$ where $i < c[j]$, $\; \;$ $a[i,j] = 0$.


Thus $r$ and $c$ define the skyline of nonzero entries in the array $a$.

The original description of the algorithm is given below.  (See algorithm 2.1,
page 5, \cite{Eisenstat}.)
Initially $L$ contains the lower half of $a$, and $U$ contains the upper 
half of $a$, and $d$ contains the diagonal elements of $a$.

\paragraph{Program Specification}

\begin{tabbing}
For $i$ := \= 1 to $n$ do \\
          \>  $[$ For $j$ := \= $r[i]$ to $i-1$ do  \\
       \>  \> $L[i,j]$ := $L[i,j] - \sum_{k=max(r[i],c[j])}^{j-1} L[i,k]*U[k,j]$ ; \\
        \>  For $j$ := \> $c[i]$ to $i-1$ do  \\
\> \> $U[j,i]$ := 
$(U[j,i] - \sum_{k=max(r[j],c[i])}^{j-1} L[j,k]*U[k,i])*(1/d[j])$ ; \\
\> $d[i]$ := $d[i] - \sum_{k=max(r[i],c[i])}^{i-1} L[i,k]*U[k,i]$ \\
\> $]$
\end{tabbing}

\paragraph{Memory Optimization}

Let $l$ be an array $[1$ .. $n]$ of tuples, where
 $l[i]$ is the tuple of elements $a[i,j]$, where $r[i] \leq j < i$.
Thus all nonzeroes in row $i$ of $a$ to the left of the diagonal are in
tuple $l[i]$.
Thus $a[i,j] = l[i][j-r[i]]$ if $r[i] \leq j$.

Similarly, let $u$ be an array $[1$ .. $n]$ of tuple, 
where $u[j]$ is the tuple@ of elements $a[i,j]$, where $c[j] \leq i < j$.
Thus all nonzeroes in column $j$ of $a$ above the diagonal are in
tuple $u[j]$.
Thus $a[i,j] = u[j][i-c[j]]$ if $c[j] \leq i$.


The program in PCN is obtained from the specification 
by the following syntactic transformation: replace 
\begin{tabbing} 
$\sum_{k=low}^{high} exp \; \; \; $\= by $\; \; \; 
(+ \; over \; \ll \; k \; in \; [low \; .. \; high] :: \; exp \gg ) $ , \\
$L[i,j]  \; \; \; $\> by $\; \; \;  l[i][j-r[i]]$, \\
$U[j,i]  \; \; \; $\> by $\; \; \;  u[i][j-c[i]]$. \\
\end{tabbing}
The resulting program is:

\begin{tabbing}
$lu(l,u,d,r,c)$ \\
array$[1$ .. $n]$ of integer: $d$,$r$,$c$; \\
array$[1$ .. $n]$ of tuple: $l$,$u$; \\
$\{;$ \\
$\ll $ \= $\; i \;   $in$ \; [1 \; .. \; n] \; :: $\\
\>$ \ll $\= $ \; j \; $in$ \; [r[i] \; .. \; i-1] \; ::$ \\
\> \>$ l[i][j-r[i]] :=  (l[i]$ \= $[j-r[i]] - $ \=  \kill
\> \>$ l[i][j-r[i]] :=  (l[i][j-r[i]] - $ \\
\> \> \> $(+ \; $over$ \; \ll \; k \; in \; 
[($max$(r[i],c[j]) \; .. \; j-1] ::$ \\
\> \> \> $l[i][k-r[i]]*u[j][k-c[j]] \gg ))$\\
\>$ \gg$ \\
\> $\ll $\>$ \; j \;  $in$ \; [c[i] \; .. \; i-1] \; :: $\\
\> \> $u[i][j-c[i]] :=  (u[i][j-c[i]] - $\\
\> \> \> $(+ \;$over$ \; \ll \; k \; in \; 
[($max$(c[i],r[j]) \; .. \; j-1] :: $\\
\> \> \> $l[j][k-r[j]]*u[i][k-c[i]] \gg )) * (1/d[j])$ \\
\> $\gg$ \\
\> \> $d[i] := (d[i] - $\\
\> \> \> $( + \; $over$ \ll \; k \; in \; 
[($max$(r[i],c[i]) \; .. \; i-1] :: $ \\
\> \> \> $l[i][k-r[i]]*u[i][k-c[i]] \gg ))$ \\
$\gg$ \\
$\}$
\end{tabbing}

Back solve is obtained from its specification by the
same syntactic transformation.

\section*{Appendix}
Control flow from one block to another is defined in the appendix,
in the context of program composition.

Associate a unique name with each fair composition block.
In an execution of a program, a block may be executed an arbitrary number
of times.
Consider a given execution of a program, and give a unique name to each
block execution within the program execution.
Control flows from an execution of block $b$ to an execution of block $d$ if:
\begin{itemize}
   \item $b$ is a parallel composition block and $d$ is one of the blocks in
      the block-list of $b$, or
   \item $b$ is a sequential composition block and $d$ is the first block in
   the block-list of $d$, or
   \item a sequential composition block is executed in which $b$ precedes $d$
   in the block-list, or
   \item $b$ is a choice-composition block or a fair-composition block, and
   $g \rightarrow d$ is in the block-list of $b$, and
   in the execution of $b$, $g$ evaluates to $success$ and then
   $d$ is executed, or
   \item there exists a block $c$ such that control flows from $b$ to $c$, and
   from $c$ to $d$.
\end{itemize}



\end{document}
      

