%%   format=book

\Doc[]
\DivBod[]
\DivLii[]\HdMjLii[\def\HdMjLiiJust{C}\def\HdMjLiiInit{}\def\HdMjLiiUnderln{F}\def\HdMjLiiNumPostpunc{}\def\HdMjLiiNumFirstdisp{99}\def\HdMjLiiFntGenlTsz{N}]Ada
Solutions to\newlinetag[]
the Salishan Problems\HdMjEndii[]
\HdMiscLvi[\def\HdMiscLviFntTsz{K}]Kenneth W. Dritz%
\HdMiscEndvi[]
\HdMiscLvi[\HdMiscLviStyAPosPostvskp=0pt \HdMiscLviStyAPosPrevskp=0pt ]Mathematics
and Computer Science Division\HdMiscEndvi[]
\HdMiscLvi[\HdMiscLviStyAPosPostvskp=0pt \HdMiscLviStyAPosPrevskp=0pt ]Argonne
National Laboratory\HdMiscEndvi[]
\HdMiscLvi[\HdMiscLviStyAPosPostvskp=20pt plus7pt minus4pt \HdMiscLviStyAPosPrevskp=0pt ]Argonne,
Illinois 60439-4801\HdMiscEndvi[]
\Para[]This chapter presents, in Sections \Xref[\def\XrefName{Hamming}]
through \Xref[\def\XrefName{skyline}], revised Ada solutions to the
four challenge problems featured in the Language Sessions of the Conference
on High-Speed Computing held in Gleneden Beach, Oregon in March 1988.
The chapter begins with an overview of Ada, emphasizing features that
are noteworthy in the problem solutions.\Endpara[]
\DivLiii[]\HdMjLiii[]Language Features Relevant to the Salishan Problems%
\HdMjEndiii[]
\Para[]Ada is a high-level procedural language, with strong typing
and other features common in languages of its genre, as well as with
several innovations. The language has had an influence in such related
areas as program development environments and software life-cycle
design methodology, so that in a broad sense one can talk about \ldquo[]the
Ada movement.\rdquo[] In this section, we cannot hope to provide a
complete introduction to the language or to the modern software engineering
principles that it supports especially well. For general background,
we refer the reader to any of the many excellent textbooks on Ada;
for the details, the language reference manual is indispensable, and
the textbooks are also valuable. Here, we\rsquo[]ll concentrate on
those features particularly relevant to the Salishan Problems\EmDash[]namely,
the tasking features that support concurrency and some of those supporting
data structuring and abstraction. The language features described
here, and used in the problem solutions, are those of Ada as standardized
in 1983 \Cit[\def\CitId{ANSI:AdaRM}]\Endcit[]. The revision currently
in progress, known informally as Ada 9X \Cit[\def\CitId{Ada9X:DraftReq}]%
\Endcit[], can be expected to allow some aspects of our solutions
to be more efficient and to be expressed more elegantly.%
\Endpara[]
\Para[]As is well known, the language was created in response to the
\ldquo[]software crisis\rdquo[] in the U. S. Department of Defense,
a crisis characterized by rapid escalation of the cost of developing,
maintaining, and adapting software while hardware costs were decreasing
\Cit[\def\CitId{Booch:SoftEng,Cohen:2ndLang}]\Endcit[]. Part of the
problem lay in the programming languages being used by the defense
services, and especially the number of those languages and the lack
of interoperability among them. Another major part of the problem
was the inadequate support for modern principles of software engineering,
both in the languages themselves and in the programming environments
surrounding them. By mandating a single high-level language designed
to support such principles as data abstraction, information hiding,
both top-down and bottom-up design, secure programming, and reusability,
the DoD expected to reduce the cost of software and increase its reliability,
significantly.\Endpara[]
\DivLiv[]\HdMinLiv[]Tasking Features\HdMinEndiv[]
\Para[]Much DoD software is for embedded systems, which have unique
requirements for low-level I/O, asynchronous interrupts, parallelism,
and real-time control. Tasking features were mandated for the new
language by the Steelman requirements \Cit[\def\CitId{DoD:Steelman}]%
\Endcit[] in 1978. A high-level model of parallelism was adopted;
based essentially on CSP \Cit[\def\CitId{Hoare:CSP}]\Endcit[], it
employs the concept of a \txtxemph[]rendezvous\txtxendemph[] between
tasks both for synchronization and for communication. Ada successfully
marries the high-level model of concurrency with low-level features;
for example, asynchronous interrupts, whose behavior is defined in
terms of \ldquo[]virtual\rdquo[] tasks in the high-level model, bring
certain low-level features\EmDash[]such as representation clauses\EmDash[]into
play. Our interest here is not in these low-level features, but rather
in the high-level model of tasking.\Endpara[]
\Para[]Ada programs are strictly serial except where tasking is explicitly
used to express concurrency. (Ada 9X, however, is likely to allow
some degree of implicit parallelism so that, for example, vector architectures
can be exploited.) If a multiprocessor or distributed implementation
of Ada is available, concurrency\EmDash[]appropriately used\EmDash[]can
provide some speedup. A more important role for concurrency, however,
is as a cognitive tool, like recursion; in that role, it can simplify
the expression of certain algorithms\EmDash[]particularly nondeterministic
ones, for which it is well suited. (Failure to exploit nondeterminism
by specifying an ordering where none is needed is an error of %
\txtxemph[]overspecification\txtxendemph[]; it can lead to inefficiency
or, in some cases, to incompleteness.) The goal of achieving speedup,
when the hardware permits it, should be secondary; indeed, concurrent
Ada programs can be written without regard to the hardware on which
they will eventually be run, because they will in fact run (without
speedup) on uniprocessors, where the implementation of Ada achieves
the illusion of concurrency by interleaving or time-slicing among
the Ada tasks eligible for execution.\Endpara[]
\Para[]The rendezvous model of tasking in Ada is at a higher level
than that of monitors \Cit[\def\CitId{Hoare:Monitors}]\Endcit[], which
are favored by some researchers for the ease with which they can be
efficiently implemented using lightweight hardware locks. Of course,
implementation of the rendezvous mechanism typically makes use of
locks and locking internally, out of sight of the application programmer.
And realization of the monitor paradigm within an Ada program, when
desired for its logical properties, is easily achieved with the rendezvous
mechanism. Unfortunately, because of the richness of the full semantics
of Ada tasking, implementation of the rendezvous mechanism has not
heretofore been efficient enough to allow monitors coded in Ada to
compete favorably with those handcrafted directly out of locks and
locking operations in other languages, or with those provided as primitive
operations in other languages (without all the semantic richness of
Ada). Increasingly, however, compiler vendors are making their compilers
smart enough to recognize when the rendezvous (without the more costly
features of the language) is used in a monitor metaphor, and by implementing
the so-called \ldquo[]Habermann-Nassi optimization\rdquo[] %
\Cit[\def\CitId{HabNas:TaskOpt}]\Endcit[] they are specializing the
code generation in that case to match the best implementations of
monitors in other languages. Nevertheless, new features are anticipated
in Ada 9X to provide for efficient mutually exclusive accesses to
shared data by concurrent tasks.\Endpara[]
\Para[]A \txtxemph[]task\txtxendemph[] is a kind of Ada program unit
like a procedure, except that it has a separate thread of control
and cannot have formal parameters. Like other program units, tasks
come in two separate parts\EmDash[]a specification and a body. A task\rsquo[]s
\txtxemph[]specification\txtxendemph[] serves to define the visible
interface between the task and other program units that might interact
with it, while its \txtxemph[]body\txtxendemph[] expresses its logical
behavior. Tasks can be defined either as individual objects (%
\txtxemph[]single tasks\txtxendemph[]) or as types; in the latter
case, any number of identical objects of the type can be created,
perhaps as components of composite objects (such as arrays).%
\NtFoot[]\NtNtpar[]The inability to parameterize tasks is especially
felt when similar tasks are aggregated into arrays and set to work
on different parts of a problem\EmDash[]a recurring strategy in several
of the following problem solutions. At present, the rendezvous mechanism
must be used to communicate with tasks to give them some idea of their
own \ldquo[]identity.\rdquo[] Mechanisms for parameterizing tasks
have been proposed for Ada 9X; these have the prospect of eliminating
some of the tasking communication in our solutions, thereby simplifying
them.\NtEndntpar[]\NtEndfoot[] Tasks, like other objects, can be created
either by \txtxemph[]elaborating\txtxendemph[] (giving effect to)
object declarations upon entering the scope of those declarations,
or by evaluating \txtxemph[]allocators\txtxendemph[] (the mechanism
for dynamic allocation in Ada); they start executing upon creation.%
\NtFoot[]\NtNtpar[]This is a simplification, but appropriate for this
introduction.\NtEndntpar[]\NtEndfoot[] In the doctor\rsquo[]s office
problem, for example, the receptionist is modeled as a single task;
the patients are modeled as an array of tasks of some appropriate
task type; and the doctors are modeled as individually created objects
of another task type, using allocators. (The reason that two different
techniques were used to manage these collections is discussed in the
problem solution.)\Endpara[]
\Para[]Tasks that work on disjoint sets of data and that never cooperate
are uninteresting. More typically, tasks either share global data
and synchronize (serialize) their references to them, or they own
data outright and rely on the queuing and mutual exclusion of other
tasks\rsquo[] interactions with themselves, plus the single thread
of control within themselves, to serialize references to the data.
In the latter case, values usually are transmitted between interacting
tasks. The synchronization and the communication aspects of the interaction
are combined in the rendezvous mechanism.\Endpara[]
\Para[]Once created, tasks execute in parallel with the rest of the
program until they terminate or reach some kind of synchronization
point\EmDash[]for example, that determined by a rendezvous with another
task.\Endpara[]
\Para[]In the simplest kind of rendezvous, the \ldquo[]calling task\rdquo[]
makes an \txtxemph[]entry call\txtxendemph[] to an \txtxemph[]entry%
\txtxendemph[] of the \ldquo[]called task.\rdquo[] (Entries of a task
are declared in its specification.) An entry call has the syntax of
a procedure call, except that the name involved is an %
\txtxemph[]expanded name\txtxendemph[] (for example, %
\tyxffmxmono[]t.e\tyxffmxendmono[]) combining the name of the called
task (\tyxffmxmono[]t\tyxffmxendmono[]) and that of an entry (%
\tyxffmxmono[]e\tyxffmxendmono[]) within it. Like a procedure call,
an entry call can optionally include actual parameters, so it can
pass values to, and receive them from, the called task.%
\Endpara[]
\Para[]The called task\rsquo[]s role in a simple rendezvous is expressed
by an \txtxemph[]accept statement\txtxendemph[], an executable statement
whose syntax is depicted in Figure \Xref[\def\XrefName{syntax-of-accept}].%
\NtFoot[]\NtNtpar[]Throughout our code examples, Ada keywords, which
are reserved words, will be emboldened. This will distinguish them
well enough from identifiers to allow both to be written in lower
case. Ada keywords appearing in ordinary text will also be emboldened
whenever some kind of punctuation seems appropriate.%
\NtEndntpar[]\NtEndfoot[]
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{syntax-of-accept}]Syntax of the accept statement%
\FgEndcap[]
\Comp[]\tyxtstxbf[]accept\tyxtstxendbf[] \Symlt[]\tyxtstxit[]entry-name%
\tyxtstxendit[]\Symgt[] \Symlbk[](\Symlt[]\tyxtstxit[]formal-parameter-list%
\tyxtstxendit[]\Symgt[])\Symrbk[] \Symlbk[]\tyxtstxbf[]do%
\tyxtstxendbf[]
   \Symlt[]\tyxtstxit[]statement-list\tyxtstxendit[]\Symgt[]
\tyxtstxbf[]end\tyxtstxendbf[] \Symlbk[]\Symlt[]\tyxtstxit[]entry-name%
\tyxtstxendit[]\Symgt[]\Symrbk[]\Symrbk[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 If the accept statement has formal parameters, their scope extends
only to the end of the statement (i.e., to the semicolon in Figure
\Xref[\def\XrefName{syntax-of-accept}]). The semantics of a rendezvous
are as follows. The first of the two tasks to execute its part of
the rendezvous (that is, either the entry call in the calling task
or the accept statement in the called task) becomes suspended until
the other task executes its corresponding part. At that point, if
the statement list is present, the calling task becomes suspended
(if it is not already so), and the called task executes the statement
list; the statement list may, of course, read the formal parameters
of mode \tyxffmxmono[]\tyxtstxbf[]in\tyxtstxendbf[]%
\tyxffmxendmono[] or \tyxffmxmono[]\tyxtstxbf[]in\tyxtstxendbf[]%
\tyxffmxendmono[] \tyxffmxmono[]\tyxtstxbf[]out\tyxtstxendbf[]%
\tyxffmxendmono[], whose values have been transmitted from the calling
task, and store into the formal parameters of mode %
\tyxffmxmono[]\tyxtstxbf[]out\tyxtstxendbf[]\tyxffmxendmono[] or %
\tyxffmxmono[]\tyxtstxbf[]in\tyxtstxendbf[]\tyxffmxendmono[] %
\tyxffmxmono[]\tyxtstxbf[]out\tyxtstxendbf[]\tyxffmxendmono[]. Finally,
when the end of the statement list is reached (or in its absence),
both tasks continue in parallel\EmDash[]the calling task with the
statement after its entry call and the called task with the statement
after its accept statement. On the calling side, the actual parameters
that had been associated with formal parameters of mode %
\tyxffmxmono[]\tyxtstxbf[]out\tyxtstxendbf[]\tyxffmxendmono[] or %
\tyxffmxmono[]\tyxtstxbf[]in\tyxtstxendbf[]\tyxffmxendmono[] %
\tyxffmxmono[]\tyxtstxbf[]out\tyxtstxendbf[]\tyxffmxendmono[] have,
henceforth, the new values they received during the rendezvous.%
\Endpara[]
\Para[]If multiple tasks call a given entry of some other task, the
calls remain queued in FIFO order, and each execution of an accept
statement for the entry removes the oldest call from the queue.%
\Endpara[]
\Para[]Conditional entry calls and accept statements (those that take
an alternate path instead of waiting, if their counterparts have not
already been executed) and timed entry calls and accept statements
(those that time out and take an alternate path if their counterparts
are not executed within a specified time) can be constructed, but
we do not need them for the problem solutions. And entries of a task
can be aggregated into \txtxemph[]entry families\txtxendemph[], which
behave like arrays of entries and provide for the identity of an entry
named in an entry call or accept statement to be computed (e.g., by
the value of its subscript expression); the problem solutions do not
require entry families, either.\Endpara[]
\Para[]Finally, tasks can be made to accept entry calls at any of
several alternative entries. To achieve that effect, the called task
executes what is called a \txtxemph[]selective wait%
\txtxendemph[], the syntax of which is illustrated (by means of a
skeletal example) in Figure \Xref[\def\XrefName{syntax-of-selective-wait}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{syntax-of-selective-wait}]Syntactic example of
a selective wait\FgEndcap[]
\Comp[]\tyxtstxbf[]select\tyxtstxendbf[]
   \Symlt[]\tyxtstxit[]accept-statement\tyxtstxendit[]\Symgt[]
   \Symlbk[]\Symlt[]\tyxtstxit[]statement-list\tyxtstxendit[]\Symgt[]\Symrbk[]
\tyxtstxbf[]or\tyxtstxendbf[]
   \Symlt[]\tyxtstxit[]accept-statement\tyxtstxendit[]\Symgt[]
   \Symlbk[]\Symlt[]\tyxtstxit[]statement-list\tyxtstxendit[]\Symgt[]\Symrbk[]
\tyxtstxbf[]or\tyxtstxendbf[]
   ...
\tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]select\tyxtstxendbf[];%
\Endcomp[]
\EndParbox[]
\FgEndblock[]
 If one or more of the entries named in the accept statements have
already been called when the task reaches its selective wait, then
one of those calls is chosen (in a manner not defined by the language),
and a rendezvous is performed with the task making the call; at the
conclusion of the rendezvous, the statement list (if any) following
the accept statement that participated in the rendezvous is executed
in parallel with calling task. On the other hand, if no task has yet
called any of the entries named in the accept statements, the task
executing the selective wait becomes suspended until some task calls
one of those entries, at which time it performs a rendezvous with
that task. Other options can be used to add the conditional or timed
behavior to a selective wait.\Endpara[]
\Para[]The branches of a selective wait are called \txtxemph[]selective
wait alternatives\txtxendemph[], of which there are several kinds.
Those shown in Figure \Xref[\def\XrefName{syntax-of-selective-wait}]
are \txtxemph[]accept alternatives\txtxendemph[]. Any of the selective
wait alternatives can be prefixed by a \txtxemph[]guard%
\txtxendemph[] containing a Boolean expression. When the task reaches
a selective wait, all of the guards are evaluated first. A selective
wait alternative whose guard evaluates to \tyxffmxmono[]true%
\tyxffmxendmono[], or one without a guard, is said to be \ldquo[]open.\rdquo[]
Only the open alternatives are considered further in the execution
of the selective wait. The Boolean expressions in guards typically
involve task-local \ldquo[]state\rdquo[] variables. The use of guards
is an essential ingredient in the realization of monitors that can
suspend a task requesting a monitor operation, when that operation
cannot be performed until some other task first performs a complementary
monitor operation. (An example of such a monitor might be one that
buffers items among a collection of tasks. The operation of delivering
an item from the buffer to a requesting task cannot be performed when
the buffer is empty; it must wait until some other task first performs
the complementary operation of placing an item into the buffer. A
guard would be used to inhibit the acceptance of an entry call requesting
delivery of an item when the buffer is empty.)\Endpara[]
\Para[]This capability of waiting for interactions with any of several
other tasks is crucial to the functioning of the solution to the doctor\rsquo[]s
office problem. There, the receptionist must wait for requests by
free doctors for sick patients, or notifications by patients that
they are sick and in need of a doctor. These interactions can occur
in an arbitrary and unpredictable order, and the receptionist must
respond to each as it occurs. Guards play a crucial role in that solution,
too; they are used to defer the receptionist\rsquo[]s interactions
with free doctors until it knows that sick patients exist. Much of
the desired behavior of the problem solution, including the queuing
of doctors and patients until they can be paired up, is obtained for
free from the semantics of the Ada tasking features.\Endpara[]
\Para[]Termination of tasks in Ada is a deep subject unto itself,
and we will give here only the briefest sketch of the possibilities.
One way that tasks can terminate is by reaching the end of their execution
(but they will wait at that point until all of their subtasks, if
any, have terminated). A further way, expressed by another kind of
selective wait alternative (a \txtxemph[]terminate alternative%
\txtxendemph[]), is more appropriate for tasks, such as monitors,
that repetitively perform services for other tasks as long as those
services are needed. Informally, this latter mechanism allows a service
task to terminate, instead of waiting for a future entry call, when
the receipt of an entry call from any task that could interact with
it is no longer possible\EmDash[]that is, when all such tasks have
either already terminated or are similarly stating their willingness
to terminate instead of taking another entry call. Typically, when
one task terminates by this mechanism, others (with which it could
interact) do so at the same time, hence the name \ldquo[]distributed
termination\rdquo[] for this mechanism. Distributed termination
happens not to be used in the problem solution.\Endpara[]
\Para[]Although the morphological similarity of tasks and procedures
has already been mentioned, it is clearly not correct to think of
a whole task as the smallest unit of parallel execution. Tasks typically
alternate between periods of suspension and execution, and the latter
can be made as large or as small as is appropriate to the application
at hand. It is also a mistake to think that Ada tasks are bound in
a fixed way to processors or nodes of a multiprocessor system, with
those processors or nodes frequently becoming blocked. Ada implementations
typically maintain a queue of Ada tasks that are eligible for execution
(not suspended), and each processor takes a task from that queue when
its previous task terminates or becomes suspended. In some cases,
the redirection of a processor\rsquo[]s attention from one task to
another can even be performed without a context switch (as, for example,
with Habermann-Nassi optimization).\Endpara[]
\Para[]A frequent criticism of Ada is its wordiness in comparison
to other languages. In our context this shows up, for example, in
the repetition of parameter profiles for task entries in both the
specification and the body of a task. (The same kind of repetition
occurs in subprogram specifications and bodies.) This particular kind
of repetition can be attributed to the requirements of a powerful
language feature called \txtxemph[]subprogram overloading%
\txtxendemph[], which can play an important role in the design of
abstractions. In general, the wordiness of Ada is sometimes a consequence
of powerful language features and sometimes a consequence of the redundancy
that both tames the power and increases the safety of programs (by
enabling extensive compile-time checking). Because of what it represents,
most Ada programmers quickly learn to accept the wordiness as an asset
rather than a hindrance.\Endpara[]
\Para[]Ada appears to be a good language in which to express a solution
to the doctor\rsquo[]s office problem because the actors in the problem,
and the interactions among them, map directly onto available features
of Ada. The pairwise interactions among the various actors are reminiscent
of the rendezvous itself; the desired kind of queuing is obtained
for free; and the merging of signals, as it were, is provided by the
selective wait. The first two of the four solutions to Hamming\rsquo[]s
problem also appear attractive in Ada, given the abstraction of a
stream, which\EmDash[]while not built into the language\EmDash[]is
readily programmed in Ada. Those solutions are comparable to others
in this book, in languages in which streams are either built in (as
in SISAL \Cit[\def\CitId{Skedz:SISAL}]\Endcit[]) or available as a
previously programmed reusable\NtFoot[]\NtNtpar[]What we mean by %
\txtxemph[]reusable\txtxendemph[] is \txtxemph[]as general as possible,
so that it can be used in a wide variety of applications requiring
the same general behavior, irrespective of differences in irrelevant
details\txtxendemph[]. In Ada, reusability is achieved primarily through
the definition and instantiation of generic units, especially generic
packages. Streams of values of an arbitrary type are an obvious candidate
for a reusable abstraction; though the type of the values held in
a stream might vary with different applications, or even with different
streams in a single application, the operations on streams are independent
of that type. We purposely do not show how to program a generic \ldquo[]streams\rdquo[]
package in Ada because it is highly likely that, in a mature working
environment, the programmer desiring to solve Hamming\rsquo[]s problem
would find that someone previously had a need for the stream abstraction
and that a generic package exporting the desired type and operations
(perhaps with different names than we have used) already exists in
a local library. Such a library can be considered to extend the language.%
\NtEndntpar[]\NtEndfoot[] abstraction. The remaining two solutions
to Hamming\rsquo[]s problem appear less attractive, but only because
they are considerably more involved than the usual solutions.%
\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Data Structuring and Abstraction Features%
\HdMinEndiv[]
\Para[]Among the features useful for defining complex data structures
and abstractions, and for making them reusable, are packages, generic
units, private types, access types, record types with discriminant
parts or variant parts, and subprogram or operator overloading. The
Ada problem solutions only scratch the surface of the vast well of
potential benefits these features offer. Opportunities for their use
suggested themselves quite naturally during the development of the
solutions.\Endpara[]
\Para[]\txtxemph[]Packages\txtxendemph[] are one of the four kinds
of program units in Ada, the other three being subprograms (functions
or procedures), tasks, and generic units. Packages contain collections
of declarations meant to be used together. For example, a math library
is typically constituted as a package containing mathematical subprograms.
Abstractions are usually organized as packages that declare types\EmDash[]usually
private types\EmDash[]as well as explicitly defined operations applicable
to objects of those types. Like other program units, packages have
separate specifications and bodies. The declarations in a package
specification, or rather in the part of a package specification called
its \txtxemph[]visible part\txtxendemph[], are the ones exported to
the user, or client, of the package. A package specification can include,
among other things, declarations of types, declarations of objects,
and the specifications of other (nested) program units of any of the
four kinds. A package body contains the bodies of the program units
whose specifications occurred in its specification; it may also include
other declarations of types, objects, and program units, which are
visible only there (i.e., they are not visible to the client of the
package). Some packages do not need bodies; in particular, a package
specification that declares only types and objects does not require
a body.\Endpara[]
\Para[]A package specification occurring alone as a compilation unit
defines a \txtxemph[]library package\txtxendemph[]; the specifications
of subprograms and of generic units occurring alone as compilation
units also define library units. (Tasks cannot occur alone, but must
always be nested inside another program unit. This rule is connected
to the semantics of distributed termination of tasks. Tasks may, of
course, be nested inside library packages.) A library unit is entered
into a program library upon its successful compilation and is thereafter
available to potential clients. A client\EmDash[]that is, a compilation
unit that needs the facilities provided by the library unit\EmDash[]refers
to the library unit in its \txtxemph[]context clause%
\txtxendemph[], which contains one or more \txtxemph[]with clauses%
\txtxendemph[] optionally followed by \txtxemph[]use clauses%
\txtxendemph[]. (We say that the compilation unit \ldquo[]withs\rdquo[]
the library unit. In this chapter, we also say that the compilation
unit is compiled \ldquo[]in the context of\rdquo[] the library unit.)
A client of a library unit can be compiled before the body of the
library unit is compiled; furthermore, the client need not be recompiled
when, after the body of the library unit is initially compiled, it
is subsequently changed. The specification of a library package, for
example, contains all the interface information needed to compile
references to the types, objects, and subprograms that the package
exports. Thus, changes in the detailed implementation of an abstraction
do not require the client of an abstraction to be recompiled, provided
that the interface remains unchanged.\Endpara[]
\Para[]The solution to Hamming\rsquo[]s problem is organized as a
library package; the package exports a type, an internal package,
and a procedure that solves the problem. To solve Hamming\rsquo[]s
problem, the user writes a program unit that \ldquo[]withs\rdquo[]
the Hamming\rsquo[]s problem package and then calls the procedure
that it exports. To interface to that procedure, the user would also
declare some objects of the type exported by the Hamming\rsquo[]s
problem package and by its internal package.\Endpara[]
\Para[]The solution to the paraffins problem is organized somewhat
differently, in three parts: a pair of library packages (one for radicals,
the other for molecules) that export types and operations, and a library
function that solves the problem. To solve the paraffins problem,
the user writes a program unit that \ldquo[]withs\rdquo[] and calls
the function. To interface to that function, the user would also \ldquo[]with\rdquo[]
the molecules package and declare some objects of a type exported
by it. Depending on the other needs of the user\rsquo[]s application,
the user might also wish to \ldquo[]with\rdquo[] the radicals package.%
\Endpara[]
\Para[]\txtxemph[]Generic units\txtxendemph[], which may be generic
packages or generic subprograms, strongly support the aim of reusability
by making it possible to parameterize packages or subprograms in a
variety of ways. They serve as templates from which ordinary packages
or subprograms are obtained by the process of \txtxemph[]instantiation%
\txtxendemph[], in which \txtxemph[]generic actual parameters%
\txtxendemph[] are associated with the generic unit\rsquo[]s %
\txtxemph[]generic formal parameters\txtxendemph[]. Generic units
can be parameterized with types, computed values (playing the role
of constants inside the generic unit), variables (providing aliasing
between variables inside and outside the generic unit), and subprograms.
The generic actual parameters are said to be \ldquo[]imported\rdquo[]
into a generic unit; some of those imported by a generic package may
be re-exported by the ordinary package obtained from it by instantiation.%
\Endpara[]
\Para[]The solution to the doctor\rsquo[]s office problem is organized
as a generic library procedure that imports a pair of functions. To
solve the doctor\rsquo[]s office problem, the user writes a program
unit that \ldquo[]withs\rdquo[] the generic procedure, instantiates
it with the names of a pair of functions (provided by the user) giving
the probability distributions of patients\rsquo[] healthy periods
and doctors\rsquo[] cure times, and calls the resulting ordinary procedure.
Parameterization by a subprogram also plays a minor role in the solution
to the paraffins problem, where generic procedures are used (both
as library units and internally). At present, generic units must be
used in this way to parameterize a subprogram with another subprogram,
but Ada 9X is expected to provide a way to do this without using generic
units.\Endpara[]
\Para[]The solution to the skyline matrix problem is organized as
a generic library package importing a floating-point type and a positive
integer value. To solve the skyline matrix problem, the user writes
a program unit that \ldquo[]withs\rdquo[] the generic package, instantiates
it with a floating-point type (thus customizing the problem to the
required precision) and a positive integer value giving the order
of the problem, declares matrices and vectors of the types exported
by the resulting ordinary package, manipulates the matrices and vectors
using operations exported by the package, and calls the function (also
exported by the package) to solve the matrix equation.\Endpara[]
\Para[]In Ada, a type is viewed as a set of values and a set of operations
on the values. Operations of a type can be declared by the user in
the form of a subprogram and are designated either by a name or a
(predefined) operator symbol. In addition, operations appropriate
to the nature of a type are implicitly declared and exported with
the type. For one example, the declaration of a floating-point type
implicitly declares arithmetic operations on values of the type; for
another, the declaration of an array type implicitly declares component
selection by subscripting as an operation of the type. The user may
declare \txtxemph[]private types\txtxendemph[], whose significance
is that very few operations are implicitly exported by the type declaration;
essentially, the details of the realization of the type are hidden
from clients. A private type is defined in the visible part of a package
specification. A corresponding \txtxemph[]full type declaration%
\txtxendemph[] is given in another part of the package specification,
called the \txtxemph[]private part\txtxendemph[]. Beyond the few operations
implicitly exported for all private types, the only other operations
available to clients of the package are those explicitly exported
in the form of subprograms declared in the package\rsquo[]s visible
part. Operations relevant to the full type declaration are implicitly
declared by it and are visible in the body of the package, but not
to clients of the package. The use of private types is often combined
with the use of generics to forge powerful and secure abstractions.
Our use of private types in the solutions is limited to a brief discussion
at the end of Section \Xref[\def\XrefName{crout-skyline}] of some
interesting possibilities in connection with skyline matrices. However,
in several of the problem solutions we assume the existence of generic
library packages that provide generally useful abstractions, and these
would certainly use private types.\NtFoot[]\NtNtpar[]All of the library
units said in this chapter to be \ldquo[]assumed to exist\rdquo[]
were actually written and used for testing the solutions.%
\NtEndntpar[]\NtEndfoot[]\Endpara[]
\Para[]Dynamic storage allocation is provided in Ada for applications
requiring the construction of complex list or tree structures. An
operation called an \txtxemph[]allocator\txtxendemph[] obtains storage
for an object dynamically and returns a pointer to the newly allocated
object. Pointer values are values of a class of types called %
\txtxemph[]access types\txtxendemph[]. The declaration of an access
type designates the type of the objects pointed to by values of the
access type, upholding Ada\rsquo[]s principle of strong typing. We
use access types in the solutions in several ways. In the paraffins
problem, we construct molecules and radicals as trees of linked records,
and we store those of a given size in linked lists. In the doctor\rsquo[]s
office problem, we represent the doctors as dynamically allocated
tasks of some task type, with each task accessed through a pointer
serving to identify it to the receptionist and to the patient that
it treats. In the skyline matrix problem, we dynamically allocate
the rows and columns of skyline matrices to accommodate the components
inside the skyline envelope without wasting space for the zero components
outside, and in fact a skyline matrix is represented as an array of
pointers to the row vectors of the lower triangle and another array
of pointers to the column vectors of the upper triangle.%
\Endpara[]
\Para[]Two features of record types play a role in data structuring
and abstraction in Ada: discriminant parts and variant parts. Record
types may be declared with a \txtxemph[]discriminant part%
\txtxendemph[], which serves to parameterize the type in certain ways.
A discriminant part of a record type definition gives the names and
types of special components of the record known as \txtxemph[]discriminants%
\txtxendemph[], upon which other components may depend. Without going
into much detail, we will simply say that the discriminants of a record
type may be used to express the bounds of other record components
that are arrays, and, in conjunction with \txtxemph[]variant parts%
\txtxendemph[], they may be used to determine which of several alternate
components exist in the record. Objects of a record type with discriminants
are thus self-describing in terms of their layout. Depending on how
they are declared and how they are created, such objects can either
be constrained to have the same layout forever (i.e., the discriminants,
once initialized, are unchangeable) or be permitted to change their
layout as a result of assignment, within the allowable range of values
of the discriminants as given by their types. In the problem solutions,
we make only limited use of this facility. In the paraffins problem,
we use discriminants and variant parts to define a record type for
paraffin radicals that can have one of two distinct layouts and a
record type for paraffin molecules that can also have one of two distinct
layouts. In the skyline matrix problem, we use discriminants to hold
the bounds of a record component that is an array. In both cases,
the objects of the record types are dynamically allocated with constrained
layouts.\Endpara[]
\Para[]The final feature of interest in the problem solutions, %
\txtxemph[]subprogram and operator overloading\txtxendemph[], refers
to the ability to declare several different subprograms with the same
designator (which is either a name or a predefined operator symbol)
but different parameter/result profiles. The subprogram designated
by a particular name or operator symbol is determined during compilation
by overload resolution, using the parameter/result types and other
contextual information. This feature supports abstraction by allowing
familiar names or operator symbols to be extended to new data types.
We use operator overloading in the solution to the skyline matrix
problem to define an inner-product function for vectors, using the
customary \tyxffmxmono[]*\tyxffmxendmono[] infix operator symbol (which
is predefined as the multiplication operator for scalars); thus, we
overload the \tyxffmxmono[]*\tyxffmxendmono[] operator. (We also mix
\txtxemph[]named parameter association\txtxendemph[] with the more
traditional \txtxemph[]positional parameter association%
\txtxendemph[], particularly when it allows a subprogram invocation
or generic instantiation to be read like an English phrase.)%
\Endpara[]
\Para[]In the problem solutions that follow, we discuss language features
only to the depth required for a reader unfamiliar with the language
to appreciate the implications, strengths, and limitations of the
feature, and its application to the problem at hand. We make no attempt
to describe \txtxemph[]all\txtxendemph[] the features used, however.%
\Endpara[]
\DivEndiv[]
\DivEndiii[]
\DivLiii[\def\DivLiiiId{Hamming}]\HdMjLiii[]Hamming\rsquo[]s Problem
(Extended)\HdMjEndiii[]
\Para[]The problem is as follows: Given a finite increasing sequence
\InlEqn[]\LmthEqn[]p_{1},
\ldots ,p_{k}
\LmthEndeqn[]\EndInlEqn[] of primes and an integer \InlEqn[]\LmthEqn[]n
\LmthEndeqn[]%
\EndInlEqn[], output in order of increasing magnitude and without
duplication all integers less than or equal to \InlEqn[]\LmthEqn[]n
\LmthEndeqn[]%
\EndInlEqn[] of the form 
\DispEqn[]
\DmthEqn[]
\prod \limits _{i=1}^{k}p_{i}^{e_{i}}
\DmthEndeqn[]\EndDispEqn[]
for \InlEqn[]\LmthEqn[]e_{i}
\geq 0
\LmthEndeqn[]\EndInlEqn[]. A hint calls attention to the fact that
if \InlEqn[]\LmthEqn[]m
\LmthEndeqn[]\EndInlEqn[] is in the output sequence, then so is %
\InlEqn[]\LmthEqn[]m
\cdot p_{i}
\LmthEndeqn[]\EndInlEqn[], provided that it is less than or equal to %
\InlEqn[]\LmthEqn[]n
\LmthEndeqn[]\EndInlEqn[].\Endpara[]
\Para[]Four solutions to Hamming\rsquo[]s problem, using different
degrees of tasking, are presented. The first is straightforward and
uses no tasking features, while the second is a minor variation of
the first that uses tasking in a rather artificial way to remove unnecessary
determinism and coincidentally introduce a small amount of concurrency.
The third implements an entirely different algorithm and uses tasking
in a more functional way, and the fourth is an extension of the third
in which tasks are replicated to achieve greater parallelism. While
the fourth solution also represents an artificial improvement over
its predecessor, the goal and the method of the improvement are unlike
that embodied in the second solution.\Endpara[]
\DivLiv[]\HdMinLiv[]First Solution: Usual Serial Algorithm%
\HdMinEndiv[]
\Para[]The usual method of solving this problem involves several parallel
streams of future output values, one stream corresponding to each
prime. In each iteration of the \ldquo[]main loop,\rdquo[] a value
is appended to the tail of each stream, a new output value is produced,
and a value is removed from the head of some of the streams. More
precisely, each time through the loop,
\LstList[]
\LstItem[]the product of the previous output value and the prime associated
with the stream is appended to each stream;\LstEnditem[]
\LstItem[]the least of the values at the heads of all the streams
is determined, and it becomes the next output value; and%
\LstEnditem[]
\LstItem[]each stream whose head matches that least value has its
head removed.\LstEnditem[]
\LstEndlist[]
\Endpara[]
\Para[]Streams are not predefined in Ada, but we assume the availability,
as a library unit, of a generic package named \tyxffmxmono[]streams%
\tyxffmxendmono[] that provides an abstract data type called %
\tyxffmxmono[]stream\tyxffmxendmono[] complete with appropriate operations
on objects of that type. Since we need streams of positive integers,
we instantiate the generic package \tyxffmxmono[]streams%
\tyxffmxendmono[] with the predefined subtype \tyxffmxmono[]positive%
\tyxffmxendmono[] of the predefined type \tyxffmxmono[]integer%
\tyxffmxendmono[] to obtain a package that we call %
\tyxffmxmono[]positive\Symuns[]streams\tyxffmxendmono[]; its %
\tyxffmxmono[]stream\tyxffmxendmono[] type is exactly what we seek.
We are not concerned here with the implementation of the generic package,
which might very well use pointers and linked lists, and for brevity
we omit even its specification. We assume that the initial state of
an object of type \tyxffmxmono[]stream\tyxffmxendmono[] is \ldquo[]empty,\rdquo[]
allowing us to dispense with explicit initialization of streams; this
is a realistic assumption since access objects, i.e., pointers, are
automatically initialized to \tyxffmxmono[]\tyxtstxbf[]null%
\tyxtstxendbf[]\tyxffmxendmono[] in Ada. In this application, we require
only the following operations on streams, which we assume are provided
by the generic package: a procedure (\tyxffmxmono[]append%
\tyxffmxendmono[]) to append a value to the tail of a stream; a function
(\tyxffmxmono[]head\tyxffmxendmono[]) to return the value at the head
of a nonempty stream without removing it; and a procedure (%
\tyxffmxmono[]behead\tyxffmxendmono[]) to remove and discard the value
at the head of a nonempty stream. The subprograms \tyxffmxmono[]head%
\tyxffmxendmono[] and \tyxffmxmono[]behead\tyxffmxendmono[] can be
assumed to raise some exception if applied to an empty stream. We
have no need for an \tyxffmxmono[]is\Symuns[]empty%
\tyxffmxendmono[] predicate; and because we apply \tyxffmxmono[]head%
\tyxffmxendmono[] and \tyxffmxmono[]behead\tyxffmxendmono[] only to
nonempty streams, we can guarantee that the exception will never be
raised.\Endpara[]
\Para[]Our first solution to Hamming\rsquo[]s problem is in the form
of a package, \tyxffmxmono[]hammings\Symuns[]problem%
\tyxffmxendmono[], that exports a type for unconstrained arrays (those
not bearing bounds) of positive integers, a package of types and operations
associated with streams of positive integers, and a procedure to compute
and deliver the required sequence of values given a maximal output
value and an array of primes in ascending order. The array type and
the package of stream types and operations are exported with the procedure
so that they can be used in forming and manipulating the procedure\rsquo[]s
inputs and outputs (we have chosen to deliver the sequence of output
values by appending them to an \tyxffmxmono[]\tyxtstxbf[]in%
\tyxtstxendbf[]\tyxffmxendmono[] \tyxffmxmono[]\tyxtstxbf[]out%
\tyxtstxendbf[]\tyxffmxendmono[] parameter which is a stream initially
passed in as an empty stream). The specification of the %
\tyxffmxmono[]hammings\Symuns[]problem\tyxffmxendmono[] package is
shown in Figure \Xref[\def\XrefName{spec-of-hammings-problem}].%
\NtFoot[]\NtNtpar[]All of the integer values used by, and generated
in, our solutions to Hamming\rsquo[]s problem are greater than zero,
except that this assumption of positiveness is not made (since it
is not required) for the subscripts of objects of the unconstrained
array type \tyxffmxmono[]positive\Symuns[]array\tyxffmxendmono[].
It is therefore appropriate to use, as we have done, the subtype %
\tyxffmxmono[]positive\tyxffmxendmono[], instead of the type %
\tyxffmxmono[]integer\tyxffmxendmono[], for all of our variables or
their components; doing so increases the security of the programs
since, as a consequence, the procedure \tyxffmxmono[]solver%
\tyxffmxendmono[] can not then be called with scalar actual parameters
having nonpositive values or composite actual parameters having nonpositive
components, which if allowed would cause obscure failures. We have
applied this reasoning to the fullest extent, though in reality the
necessary security would have been achieved by declaring just the
formal parameters of \tyxffmxmono[]solver\tyxffmxendmono[] to be (or
to have components) of subtype \tyxffmxmono[]positive%
\tyxffmxendmono[], and every other integer variable or component,
including the components of streams, to be of type %
\tyxffmxmono[]integer\tyxffmxendmono[]. (One can prove that, if the
actual parameters in a call to \tyxffmxmono[]solver%
\tyxffmxendmono[], or their components, are all positive, then all
integer values generated by the solutions \txtxemph[]will%
\txtxendemph[] be positive.)\NtEndntpar[]\NtEndfoot[]
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-hammings-problem}]Specification of the
\tyxffmxmono[]hammings\Symuns[]problem\tyxffmxendmono[] package%
\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] streams;
\tyxtstxbf[]package\tyxtstxendbf[] hammings\Symuns[]problem %
\tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] positive\Symuns[]array %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (integer %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] positive;
   \tyxtstxbf[]package\tyxtstxendbf[] positive\Symuns[]streams %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] streams (positive);
   \tyxtstxbf[]use\tyxtstxendbf[]     positive\Symuns[]streams;
   \tyxtstxbf[]procedure\tyxtstxendbf[] solver (n       : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                     primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                     outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream);
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]The body of the \tyxffmxmono[]hammings\Symuns[]problem%
\tyxffmxendmono[] package is shown in Figure \Xref[\def\XrefName{body-of-hammings-problem}].
The functions \tyxffmxmono[]min\tyxffmxendmono[] and %
\tyxffmxmono[]max\tyxffmxendmono[] are not predefined in Ada, but
we assume the availability, as a library unit, of a generic package
named \tyxffmxmono[]min\Symuns[]and\Symuns[]max\tyxffmxendmono[],
which we instantiate with the subtype \tyxffmxmono[]positive%
\tyxffmxendmono[]. The result of the instantiation is a package that
we call \tyxffmxmono[]positive\Symuns[]min\Symuns[]and\Symuns[]max%
\tyxffmxendmono[]; it exports \tyxffmxmono[]min\tyxffmxendmono[] and
\tyxffmxmono[]max\tyxffmxendmono[] functions on positive integers.
We are not concerned here with the implementation of the generic package,
and for brevity we omit even its specification.
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-hammings-problem}]Body of the %
\tyxffmxmono[]hammings\Symuns[]problem\tyxffmxendmono[] package (first
solution)\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] min\Symuns[]and\Symuns[]max;
\tyxtstxbf[]package\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] hammings\Symuns[]problem \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]package\tyxtstxendbf[] positive\Symuns[]min\Symuns[]and\Symuns[]max %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] min\Symuns[]and\Symuns[]max (positive);
   \tyxtstxbf[]use\tyxtstxendbf[]     positive\Symuns[]min\Symuns[]and\Symuns[]max;
   \tyxtstxbf[]procedure\tyxtstxendbf[] solver (n       : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                     primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                     outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]A place for the body of the \tyxffmxmono[]solver%
\tyxffmxendmono[] procedure is held by a \txtxemph[]body stub%
\txtxendemph[], and the \txtxemph[]proper body\txtxendemph[] of %
\tyxffmxmono[]solver\tyxffmxendmono[] is made a \txtxemph[]subunit%
\txtxendemph[] of \tyxffmxmono[]hammings\Symuns[]problem%
\tyxffmxendmono[]. This allows us to keep our compilation units small.
The need for that economy is not especially strong now, but the solutions
to be exhibited subsequently do definitely benefit from this practice.
The proper body of \tyxffmxmono[]solver\tyxffmxendmono[], as a separate
compilation unit, is shown in Figure \Xref[\def\XrefName{body-of-solver}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-solver}]Proper body of the %
\tyxffmxmono[]solver\tyxffmxendmono[] procedure (first solution)%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem)
\tyxtstxbf[]procedure\tyxtstxendbf[] solver (n       : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                  primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                  outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream) \tyxtstxbf[]is%
\tyxtstxendbf[]
   infinity : \tyxtstxbf[]constant\tyxtstxendbf[] positive := n + 1;
   pipes    : \tyxtstxbf[]array\tyxtstxendbf[] (primes\rsquo[]range) %
\tyxtstxbf[]of\tyxtstxendbf[] stream;
   i        : positive := 1;
   new\Symuns[]i    : positive;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]while\tyxtstxendbf[] i \Symlt[]= n \tyxtstxbf[]loop%
\tyxtstxendbf[]
      append (i, to =\Symgt[] outputs);
      new\Symuns[]i := infinity;
      \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
         append (i*primes(k), to =\Symgt[] pipes(k));
         new\Symuns[]i := min(new\Symuns[]i, head(pipes(k)));
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      i := new\Symuns[]i;
      \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
         \tyxtstxbf[]if\tyxtstxendbf[] head(pipes(k)) = i %
\tyxtstxbf[]then\tyxtstxendbf[]
            behead (pipes(k));
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]The solution shown in Figure \Xref[\def\XrefName{body-of-solver}]
is somewhat wasteful in that it appends values exceeding %
\tyxffmxmono[]n\tyxffmxendmono[], the maximal output value, to the
streams, even though they will never become part of the output sequence;
they remain in the streams when the main loop terminates. Worse, it
lacks robustness because the very computation of such values could
theoretically overflow, bringing the program to a grinding halt. These
problems could be easily corrected, but the simplicity of the algorithm
would be obscured by the added detail.\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Second Solution: Processing the Streams in Parallel%
\HdMinEndiv[]
\Para[]In each iteration of the main loop, the preceding solution
cycles through the streams in order. The order of visiting the streams
is immaterial, of course, and in fact they could be processed in parallel.
Thus, that solution is actually overspecified.\Endpara[]
\Para[]For our second solution, a modified proper body of the %
\tyxffmxmono[]solver\tyxffmxendmono[] procedure is shown in Figure
\Xref[\def\XrefName{body-of-solver-parallel}],
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-solver-parallel}]Proper body of the %
\tyxffmxmono[]solver\tyxffmxendmono[] procedure (second solution)%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem)
\tyxtstxbf[]procedure\tyxtstxendbf[] solver (n       : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                  primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                  outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]type%
\tyxtstxendbf[] stream\Symuns[]processor \tyxtstxbf[]is%
\tyxtstxendbf[]
      \tyxtstxbf[]entry\tyxtstxendbf[] install\Symuns[]prime (a\Symuns[]prime : %
\tyxtstxbf[]in\tyxtstxendbf[] positive);
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]task\tyxtstxendbf[] min\Symuns[]finder %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]entry\tyxtstxendbf[] bid (a\Symuns[]head : %
\tyxtstxbf[]in\tyxtstxendbf[] positive);
      \tyxtstxbf[]entry\tyxtstxendbf[] wait\Symuns[]for\Symuns[]min;
   \tyxtstxbf[]end\tyxtstxendbf[];
   infinity : \tyxtstxbf[]constant\tyxtstxendbf[] positive := n + 1;
   pipes    : \tyxtstxbf[]array\tyxtstxendbf[] (primes\rsquo[]range) %
\tyxtstxbf[]of\tyxtstxendbf[] stream\Symuns[]processor;
   i        : positive := 1;
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] stream\Symuns[]processor \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] min\Symuns[]finder       \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
      pipes(k).install\Symuns[]prime (primes(k));
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 while the specification and body of the \tyxffmxmono[]hammings\Symuns[]problem%
\tyxffmxendmono[] package remain unchanged. A separate task is now
devoted to the processing of each stream. The \tyxffmxmono[]pipes%
\tyxffmxendmono[] array of streams has been replaced by an array (of
the same name) whose components are of a task type called %
\tyxffmxmono[]stream\Symuns[]processor\tyxffmxendmono[]; each task
in this array declares and processes a single stream, using the corresponding
prime. There is one additional task, \tyxffmxmono[]min\Symuns[]finder%
\tyxffmxendmono[], devoted to finding the minimum of the heads of
all the streams at the appropriate time. Places for the bodies of
the \tyxffmxmono[]stream\Symuns[]processor\tyxffmxendmono[] task type
and \tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] single task
are held by body stubs; their proper bodies are made subunits of %
\tyxffmxmono[]solver\tyxffmxendmono[] and are shown later.%
\Endpara[]
\Para[]The \tyxffmxmono[]pipes\tyxffmxendmono[] array of %
\tyxffmxmono[]stream\Symuns[]processor\tyxffmxendmono[] tasks is created
as part of the execution of \tyxffmxmono[]solver%
\tyxffmxendmono[] (specifically, during the elaboration of its declarative
part). The statement list of \tyxffmxmono[]solver%
\tyxffmxendmono[] initializes each task with its corresponding prime,
then waits (at its end) for all the tasks to terminate before returning
to its caller.\Endpara[]
\Para[]Each time through their loop, the \tyxffmxmono[]stream\Symuns[]processor%
\tyxffmxendmono[] tasks bid their respective stream heads as the prospective
minimum to \tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] and then
wait for \tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] to place
the minimum of the bids in \tyxffmxmono[]i\tyxffmxendmono[] (the variable
\tyxffmxmono[]i\tyxffmxendmono[] plays the same role as before but
is now global to all the tasks). The code implementing the behavior
of a \tyxffmxmono[]stream\Symuns[]processor\tyxffmxendmono[] task
is shown in Figure \Xref[\def\XrefName{body-of-stream-processor}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-stream-processor}]Proper body of the %
\tyxffmxmono[]stream\Symuns[]processor\tyxffmxendmono[] task type%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem.solver)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] stream\Symuns[]processor %
\tyxtstxbf[]is\tyxtstxendbf[]
   my\Symuns[]prime  : positive;
   my\Symuns[]stream : stream;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]accept\tyxtstxendbf[] install\Symuns[]prime (a\Symuns[]prime : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]do%
\tyxtstxendbf[]
      my\Symuns[]prime := a\Symuns[]prime;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]while\tyxtstxendbf[] i \Symlt[]= n \tyxtstxbf[]loop%
\tyxtstxendbf[]
      append (i*my\Symuns[]prime, to =\Symgt[] my\Symuns[]stream);
      min\Symuns[]finder.bid (head(my\Symuns[]stream));
      min\Symuns[]finder.wait\Symuns[]for\Symuns[]min;
      \tyxtstxbf[]if\tyxtstxendbf[] head(my\Symuns[]stream) = i %
\tyxtstxbf[]then\tyxtstxendbf[]
         behead (my\Symuns[]stream);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]The pair of rendezvous used for communication and synchronization
with \tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] acts like a
\ldquo[]barrier,\rdquo[] preventing the \tyxffmxmono[]stream\Symuns[]processor%
\tyxffmxendmono[] tasks from moving on to the beheading of their streams
until all of them have communicated the value of their stream heads
to \tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] and %
\tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] has found the minimum
of them. The code implementing the behavior of the %
\tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] task is shown in
Figure \Xref[\def\XrefName{body-of-min-finder}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-min-finder}]Proper body of the %
\tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] task%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem.solver)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] min\Symuns[]finder %
\tyxtstxbf[]is\tyxtstxendbf[]
   new\Symuns[]i : positive;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]while\tyxtstxendbf[] i \Symlt[]= n \tyxtstxbf[]loop%
\tyxtstxendbf[]
      append(i, to =\Symgt[] outputs);
      new\Symuns[]i := infinity;
      \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
         \tyxtstxbf[]accept\tyxtstxendbf[] bid (a\Symuns[]head : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]do%
\tyxtstxendbf[]
            new\Symuns[]i := min(new\Symuns[]i, a\Symuns[]head);
         \tyxtstxbf[]end\tyxtstxendbf[];
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      i := new\Symuns[]i;
      \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
         \tyxtstxbf[]accept\tyxtstxendbf[] wait\Symuns[]for\Symuns[]min;
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]The second solution cannot seriously be expected to yield any
significant speedup, since the grains of parallel work between the
synchronization points are too small in relation to the synchronization
overhead. The serial bottleneck represented by the barrier has an
analog in the first solution and does not, by itself, make matters
worse. The main value of the second solution is to illustrate how
tasking can be used to replace an unnecessary, deterministic ordering
by a completely nondeterministic ordering satisfying the relevant
dataflow properties of the algorithm and nothing else.\NtFoot[]%
\NtNtpar[]Within the constraints of those dataflow properties, different
orderings in different runs are caused, of course, by probabilistic
characteristics of the computing load.\NtEndntpar[]\NtEndfoot[] (The
for loops in \tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[] are
used only to count the number of rendezvous to be performed, not to
order them; the loop variable is not referenced inside the loops.)%
\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Third Solution: Novel Use of Concurrency%
\HdMinEndiv[]
\Para[]In an idealized implementation of Ada in which a rendezvous
incurs no overhead, the speedup yielded by the second solution would
be expected to scale up with the number of primes; if there are more
processors than primes, the surplus processors would not be exploited.%
\NtFoot[]\NtNtpar[]Well, almost; one of them would execute %
\tyxffmxmono[]min\Symuns[]finder\tyxffmxendmono[].\NtEndntpar[]%
\NtEndfoot[] The radically different approach to be described next
is capable of being scaled up in proportion to an independent parameter;
it can therefore always be made to use all available processors. (We
save for the fourth solution the details of the actual scaling up
and present here the basic algorithm.)\Endpara[]
\Para[]Our third solution uses a single recirculating stream of future
output values; the stream is recirculating because some of the values
that are removed from its head are put back on the stream at its tail.
In each iteration of the main loop, the value at the head of the stream
is removed and placed in the \tyxffmxmono[]outputs%
\tyxffmxendmono[] stream; it is also used to trigger the generation,
by another task (called \tyxffmxmono[]products\Symuns[]generator%
\tyxffmxendmono[]), of a sequence of products of itself and all the
primes. Meanwhile\EmDash[]that is, as the products are being generated\EmDash[]the
remainder of the recirculating stream of future output values is read
and merged with the stream of products as they become available (both
streams are in ascending order), with the resulting sequence of values
being directed back to the recirculating stream (i.e., appended to
its tail).\Endpara[]
\Para[]In this solution, in contrast to the earlier ones, we do not
generate any products greater than \tyxffmxmono[]n%
\tyxffmxendmono[]. It is convenient to use the constant %
\tyxffmxmono[]infinity\tyxffmxendmono[], defined as %
\tyxffmxmono[]n+1\tyxffmxendmono[] and previously used for a different
purpose, as an end-marker both for the stream of products and for
the recirculating stream of future outputs (where it separates the
last value produced by one iteration from the first value produced
by the next). The recirculating stream is initialized to a 1 followed
by an end-marker; it grows and eventually shrinks in length with succeeding
iterations, and the algorithm terminates when the recirculating stream
is reduced to just the end-marker (i.e., when the first value read
from the recirculating stream in an iteration of the main loop is
the end-marker). The dataflow characteristics of this algorithm are
depicted in Figure \Xref[\def\XrefName{data-flow-diagram}].
\FgBlock[\def\FgBlockPlace{H}]
\FgCap[\def\FgCapId{data-flow-diagram}]Dataflow in the novel algorithm
for solving Hamming\rsquo[]s problem\FgEndcap[]
\PreProcFgGfx\FgGfx[\FgGfxHt=230.44pt \FgGfxWd=510.85pt \def\FgGfxPath{salishan.try12.book}\def\FgGfxCache{salishan.try12.book}\FgGfxX=0.00pt \FgGfxY=0.00pt \def\FgGfxProc{PubDraw}\FgGfxMag=80 \def\FgGfxFilename{data-flow.vec}]
\FgEndblock[]
\Endpara[]
\Para[] The \tyxffmxmono[]products\Symuns[]generator%
\tyxffmxendmono[] task proceeds at its own pace and could either generate
products well before they are needed (in which case they remain in
the \tyxffmxmono[]products\tyxffmxendmono[] stream until needed) or
generate them so slowly that the \tyxffmxmono[]products%
\tyxffmxendmono[] stream would be empty when a product is needed from
it. Therefore the stream abstractions previously assumed are inadequate
for this application; the fact that the \tyxffmxmono[]products%
\tyxffmxendmono[] stream is written and read by different tasks should
be a clue to that inadequacy. We now require that a task trying to
read a stream that happens to be empty be suspended until some other
task writes to that stream. Streams of this type will be called \ldquo[]buffers\rdquo[]
to distinguish them from the earlier kind. Indeed, we now assume the
availability, as a library unit, of a generic package named %
\tyxffmxmono[]buffers\tyxffmxendmono[] that provides an abstract data
type called \tyxffmxmono[]buffer\tyxffmxendmono[] complete with appropriate
operations on objects of that type. Since we need buffers of positive
integers, we instantiate the generic package \tyxffmxmono[]buffers%
\tyxffmxendmono[] with the subtype \tyxffmxmono[]positive%
\tyxffmxendmono[] to obtain a package that we call %
\tyxffmxmono[]positive\Symuns[]buffers\tyxffmxendmono[]; its %
\tyxffmxmono[]buffer\tyxffmxendmono[] type is exactly what we seek.
 As we did with streams, we assume that the initial state of an object
of type \tyxffmxmono[]buffer\tyxffmxendmono[] is \ldquo[]empty,\rdquo[]
allowing us to dispense with explicit initialization of buffers. For
brevity, we omit the body and even the specification of the generic
package. We remark, however, that it is convenient to combine the
previous \tyxffmxmono[]head\tyxffmxendmono[] and \tyxffmxmono[]behead%
\tyxffmxendmono[] operations into a single procedure called %
\tyxffmxmono[]read\tyxffmxendmono[], which waits for the given buffer
to become nonempty, then removes and delivers the item at its head.
We call the buffer analog of \tyxffmxmono[]append%
\tyxffmxendmono[], to keep our abstractions separate, %
\tyxffmxmono[]write\tyxffmxendmono[]. Finally, we note that the implementation
of \tyxffmxmono[]buffers\tyxffmxendmono[] will now surely use tasks
to achieve the desired suspension of the caller of %
\tyxffmxmono[]read\tyxffmxendmono[] when required; indeed, the type
\tyxffmxmono[]buffer\tyxffmxendmono[] can be implemented as a task
type whose behavior is that of a monitor.\Endpara[]
\Para[]In the third solution, we retain the use of streams only for
the outputs of \tyxffmxmono[]solver\tyxffmxendmono[] and use buffers
elsewhere. In theory, the recirculating \ldquo[]stream\rdquo[] could
indeed be a stream instead of a buffer, since it is read and written
by the same task; we have chosen to realize it as a buffer, however,
in anticipation of the fourth solution (in which the analogous object
\txtxemph[]must\txtxendemph[] be a buffer), so as to avoid accentuating
nonessential differences between the current solution and that variation.
As in the second solution, the specification of the %
\tyxffmxmono[]hammings\Symuns[]problem\tyxffmxendmono[] package remains
unchanged, but this time we make a slight change in its body: for
purely stylistic reasons, that is where we choose to instantiate the
\tyxffmxmono[]buffers\tyxffmxendmono[] generic package. The revised
body of the \tyxffmxmono[]hammings\Symuns[]problem%
\tyxffmxendmono[] package is shown in Figure \Xref[\def\XrefName{body-of-hammings-problem-novel}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-hammings-problem-novel}]Body of the %
\tyxffmxmono[]hammings\Symuns[]problem\tyxffmxendmono[] package (third
solution)\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] min\Symuns[]and\Symuns[]max, buffers;
\tyxtstxbf[]package\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] hammings\Symuns[]problem \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]package\tyxtstxendbf[] positive\Symuns[]min\Symuns[]and\Symuns[]max %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] min\Symuns[]and\Symuns[]max (positive);
   \tyxtstxbf[]package\tyxtstxendbf[] positive\Symuns[]buffers     %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] buffers (positive);
   \tyxtstxbf[]use\tyxtstxendbf[]     positive\Symuns[]min\Symuns[]and\Symuns[]max, positive\Symuns[]buffers;
   \tyxtstxbf[]procedure\tyxtstxendbf[] solver (n       : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                     primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                     outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]The revised proper body of the \tyxffmxmono[]solver%
\tyxffmxendmono[] procedure is shown in Figure \Xref[\def\XrefName{body-of-solver-novel}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-solver-novel}]Proper body of the %
\tyxffmxmono[]solver\tyxffmxendmono[] procedure (third solution)%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem)
\tyxtstxbf[]procedure\tyxtstxendbf[] solver (n       : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                  primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                  outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream) \tyxtstxbf[]is%
\tyxtstxendbf[]
   infinity : \tyxtstxbf[]constant\tyxtstxendbf[] positive := n + 1;
   recirc   : buffer;
   i        : positive;
\tyxtstxbf[]begin\tyxtstxendbf[]
   write (1,        to =\Symgt[] recirc);
   write (infinity, to =\Symgt[] recirc);
   \tyxtstxbf[]loop\tyxtstxendbf[]
      read   (i, from =\Symgt[] recirc);
   \tyxtstxbf[]exit\tyxtstxendbf[] \tyxtstxbf[]when%
\tyxtstxendbf[] i = infinity;
      append (i, to   =\Symgt[] outputs);
      \tyxtstxbf[]declare\tyxtstxendbf[]
         j, p     : positive;
         products : buffer;
         \tyxtstxbf[]task\tyxtstxendbf[] products\Symuns[]generator;
         \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] products\Symuns[]generator \tyxtstxbf[]is%
\tyxtstxendbf[]
         \tyxtstxbf[]begin\tyxtstxendbf[]
            \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
            \tyxtstxbf[]exit\tyxtstxendbf[] \tyxtstxbf[]when%
\tyxtstxendbf[] i \Symgt[] n/primes(k);
               write (i*primes(k), to =\Symgt[] products);
            \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
            write (infinity, to =\Symgt[] products);
         \tyxtstxbf[]end\tyxtstxendbf[];
      \tyxtstxbf[]begin\tyxtstxendbf[]
         read (j, from =\Symgt[] recirc);
         read (p, from =\Symgt[] products);
         \tyxtstxbf[]loop\tyxtstxendbf[]
            \tyxtstxbf[]if\tyxtstxendbf[]    j \Symlt[] p %
\tyxtstxbf[]then\tyxtstxendbf[]
               write (j, to   =\Symgt[] recirc);
               read  (j, from =\Symgt[] recirc);
            \tyxtstxbf[]elsif\tyxtstxendbf[] j \Symgt[] p %
\tyxtstxbf[]then\tyxtstxendbf[]
               write (p, to   =\Symgt[] recirc);
               read  (p, from =\Symgt[] products);
            \tyxtstxbf[]else\tyxtstxendbf[]
               write (j, to   =\Symgt[] recirc);
         \tyxtstxbf[]exit\tyxtstxendbf[] \tyxtstxbf[]when%
\tyxtstxendbf[] j = infinity;
               read  (j, from =\Symgt[] recirc);
               read  (p, from =\Symgt[] products);
            \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 The \tyxffmxmono[]products\Symuns[]generator\tyxffmxendmono[] task
is created and subsequently terminates, when it
\TyPbrkNewp[]
 reaches the end of its execution, each time through the main loop.
With a slight redesign, we could arrange to create it just once, enclose
its processing within a loop, synchronize that loop with the main
loop in the \tyxffmxmono[]solver\tyxffmxendmono[] procedure, and make
it terminate at the appropriate time. That redesign would require
the use of a rendezvous for the synchronization, and distributed termination
for the \tyxffmxmono[]products\Symuns[]generator%
\tyxffmxendmono[] task. But since simplicity is more desirable than
efficiency in these solutions, we have chosen the method having conceptually
simpler semantics.\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Fourth Solution: Dataflow Loop Unrolling%
\HdMinEndiv[]
\Para[]The technique of \ldquo[]loop unrolling\rdquo[] can be applied
in a unique way to the dataflow loop in Figure \Xref[\def\XrefName{data-flow-diagram}]
by considering all the processing of  values between the moment they
are removed from the recirculating stream and the moment they are
put back in it to be a single \ldquo[]stage\rdquo[] of processing;
by encapsulating a stage of processing in a task; by replicating that
task any number of times; and by interposing buffers (instead of streams)
between the tasks\EmDash[]that is, between the stages. By spreading
the processing over a larger number of tasks, the result, whose dataflow
characteristics are shown in Figure
\FgBlock[\def\FgBlockPlace{H}]
\FgCap[\def\FgCapId{unrolled-data-flow-diagram}]Dataflow in the novel
algorithm for solving Hamming\rsquo[]s problem, with loop unrolling%
\FgEndcap[]
\PreProcFgGfx\FgGfx[\FgGfxHt=376.09pt \FgGfxWd=491.72pt \def\FgGfxPath{salishan.try12.book}\def\FgGfxCache{salishan.try12.book}\FgGfxX=0.00pt \FgGfxY=0.00pt \def\FgGfxProc{PubDraw}\FgGfxMag=80 \def\FgGfxFilename{unrolled-data-flow.vec}]
\FgEndblock[]
 \Xref[\def\XrefName{unrolled-data-flow-diagram}], achieves potentially
greater parallelism\EmDash[]principally because several streams of
products can be generated and merged with the recirculating stream
of future outputs concurrently. It should be noted that the \ldquo[]recirculating
stream\rdquo[] of future output values is now spread out over the
whole dataflow loop, with some values in each intertask buffer and
some in local variables of each task, and with only one end-marker
located somewhere around the loop. Although many tasks now append
to the \tyxffmxmono[]outputs\tyxffmxendmono[] stream, only one at
a time does so as the \ldquo[]front\rdquo[] of the stream of future
outputs advances from one stage to the next, and thus no synchronization
problems arise from this behavior.\Endpara[]
\Para[]The code for the fourth solution, the variant of the novel
algorithm with dataflow loop unrolling, is split between two figures.
Figure \Xref[\def\XrefName{body-of-solver-novel-unrolled}]
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-solver-novel-unrolled}]Proper body of
the \tyxffmxmono[]solver\tyxffmxendmono[] procedure (fourth solution)%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem)
\tyxtstxbf[]procedure\tyxtstxendbf[] solver (n, m    : %
\tyxtstxbf[]in\tyxtstxendbf[]     positive;
                  primes  : \tyxtstxbf[]in\tyxtstxendbf[]     positive\Symuns[]array;
                  outputs : \tyxtstxbf[]in\tyxtstxendbf[] %
\tyxtstxbf[]out\tyxtstxendbf[] stream) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]type%
\tyxtstxendbf[] stage \tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]entry\tyxtstxendbf[] identify\Symuns[]self (k : %
\tyxtstxbf[]in\tyxtstxendbf[] positive);
   \tyxtstxbf[]end\tyxtstxendbf[];
   infinity : \tyxtstxbf[]constant\tyxtstxendbf[] positive := n + 1;
   stages   : \tyxtstxbf[]array\tyxtstxendbf[] (1 .. m) %
\tyxtstxbf[]of\tyxtstxendbf[] stage;
   sbuffers : \tyxtstxbf[]array\tyxtstxendbf[] (1 .. m) %
\tyxtstxbf[]of\tyxtstxendbf[] buffer;
   done     : \tyxtstxbf[]array\tyxtstxendbf[] (1 .. m) %
\tyxtstxbf[]of\tyxtstxendbf[] boolean := (\tyxtstxbf[]others%
\tyxtstxendbf[] =\Symgt[] false);
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] stage \tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]separate%
\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   write (1,        to =\Symgt[] sbuffers(1));
   write (infinity, to =\Symgt[] sbuffers(1));
   \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] stages\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
      stages(k).identify\Symuns[]self (k);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 shows the revised proper body of the \tyxffmxmono[]solver%
\tyxffmxendmono[] procedure, in which the body of the %
\tyxffmxmono[]stage\tyxffmxendmono[] task type is represented by a
body stub. The proper body of \tyxffmxmono[]stage%
\tyxffmxendmono[] is shown in Figure \Xref[\def\XrefName{body-of-stage}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-stage}]Proper body of the %
\tyxffmxmono[]stage\tyxffmxendmono[] task type\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (hammings\Symuns[]problem.solver)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] stage %
\tyxtstxbf[]is\tyxtstxendbf[]
   i, self, successor : positive;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]accept\tyxtstxendbf[] identify\Symuns[]self (k : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]do%
\tyxtstxendbf[]
      self := k;
   \tyxtstxbf[]end\tyxtstxendbf[];
   successor := self \tyxtstxbf[]mod\tyxtstxendbf[] m + 1;
   \tyxtstxbf[]loop\tyxtstxendbf[]
      read   (i, from =\Symgt[] sbuffer(self));
   \tyxtstxbf[]exit\tyxtstxendbf[] \tyxtstxbf[]when%
\tyxtstxendbf[] i = infinity;
      append (i, to   =\Symgt[] outputs);
      \tyxtstxbf[]declare\tyxtstxendbf[]
         j, p     : positive;
         products : buffer;
         \tyxtstxbf[]task\tyxtstxendbf[] products\Symuns[]generator;
         \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] products\Symuns[]generator \tyxtstxbf[]is%
\tyxtstxendbf[]
         \tyxtstxbf[]begin\tyxtstxendbf[]
            \tyxtstxbf[]for\tyxtstxendbf[] k \tyxtstxbf[]in%
\tyxtstxendbf[] primes\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
            \tyxtstxbf[]exit\tyxtstxendbf[] \tyxtstxbf[]when%
\tyxtstxendbf[] i \Symgt[] n/primes(k);
               write (i*primes(k), to =\Symgt[] products);
            \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
            write (infinity, to =\Symgt[] products);
         \tyxtstxbf[]end\tyxtstxendbf[];
      \tyxtstxbf[]begin\tyxtstxendbf[]
         read (j, from =\Symgt[] sbuffer(self));
         read (p, from =\Symgt[] products);
         \tyxtstxbf[]loop\tyxtstxendbf[]
            \tyxtstxbf[]if\tyxtstxendbf[]    j \Symlt[] p %
\tyxtstxbf[]then\tyxtstxendbf[]
               write (j, to   =\Symgt[] sbuffer(successor));
               read  (j, from =\Symgt[] sbuffer(self));
            \tyxtstxbf[]elsif\tyxtstxendbf[] j \Symgt[] p %
\tyxtstxbf[]then\tyxtstxendbf[]
               write (p, to   =\Symgt[] sbuffer(successor));
               read  (p, from =\Symgt[] products);
            \tyxtstxbf[]else\tyxtstxendbf[]
               write (j, to   =\Symgt[] sbuffer(successor));
         \tyxtstxbf[]exit\tyxtstxendbf[] \tyxtstxbf[]when%
\tyxtstxendbf[] j = infinity;
               read  (j, from =\Symgt[] sbuffer(self));
               read  (p, from =\Symgt[] products);
            \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   done(self) := true;
   \tyxtstxbf[]if\tyxtstxendbf[] \tyxtstxbf[]not\tyxtstxendbf[] done(successor) %
\tyxtstxbf[]then\tyxtstxendbf[]
      write (infinity, to =\Symgt[] sbuffer(successor));
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\Endpara[]
\Para[]We have given \tyxffmxmono[]solver\tyxffmxendmono[] an extra
parameter, \tyxffmxmono[]m\tyxffmxendmono[], which is the depth of
the loop unrolling (number of stages); to save space, we omit showing
the trivial change in the specification and body of the %
\tyxffmxmono[]hammings\Symuns[]problem\tyxffmxendmono[] package necessitated
by this addition. Ideally, the value of \tyxffmxmono[]m%
\tyxffmxendmono[] should be increased in proportion to the number
of processors available, at a rate that is probably best determined
empirically (it depends on how much of a processor\rsquo[]s power
is consumed by the tasks of each stage, among other things).%
\Endpara[]
\Para[]In this solution, most of the work is done by the dependent
tasks of \tyxffmxmono[]solver\tyxffmxendmono[]. After \ldquo[]priming\rdquo[]
the first stage and then identifying to each stage its position in
the dataflow loop, \tyxffmxmono[]solver\tyxffmxendmono[] waits (at
its end) for its dependent tasks to terminate before returning to
its caller; when it finally does so, the \tyxffmxmono[]outputs%
\tyxffmxendmono[] stream will have been completed.\Endpara[]
\Para[]As shown by Figure \Xref[\def\XrefName{body-of-stage}], each
stage\rsquo[]s first action is to receive its position in
\TyPbrkNewp[]
 the dataflow loop from \tyxffmxmono[]solver\tyxffmxendmono[]. It
then computes the position of its successor. These positions are,
of course, indices in the arrays declared by \tyxffmxmono[]solver%
\tyxffmxendmono[], so that the successor of the last component in
each of these arrays is the first component. Each \tyxffmxmono[]stage%
\tyxffmxendmono[] uses its own index and that of its successor to
determine which intertask buffer is its input buffer and which is
its output buffer.\Endpara[]
\Para[]When a stage reads the end-marker as the first item from its
input buffer, in an execution of its main loop, it sets its own component
of the \tyxffmxmono[]done\tyxffmxendmono[] array to %
\tyxffmxmono[]true\tyxffmxendmono[], propagates the end-marker if
required, and then terminates. Propagation of the end-marker from
one stage to its successor is required if the successor has not yet
read an end-marker as the first item from \txtxemph[]its%
\txtxendemph[] input buffer, as indicated by the successor\rsquo[]s
component of the \tyxffmxmono[]done\tyxffmxendmono[] array. Were the
end-marker not propagated in this way, stages would deadlock waiting
for input that would never arrive, and \tyxffmxmono[]solver%
\tyxffmxendmono[] would never terminate. But, after the end-marker
(not preceded by any future outputs) has made its way around the dataflow
loop once, all of the stages will have terminated, and there will
thus be no need to propagate it further.\Endpara[]
\Para[]Care has been taken to ensure that the fourth solution will
work for all values of \tyxffmxmono[]m\tyxffmxendmono[]\EmDash[]in
particular, even for the value 1. In that case, the successor of a
stage is itself, and changes made by the stage to its \ldquo[]right-hand\rdquo[]
environment are immediately seen as having an effect on its \ldquo[]left-hand\rdquo[]
environment (and vice versa). The similarities between Figures %
\Xref[\def\XrefName{body-of-stage}] and \Xref[\def\XrefName{body-of-solver-novel}]
suggest that a further level of subprogram abstraction would have
been appropriate.\Endpara[]
\DivEndiv[]
\DivEndiii[]
\DivLiii[]\HdMjLiii[]The Paraffins Problem\HdMjEndiii[]
\Para[]The chemical formula for paraffin molecules is \InlEqn[]\LmthEqn[]
{\rm C_{
{\mit i}}H_{2
{\mit i}+1}}
\LmthEndeqn[]%
\EndInlEqn[]. The problem is as follows: Given an integer %
\InlEqn[]\LmthEqn[]n
\LmthEndeqn[]\EndInlEqn[], output\EmDash[]in order of increasing size\EmDash[]structural
representations of all paraffin molecules for \InlEqn[]\LmthEqn[]i
\leq n
\LmthEndeqn[]%
\EndInlEqn[], including all isomers but no duplicates.\Endpara[]
\Para[]The paraffins problem was designed to reveal the strengths
of applicative languages. Turner\rsquo[]s original solution %
\Cit[\def\CitId{Turner:Paraffins}]\Endcit[] in the applicative language
KRC makes extensive use of set abstraction and higher-order functions
to produce a compact and elegant program at the cost of some inefficiency.
His program was designed to produce all paraffin molecules of a given
size by attaching paraffin radicals of appropriate sizes to a leading
carbon atom without regard, initially, to the fact that this simple
process yields many different representations (different orientations)
of each of the distinct paraffin isomers. Since the problem calls
for producing only one representation of each isomer, Turner\rsquo[]s
solution filters out the duplicates. As each new paraffin molecule
is generated, it is tested for distinctness from all previously retained
molecules. The test for distinctness consists of checking each of
the previously retained molecules for membership in the set of all
structurally equivalent reorientations of the newly generated molecule.
The latter set is obtained on the fly by computing the closure of
the set containing the newly generated molecule under various equivalence-preserving
transformations (rotations, inversions, and swapping of the paraffin
radicals attached to each of the molecule\rsquo[]s carbon atoms).
For this process to be workable, implicit or explicit garbage collection
must be at work. The KRC solution is concise in part because garbage
collection is implicit and in part because no premium is placed on
avoiding the recomputation of a previously computed closure set each
time a new duplicate is found. The strategy adopted by Turner also
was influenced by another feature of KRC\EmDash[]lazy evaluation\EmDash[]which
at least partially reclaims some of the lost efficiency by deferring
the computation of a set element until it is needed (a duplicate is
typically found when its closure set is still incomplete).%
\Endpara[]
\Para[]A programmer faced with solving this problem in a language
not having the powerful and convenient features of KRC (or other applicative
languages) is strongly motivated to forgo Turner\rsquo[]s solution\EmDash[]if
programming explicit garbage collection is unappealing, and if strict
evaluation and repeated computation are unacceptably inefficient\EmDash[]and
instead search for a strategy that generates paraffin molecules so
that duplicates are avoided from the outset. The Ada solution, like
most of the others in this book, follows such a strategy.%
\NtFoot[]\NtNtpar[]Actually, Ada \txtxemph[]allows\txtxendemph[] for
implicit garbage collection, but it also provides mechanisms for explicit
freeing of dynamically allocated storage. Had we found implicit garbage
collection to be routinely implemented, we might have been motivated
to obtain a solution in the spirit of Turner\rsquo[]s; in reality,
it has only rarely been implemented in Ada systems. Ada solutions
significantly different from the present one would have required more
storage or more time, and certainly more code.\NtEndntpar[]%
\NtEndfoot[]\Endpara[]
\Para[]A paraffin molecule can be regarded as a free tree (see %
\Cit[\def\CitId{Knuth:Vol1}]\Endcit[], \Nobr[]pp. 362\EnDash[]363%
\Endnobr[]) whose vertices correspond to the carbon atoms and whose
edges correspond to the carbon-carbon bonds. The distinct paraffin
isomers of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]\EmDash[]that is, having %
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] carbon atoms\EmDash[]therefore correspond to
the structurally distinct free trees having \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]%
\EndInlEqn[] vertices. Our program represents paraffin molecules as
oriented, ordered trees (whose vertices we refer to here as nodes)\EmDash[]not
as free trees\EmDash[]and the essence of our strategy for avoiding
duplicates lies in the mapping between the vertices of the free-tree
representation of a paraffin molecule and the nodes of its corresponding
representation as an oriented, ordered tree in the program.%
\Endpara[]
\Para[]It is apparent that the unordered neighbors of a vertex of
the free-tree representation will become ordered subnodes of the node
to which it is mapped in the representation used in the program. Varying
the order of the subnodes results in different representations of
the same paraffin molecule\EmDash[]that is, in structurally equivalent
paraffin molecules. We avoid this source of duplicates by using a
unique (lexicographic) ordering for the subnodes of a node. Note that
whereas vertices of the free tree may have fewer than four neighbors
(i.e., when they represent carbon atoms to which some hydrogen atoms
are attached), the corresponding nodes in the tree in the program
have either four subnodes (in the case of the root node) or three
subnodes and an ancestor node (in the case of a node other than the
root). Also note that some of the subnodes represent hydrogen atoms;
in the program, the positions at which hydrogen atoms are attached
to carbon atoms are explicit.\Endpara[]
\Para[]It is also apparent that the unoriented edges of the free tree
will become directed links between nodes in the tree in the program
and that some vertex will be mapped to the root node. Varying the
vertex that is mapped to the root node again results in different
representations of the same paraffin molecule. We avoid this source
of duplicates by appealing to the \txtxemph[]centroid theorem for
free trees\txtxendemph[] (see \Cit[\def\CitId{Knuth:Vol1}]%
\Endcit[], \Nobr[]p. 387\Endnobr[]): a free tree of odd size has a
single centroid (vertex of minimum height, where the height of a vertex
is the size of its largest subtree), while one of even size has either
a single centroid or a pair of adjacent centroids. We canonicalize
the representation of single-centroid paraffin molecules by selecting
the centroid as the root node in the program tree. In the case of
double-centroid paraffin molecules, we use as root node a node that
corresponds not to any carbon atom but to the carbon-carbon bond between
the centroids. It has exactly two subnodes, corresponding to the two
centroids; they, of course, are lexicographically ordered as well.%
\Endpara[]
\Para[]To summarize, our strategy avoids duplicates by canonically
selecting root nodes and lexicographically ordering subnodes.%
\Endpara[]
\Para[]Odd-sized paraffin molecules and even-sized single-centroid
paraffin molecules are here called \ldquo[]carbon-centered paraffins,\rdquo[]
or CCPs; the root nodes of their trees correspond to carbon atoms
and have four subnodes, each the root of a subtree representing a
paraffin radical. The four radicals of a CCP of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]%
\EndInlEqn[] each have size less than or equal to \InlEqn[]\LmthEqn[]
\left\lfloor {{{i-1} \over {2}}}
\right\rfloor 
\LmthEndeqn[]%
\EndInlEqn[] and total \InlEqn[]\LmthEqn[]i-1
\LmthEndeqn[]\EndInlEqn[] in size. Even-sized double-centroid
paraffin molecules are here called \ldquo[]bond-centered paraffins,\rdquo[]
or BCPs; the root nodes of their trees correspond to carbon-carbon
bonds and have two subnodes, each the root of a subtree representing
a paraffin radical. The two radicals of a BCP of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]%
\EndInlEqn[] each have size exactly equal to \InlEqn[]\LmthEqn[]{{i} \over {2}}
\LmthEndeqn[]%
\EndInlEqn[] and therefore total \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] in size. For
their part, the root nodes of paraffin radicals of size %
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[], for \InlEqn[]\LmthEqn[]i>0
\LmthEndeqn[]\EndInlEqn[], correspond to carbon
atoms and have three subnodes, each the root of a subtree representing
a paraffin radical. (Thus, the data structure for paraffin radicals
is recursive.) The three subradicals of such a paraffin radical each
have size less than or equal to \InlEqn[]\LmthEqn[]i-1
\LmthEndeqn[]\EndInlEqn[] and total %
\InlEqn[]\LmthEqn[]i-1
\LmthEndeqn[]\EndInlEqn[] in size. A paraffin radical of size 0 is just
a hydrogen radical; its root node corresponds to a hydrogen atom and
has no subnodes. In the program, all three kinds of objects are constructed
by the same process, which amounts to attaching some number\EmDash[]two,
three, or four\EmDash[]of paraffin radicals of appropriate sizes to
some other node. Restrictions on the maximum sizes of the attached
radicals guarantee that the node at the root of a CCP corresponds
to the centroid, and similarly that the pair of nodes immediately
descendent from the root of a BCP always correspond to the adjacent
centroids; this property, together with the lexicographic ordering
of the attached radicals, guarantees the avoidance of duplicates.%
\Endpara[]
\DivLiv[]\HdMinLiv[]Serial Solution\HdMinEndiv[]
\Para[]For the sake of simplicity, we develop in this section a completely
serial solution to the paraffins problem; in the next section, we
discuss the opportunities for parallelism presented by the problem
and obtain one parallel solution by a straightforward modification
of a small part of the serial solution.\Endpara[]
\Para[]At the top level, our serial solution is in the form of a function,
\tyxffmxmono[]paraffins\tyxffmxendmono[] (shown in Figure %
\Xref[\def\XrefName{body-of-paraffins-serial}]),
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-paraffins-serial}]Self-specifying body
of the \tyxffmxmono[]paraffins\tyxffmxendmono[] function (serial version)%
\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] radicals, molecules;
\tyxtstxbf[]use\tyxtstxendbf[]  radicals, molecules;
\tyxtstxbf[]function\tyxtstxendbf[] paraffins (n : positive) %
\tyxtstxbf[]return\tyxtstxendbf[] array\Symuns[]of\Symuns[]molecule\Symuns[]lists %
\tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (positive %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] natural;
   \tyxtstxbf[]use\tyxtstxendbf[] radical\Symuns[]lists, molecule\Symuns[]lists;
   r\Symuns[]array : array\Symuns[]of\Symuns[]radical\Symuns[]lists  (0 .. n/2);
   m\Symuns[]array : array\Symuns[]of\Symuns[]molecule\Symuns[]lists (1 .. n);
   \tyxtstxbf[]generic\tyxtstxendbf[]
      \tyxtstxbf[]with\tyxtstxendbf[] \tyxtstxbf[]procedure%
\tyxtstxendbf[] apply\Symuns[]to\Symuns[]each (tuple : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]radicals);
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (p : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals);
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (p : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals)  %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]separate%
\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]radicals\Symuns[]of\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]ccps\Symuns[]of\Symuns[]size     (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]bcps\Symuns[]of\Symuns[]size     (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   append (hydrogen\Symuns[]radical, to =\Symgt[] r\Symuns[]array(0));
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n/2 \tyxtstxbf[]loop\tyxtstxendbf[]
      generate\Symuns[]radicals\Symuns[]of\Symuns[]size (i);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      generate\Symuns[]ccps\Symuns[]of\Symuns[]size (i);
      \tyxtstxbf[]if\tyxtstxendbf[] i \tyxtstxbf[]mod%
\tyxtstxendbf[] 2 = 0 \tyxtstxbf[]then\tyxtstxendbf[]
         generate\Symuns[]bcps\Symuns[]of\Symuns[]size (i);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]return\tyxtstxendbf[] m\Symuns[]array;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 that takes a positive integer, \tyxffmxmono[]n\tyxffmxendmono[],
and returns an array, indexed by the values 1 to \tyxffmxmono[]n%
\tyxffmxendmono[], whose \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]th component is a list
of the unique paraffin isomers of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]. The
function is compiled in the context of some application-dependent
types for radicals and molecules that are defined in the two library
packages (\tyxffmxmono[]radicals\tyxffmxendmono[] and %
\tyxffmxmono[]molecules\tyxffmxendmono[]) named in its context clauses.
Certainly the function needs some such types; presumably the larger
application of which the function is a part does, too. (The specifications
and bodies of the packages of types are shown in Figures \Xref[\def\XrefName{spec-of-radicals}]
through \Xref[\def\XrefName{body-of-molecules}].) The %
\tyxffmxmono[]paraffins\tyxffmxendmono[] function first sequentially
creates, and internally stores in the components of the local array
\tyxffmxmono[]r\Symuns[]array\tyxffmxendmono[], lists of paraffin
radicals of sizes 0 to \tyxffmxmono[]n/2\tyxffmxendmono[] (integer
division in Ada truncates towards zero, which for positive operands
is equivalent to delivering the floor of the quotient); %
\tyxffmxmono[]n/2\tyxffmxendmono[] is the size of the largest radical
that will be needed for a paraffin molecule of size %
\tyxffmxmono[]n\tyxffmxendmono[]. The radicals are created in order
of size because smaller radicals are needed for the construction of
larger ones.\NtFoot[]\NtNtpar[]Our lexicographic ordering is such
that two radicals are lexicographically ordered if the first is smaller
than the second or if they are of the same size and the first occurs
not later than the second on the list of radicals of their common
size.\NtEndntpar[]\NtEndfoot[] Next, the function sequentially creates
lists of paraffin molecules of sizes 1 to \tyxffmxmono[]n%
\tyxffmxendmono[], storing in the \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]th component
of \tyxffmxmono[]m\Symuns[]array\tyxffmxendmono[] the list for size
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]\EmDash[]first the CCPs, and then (for even sizes)
the BCPs. Finally, it returns \tyxffmxmono[]m\Symuns[]array%
\tyxffmxendmono[]. (The contents of the function are further discussed
later.)\Endpara[]
\Para[]Let\rsquo[]s look at the packages that declare the problem-dependent
types used in the solution. The specification of the package %
\tyxffmxmono[]radicals\tyxffmxendmono[] is shown in Figure %
\Xref[\def\XrefName{spec-of-radicals}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-radicals}]Specification of the %
\tyxffmxmono[]radicals\tyxffmxendmono[] package\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] lists;
\tyxtstxbf[]package\tyxtstxendbf[] radicals \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] radical\Symuns[]kind %
\tyxtstxbf[]is\tyxtstxendbf[] (hydrogen, carboniferous);
   \tyxtstxbf[]type\tyxtstxendbf[] radical\Symuns[]node (kind : radical\Symuns[]kind);
   \tyxtstxbf[]type\tyxtstxendbf[] radical           %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]access\tyxtstxendbf[] radical\Symuns[]node;
   \tyxtstxbf[]type\tyxtstxendbf[] array\Symuns[]of\Symuns[]radicals %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (positive %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] radical;
   \tyxtstxbf[]subtype\tyxtstxendbf[] two\Symuns[]radicals   %
\tyxtstxbf[]is\tyxtstxendbf[] array\Symuns[]of\Symuns[]radicals (1 .. 2);
   \tyxtstxbf[]subtype\tyxtstxendbf[] three\Symuns[]radicals %
\tyxtstxbf[]is\tyxtstxendbf[] array\Symuns[]of\Symuns[]radicals (1 .. 3);
   \tyxtstxbf[]subtype\tyxtstxendbf[] four\Symuns[]radicals  %
\tyxtstxbf[]is\tyxtstxendbf[] array\Symuns[]of\Symuns[]radicals (1 .. 4);
   \tyxtstxbf[]type\tyxtstxendbf[] radical\Symuns[]node (kind : radical\Symuns[]kind) %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]record\tyxtstxendbf[]
      \tyxtstxbf[]case\tyxtstxendbf[] kind \tyxtstxbf[]is%
\tyxtstxendbf[]
      \tyxtstxbf[]when\tyxtstxendbf[] hydrogen =\Symgt[]
         \tyxtstxbf[]null\tyxtstxendbf[];
      \tyxtstxbf[]when\tyxtstxendbf[] carboniferous =\Symgt[]
         carbon\Symuns[]neighbors : three\Symuns[]radicals;
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]case%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]record%
\tyxtstxendbf[];
   \tyxtstxbf[]package\tyxtstxendbf[] radical\Symuns[]lists %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] lists (radical);
   \tyxtstxbf[]subtype\tyxtstxendbf[] radical\Symuns[]list  %
\tyxtstxbf[]is\tyxtstxendbf[] radical\Symuns[]lists.list;
   \tyxtstxbf[]type\tyxtstxendbf[] array\Symuns[]of\Symuns[]radical\Symuns[]lists %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]array\tyxtstxendbf[] (natural \tyxtstxbf[]range%
\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of\tyxtstxendbf[] radical\Symuns[]list;
   \tyxtstxbf[]function\tyxtstxendbf[] hydrogen\Symuns[]radical %
\tyxtstxbf[]return\tyxtstxendbf[] radical;
   \tyxtstxbf[]function\tyxtstxendbf[] radical\Symuns[]made\Symuns[]from (subradicals : three\Symuns[]radicals)
      \tyxtstxbf[]return\tyxtstxendbf[] radical;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 Radicals are trees whose nodes are of the type \tyxffmxmono[]radical\Symuns[]node%
\tyxffmxendmono[], which is a record type with a discriminant indicating
whether the node represents a hydrogen radical (which has no subnodes)
or a carboniferous radical (which has three). The type %
\tyxffmxmono[]radical\tyxffmxendmono[] is an access type whose designated
type is \tyxffmxmono[]radical\Symuns[]node\tyxffmxendmono[]; thus
a radical is represented by the pointer to its root node, which if
not degenerate contains pointers to its subnodes, etc. An unconstrained
array type providing for arrays of radicals is also declared, as are
several constrained subtypes thereof with fixed numbers of components;
one of these is used in the declaration of \tyxffmxmono[]radical\Symuns[]node%
\tyxffmxendmono[]. Linked lists of radicals are obtained by instantiating
with the type \tyxffmxmono[]radical\tyxffmxendmono[] a generic package
called \tyxffmxmono[]lists\tyxffmxendmono[] which, because of its
utility in diverse applications, we assume to be available as an application-independent
library unit; the specification of \tyxffmxmono[]radicals%
\tyxffmxendmono[] is compiled in its context. We do not show its definition
here, and we merely remark that we assume it exports at least a type
called \tyxffmxmono[]list\tyxffmxendmono[]; \tyxffmxmono[]head%
\tyxffmxendmono[], \tyxffmxmono[]tail\tyxffmxendmono[], and %
\tyxffmxmono[]is\Symuns[]empty\tyxffmxendmono[] functions; and an
\tyxffmxmono[]append\tyxffmxendmono[] procedure. We furthermore assume
that lists are initially empty. Another unconstrained array type providing
for arrays of linked lists of radicals is declared, and finally two
functions are declared\EmDash[]one for allocating, and returning a
pointer to, an object of type \tyxffmxmono[]radical\Symuns[]node%
\tyxffmxendmono[] representing a hydrogen radical, and one for allocating,
and returning a pointer to, an object of type \tyxffmxmono[]radical\Symuns[]node%
\tyxffmxendmono[] representing a carboniferous paraffin radical made
from pointers to the objects of type \tyxffmxmono[]radical\Symuns[]node%
\tyxffmxendmono[] that are its subnodes.\Endpara[]
\Para[]The body of the \tyxffmxmono[]radicals\tyxffmxendmono[] package
is shown in Figure \Xref[\def\XrefName{body-of-radicals}];
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-radicals}]Body of the \tyxffmxmono[]radicals%
\tyxffmxendmono[] package\FgEndcap[]
\Comp[]\tyxtstxbf[]package\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] radicals \tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]function\tyxtstxendbf[] hydrogen\Symuns[]radical %
\tyxtstxbf[]return\tyxtstxendbf[] radical \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]return\tyxtstxendbf[] \tyxtstxbf[]new%
\tyxtstxendbf[] radical\Symuns[]node\rsquo[](kind =\Symgt[] hydrogen);
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] radical\Symuns[]made\Symuns[]from (subradicals : three\Symuns[]radicals)
      \tyxtstxbf[]return\tyxtstxendbf[] radical \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]return\tyxtstxendbf[] \tyxtstxbf[]new%
\tyxtstxendbf[] radical\Symuns[]node\rsquo[](kind             =\Symgt[] carboniferous,
                               carbon\Symuns[]neighbors =\Symgt[] subradicals);
   \tyxtstxbf[]end\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 it contains the bodies of the radical-constructing functions declared
in its specification. These are simple enough that they should need
no explanation.\Endpara[]
\Para[]The specification of the \tyxffmxmono[]molecules%
\tyxffmxendmono[] package is shown in Figure \Xref[\def\XrefName{spec-of-molecules}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-molecules}]Specification of the %
\tyxffmxmono[]molecules\tyxffmxendmono[] package\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] radicals, lists;
\tyxtstxbf[]use\tyxtstxendbf[]  radicals;
\tyxtstxbf[]package\tyxtstxendbf[] molecules \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] molecule\Symuns[]kind %
\tyxtstxbf[]is\tyxtstxendbf[] (bond\Symuns[]centered, carbon\Symuns[]centered);
   \tyxtstxbf[]type\tyxtstxendbf[] molecule\Symuns[]node (kind : molecule\Symuns[]kind) %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]record\tyxtstxendbf[]
      \tyxtstxbf[]case\tyxtstxendbf[] kind \tyxtstxbf[]is%
\tyxtstxendbf[]
      \tyxtstxbf[]when\tyxtstxendbf[] bond\Symuns[]centered =\Symgt[]
         bond\Symuns[]neighbors : two\Symuns[]radicals;
      \tyxtstxbf[]when\tyxtstxendbf[] carbon\Symuns[]centered =\Symgt[]
         carbon\Symuns[]neighbors : four\Symuns[]radicals;
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]case%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]record%
\tyxtstxendbf[];
   \tyxtstxbf[]type\tyxtstxendbf[] molecule \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]access\tyxtstxendbf[] molecule\Symuns[]node;
   \tyxtstxbf[]package\tyxtstxendbf[] molecule\Symuns[]lists %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] lists (molecule);
   \tyxtstxbf[]subtype\tyxtstxendbf[] molecule\Symuns[]list  %
\tyxtstxbf[]is\tyxtstxendbf[] molecule\Symuns[]lists.list;
   \tyxtstxbf[]type\tyxtstxendbf[] array\Symuns[]of\Symuns[]molecule\Symuns[]lists %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]array\tyxtstxendbf[] (positive \tyxtstxbf[]range%
\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of\tyxtstxendbf[] molecule\Symuns[]list;
   \tyxtstxbf[]function\tyxtstxendbf[] molecule\Symuns[]made\Symuns[]from (radicals : array\Symuns[]of\Symuns[]radicals)
      \tyxtstxbf[]return\tyxtstxendbf[] molecule;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
\TyPbrkNewp[]
 Molecules are trees whose root nodes are of the type %
\tyxffmxmono[]molecule\Symuns[]node\tyxffmxendmono[], which is a record
type with a discriminant indicating whether the node represents a
BCP (which has two subnodes) or a CCP (which has four). The type %
\tyxffmxmono[]molecule\tyxffmxendmono[] is an access type whose designated
type is \tyxffmxmono[]molecule\Symuns[]node\tyxffmxendmono[]; thus
a molecule is represented by the pointer to its root node, which contains
pointers to its subnodes, etc. Note that the types %
\tyxffmxmono[]molecule\Symuns[]node\tyxffmxendmono[] and %
\tyxffmxmono[]molecule\tyxffmxendmono[], unlike the types %
\tyxffmxmono[]radical\Symuns[]node\tyxffmxendmono[] and %
\tyxffmxmono[]radical\tyxffmxendmono[], are not recursive types. That
is, the subnodes of a molecule are not molecules but radicals. To
achieve visibility to the types associated with radicals, we compile
the specification of \tyxffmxmono[]molecules\tyxffmxendmono[] in the
context of \tyxffmxmono[]radicals\tyxffmxendmono[] (that is, it \ldquo[]withs\rdquo[]
\tyxffmxmono[]radicals\tyxffmxendmono[]). Linked lists of molecules
are obtained by instantiating with the type \tyxffmxmono[]molecule%
\tyxffmxendmono[] the previously discussed generic package %
\tyxffmxmono[]lists\tyxffmxendmono[], which is therefore also named
in the context clause of the specification of \tyxffmxmono[]molecules%
\tyxffmxendmono[]. An unconstrained array type providing for arrays
of linked lists of molecules is declared, and finally we declare a
function for allocating, and returning a pointer to, an object of
type \tyxffmxmono[]molecule\Symuns[]node\tyxffmxendmono[], made from
pointers to the objects of type \tyxffmxmono[]radical\Symuns[]node%
\tyxffmxendmono[] that are its subnodes.\Endpara[]
\Para[]The body of the \tyxffmxmono[]molecules\tyxffmxendmono[] package
is shown in Figure \Xref[\def\XrefName{body-of-molecules}];
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-molecules}]Body of the %
\tyxffmxmono[]molecules\tyxffmxendmono[] package\FgEndcap[]
\Comp[]\tyxtstxbf[]package\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] molecules \tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]function\tyxtstxendbf[] molecule\Symuns[]made\Symuns[]from (radicals : array\Symuns[]of\Symuns[]radicals)
      \tyxtstxbf[]return\tyxtstxendbf[] molecule \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]if\tyxtstxendbf[] radicals\rsquo[]length = 2 %
\tyxtstxbf[]then\tyxtstxendbf[]
         \tyxtstxbf[]return\tyxtstxendbf[] \tyxtstxbf[]new%
\tyxtstxendbf[] molecule\Symuns[]node\rsquo[](kind =\Symgt[] bond\Symuns[]centered,
                                   bond\Symuns[]neighbors =\Symgt[] radicals);
      \tyxtstxbf[]else\tyxtstxendbf[] -- Must be 4.
         \tyxtstxbf[]return\tyxtstxendbf[] \tyxtstxbf[]new%
\tyxtstxendbf[] molecule\Symuns[]node\rsquo[](kind =\Symgt[] carbon\Symuns[]centered,
                                   carbon\Symuns[]neighbors =\Symgt[] radicals);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 it contains the body of the molecule-constructing function declared
in its specification. It is simple enough that it should need no explanation.%
\Endpara[]
\Para[]The reader should return to the body of \tyxffmxmono[]paraffins%
\tyxffmxendmono[] (Figure \Xref[\def\XrefName{body-of-paraffins-serial}])
for a moment. The function of the use clause in the context clause
preceding the \tyxffmxmono[]paraffins\tyxffmxendmono[] function is
to provide direct visibility to the names declared in both %
\tyxffmxmono[]radicals\tyxffmxendmono[] and \tyxffmxmono[]molecules%
\tyxffmxendmono[]. These names include \tyxffmxmono[]radical\Symuns[]lists%
\tyxffmxendmono[] and \tyxffmxmono[]molecule\Symuns[]lists%
\tyxffmxendmono[], the packages obtained in \tyxffmxmono[]radicals%
\tyxffmxendmono[] and \tyxffmxmono[]molecules\tyxffmxendmono[] by
the instantiation therein of \tyxffmxmono[]lists%
\tyxffmxendmono[]. However, the visible names do not include those
of the operations on lists (\tyxffmxmono[]head\tyxffmxendmono[], %
\tyxffmxmono[]tail\tyxffmxendmono[], \tyxffmxmono[]append%
\tyxffmxendmono[], \tyxffmxmono[]is\Symuns[]empty%
\tyxffmxendmono[]), since those operations are not declared in %
\tyxffmxmono[]radicals\tyxffmxendmono[] or \tyxffmxmono[]molecules%
\tyxffmxendmono[]. It is the function of the second use clause, the
one in the declarative part of the \tyxffmxmono[]paraffins%
\tyxffmxendmono[] function, to provide direct visibility to them.
Note that the same set of subprogram
\TyPbrkNewp[]
 names is exported by both \tyxffmxmono[]radical\Symuns[]lists%
\tyxffmxendmono[] and \tyxffmxmono[]molecule\Symuns[]lists%
\tyxffmxendmono[]. How does the compiler know from which of these
packages the name \tyxffmxmono[]append\tyxffmxendmono[], appearing
later in \tyxffmxmono[]paraffins\tyxffmxendmono[], comes? The answer
is that the overloaded names of the two \tyxffmxmono[]append%
\tyxffmxendmono[] procedures are disambiguated by overload resolution,
based on the types of the actual parameters in a call; the same is
true of calls to \tyxffmxmono[]head\tyxffmxendmono[], %
\tyxffmxmono[]tail\tyxffmxendmono[], \tyxffmxmono[]is\Symuns[]empty%
\tyxffmxendmono[], and other calls to \tyxffmxmono[]append%
\tyxffmxendmono[] in other parts of the solution. No such overload
resolution occurs, however, for the type name \tyxffmxmono[]list%
\tyxffmxendmono[] exported by both \tyxffmxmono[]radical\Symuns[]lists%
\tyxffmxendmono[] and \tyxffmxmono[]molecule\Symuns[]lists%
\tyxffmxendmono[]; in fact, the two occurrences of the identical type
name cancel each other out, and neither is directly visible by the
simple name \tyxffmxmono[]list\tyxffmxendmono[] in %
\tyxffmxmono[]paraffins\tyxffmxendmono[] or in subunits thereof. That
is why we declared the subtype \tyxffmxmono[]radical\Symuns[]list%
\tyxffmxendmono[] in the specification of \tyxffmxmono[]radicals%
\tyxffmxendmono[] as being synonymous with the type %
\tyxffmxmono[]list\tyxffmxendmono[] exported by \tyxffmxmono[]radical\Symuns[]lists%
\tyxffmxendmono[], and the subtype \tyxffmxmono[]molecule\Symuns[]list%
\tyxffmxendmono[] in the specification of \tyxffmxmono[]molecules%
\tyxffmxendmono[] as being synonymous with the type %
\tyxffmxmono[]list\tyxffmxendmono[] exported by \tyxffmxmono[]molecule\Symuns[]lists%
\tyxffmxendmono[]. So, in \tyxffmxmono[]paraffins%
\tyxffmxendmono[] and its subunits, we use the name %
\tyxffmxmono[]radical\Symuns[]list\tyxffmxendmono[] or %
\tyxffmxmono[]molecule\Symuns[]list\tyxffmxendmono[] as appropriate,
instead of the ambiguous (and not even directly visible) name %
\tyxffmxmono[]list\tyxffmxendmono[].\NtFoot[]\NtNtpar[]Actually, the
only use of either name in one of these places is in the proper body
of the generic procedure \tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples%
\tyxffmxendmono[], which is one of the subunits of %
\tyxffmxmono[]paraffins\tyxffmxendmono[]; see Figure \Xref[\def\XrefName{body-of-enum-rad-tuples}].%
\NtEndntpar[]\NtEndfoot[]\Endpara[]
\Para[]We turn now to the real work of constructing paraffin radicals,
BCPs, and CCPs.\Endpara[]
\Para[]Radicals of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[], for \InlEqn[]\LmthEqn[]i>0
\LmthEndeqn[]%
\EndInlEqn[], are generated by first enumerating all ordered, nondecreasing,
ternary partitions of \InlEqn[]\LmthEqn[]i-1
\LmthEndeqn[]\EndInlEqn[]. The partitions are enumerated
in a natural order. (For example, the ordered, nondecreasing, ternary
partitions of 7 are enumerated in the order (0,0,7), (0,1,6), (0,2,5),
(0,3,4), (1,1,5), (1,2,4), (1,3,3), (2,2,3).) Each such partition
gives the sizes of the three subradicals that need to be attached
(in order) to a carbon atom to obtain a radical of size %
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]; since the maximum size of any of these subradicals
is \InlEqn[]\LmthEqn[]i-1
\LmthEndeqn[]\EndInlEqn[], they are guaranteed to have been created
earlier (remember that the radicals are created in order of size).
As each such partition is enumerated, we subordinately enumerate all
lexicographically ordered triples of radicals having the indicated
sizes. Each such triple gives the actual subradicals that need to
be attached (in order) to a carbon atom to obtain a radical of size
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]. This overall process generates the radicals
of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] in lexicographic order.\Endpara[]
\Para[]CCPs of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] are generated by using the
same process, with different parameters. First we enumerate all ordered,
nondecreasing, \txtxemph[]quaternary\txtxendemph[] partitions of %
\InlEqn[]\LmthEqn[]i-1
\LmthEndeqn[]\EndInlEqn[] having elements of maximum size \InlEqn[]\LmthEqn[]
\left\lfloor {{{i-1} \over {2}}}
\right\rfloor 
\LmthEndeqn[]%
\EndInlEqn[]. Each such partition gives the sizes of the four radicals
that need to be attached (in order) to a carbon atom to obtain a CCP
of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]; the radicals are guaranteed to have
been created earlier (remember that the radicals are created before
the molecules). As each such partition is enumerated, we subordinately
enumerate all lexicographically ordered quads of radicals having the
indicated sizes. Each such quad gives the actual radicals that need
to be attached (in order) to a carbon atom to obtain a CCP of size
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[].\Endpara[]
\Para[]In theory, we do not need to enumerate partitions to obtain
the sizes of the constituent radicals of BCPs of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]%
\EndInlEqn[], since the only partition we need is \InlEqn[]\LmthEqn[]
\left( {{{i} \over {2}},{{i} \over {2}}}
\right) 
\LmthEndeqn[]%
\EndInlEqn[], and it can be obtained simply by constructing its sole
element. However, we can reuse the software components used for generating
radicals and CCPs by supplying them with parameters that will enumerate
all ordered, nondecreasing, \txtxemph[]binary\txtxendemph[] partitions
of \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] having elements of both minimum and maximum
size \InlEqn[]\LmthEqn[]{{i} \over {2}}
\LmthEndeqn[]\EndInlEqn[]; of course, there will be only one. This
partition gives the sizes of the two radicals that need to be attached
(in order) to a carbon-carbon bond to obtain a BCP of size %
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]. Subordinately, we enumerate all lexicographically
ordered pairs of radicals having the indicated sizes. Each such pair
gives the actual radicals that need to be attached (in order) to a
carbon-carbon bond to obtain a BCP of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[].%
\Endpara[]
\Para[]From the preceding discussion, it should be clear that a central
component of our solution is a procedure that enumerates all the ordered,
nondecreasing partitions of a given positive integer into a given
number of elements each bounded by a given minimum and maximum. This
suggests a procedure with four formal parameters. Actually, a fifth
parameter is needed: the name of the procedure encapsulating the operation
to be applied to each partition as it is enumerated (that operation
is the one that enumerates the tuples of radicals of the sizes given
by the partition). Since parameterization by a procedure can currently
be accomplished in Ada only with the use of generic units, we make
our partition-enumerating procedure into a generic procedure. It is
called \tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[], and
its specification is shown in Figure \Xref[\def\XrefName{spec-of-enum-partitions}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-enum-partitions}]Specification of the
\tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[] generic procedure%
\FgEndcap[]
\Comp[]\tyxtstxbf[]generic\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] array\Symuns[]type %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (positive %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] natural;
   \tyxtstxbf[]with\tyxtstxendbf[] \tyxtstxbf[]procedure%
\tyxtstxendbf[] apply\Symuns[]to\Symuns[]each (p : \tyxtstxbf[]in%
\tyxtstxendbf[] array\Symuns[]type);
\tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]partitions (sum\Symuns[]of\Symuns[]elements : %
\tyxtstxbf[]in\tyxtstxendbf[] natural;
                           nbr\Symuns[]of\Symuns[]elements : %
\tyxtstxbf[]in\tyxtstxendbf[] positive;
                           min\Symuns[]element     : %
\tyxtstxbf[]in\tyxtstxendbf[] natural;
                           max\Symuns[]element     : %
\tyxtstxbf[]in\tyxtstxendbf[] natural);\Endcomp[]
\EndParbox[]
\FgEndblock[]
 Since the declaration of the generic formal subprogram parameter,
named \tyxffmxmono[]apply\Symuns[]to\Symuns[]each%
\tyxffmxendmono[], must mention a type\EmDash[]that of the array used
to pass an enumerated partition to the actual subprogram associated
with \tyxffmxmono[]apply\Symuns[]to\Symuns[]each%
\tyxffmxendmono[]\EmDash[]we make that type another generic formal
parameter, named \tyxffmxmono[]array\Symuns[]type%
\tyxffmxendmono[]. In so doing, we import into \tyxffmxmono[]enum\Symuns[]partitions%
\tyxffmxendmono[] everything it needs to be instantiated for an application;
it gets nothing else from a global scope or a context clause and can
therefore be an application-independent library unit. So, the generic
procedure \tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[] has
two generic formal parameters, and the ordinary procedure that is
obtained by instantiating it has four ordinary formal parameters.
The body of \tyxffmxmono[]enum\Symuns[]partitions%
\tyxffmxendmono[] will be shown later.\Endpara[]
\Para[]We can anticipate three instantiations of \tyxffmxmono[]enum\Symuns[]partitions%
\tyxffmxendmono[]\EmDash[]for generating radicals, BPCs, and CCPs.
What procedures will be associated with \tyxffmxmono[]apply\Symuns[]to\Symuns[]each%
\tyxffmxendmono[] in those three instantiations, and what types with
\tyxffmxmono[]array\Symuns[]type\tyxffmxendmono[]? The second part
of the question will be answered later, when we actually look at the
instantiations. The three procedures we need for the generic actual
subprogram parameters all have much in common: they take an array
specifying a nondecreasing sequence of radical sizes and must enumerate
all tuples of lexicographically ordered radicals of the corresponding
sizes. This suggests a procedure with one formal parameter. However,
another parameter is needed: the name of a procedure encapsulating
the operation to be applied to each tuple as it is enumerated (that
operation is the one that actually constructs a radical, BCP, or CCP
from the tuple of radicals and appends it to the appropriate list).
Again, we require the use of generic units. Thus, the three tuple-enumerating
procedures will be obtained by instantiating a second generic procedure,
which we call \tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples%
\tyxffmxendmono[]. Unlike \tyxffmxmono[]enum\Symuns[]partitions%
\tyxffmxendmono[], \tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples%
\tyxffmxendmono[] is very much application specific; it needs to access
the list of radicals of a given size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[]\EmDash[]that
is, \tyxffmxmono[]r\Symuns[]array(i)\tyxffmxendmono[]. The simplest
way to give it that visibility is to nest it within %
\tyxffmxmono[]paraffins\tyxffmxendmono[] (see Figure \Xref[\def\XrefName{body-of-paraffins-serial}]).
Its body, a subunit of \tyxffmxmono[]paraffins\tyxffmxendmono[], is
shown later.\Endpara[]
\Para[]We can now turn to the three procedures that %
\tyxffmxmono[]paraffins\tyxffmxendmono[] calls: \tyxffmxmono[]generate\Symuns[]rad%
\tyxdishyph[]icals\Symuns[]of\Symuns[]size\tyxffmxendmono[], %
\tyxffmxmono[]generate\Symuns[]ccps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[], and \tyxffmxmono[]generate\Symuns[]bcps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[]. Their specifications were in \tyxffmxmono[]paraffins%
\tyxffmxendmono[], and their bodies were occupied there by body stubs.
The proper body of \tyxffmxmono[]generate\Symuns[]radicals\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] is shown in Figure
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-generate-radicals-of-size}]Proper body
of the \tyxffmxmono[]generate\Symuns[]radicals\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] procedure\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] enum\Symuns[]partitions;
\tyxtstxbf[]separate\tyxtstxendbf[] (paraffins)
\tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]radicals\Symuns[]of\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]procedure\tyxtstxendbf[] make\Symuns[]and\Symuns[]append\Symuns[]rad (triple : %
\tyxtstxbf[]in\tyxtstxendbf[] three\Symuns[]radicals) %
\tyxtstxbf[]is\tyxtstxendbf[] 
   \tyxtstxbf[]begin\tyxtstxendbf[]
      append (radical\Symuns[]made\Symuns[]from(triple), to =\Symgt[] r\Symuns[]array(i));
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]subrads\Symuns[]for\Symuns[]rads %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (apply\Symuns[]to\Symuns[]each =\Symgt[] make\Symuns[]and\Symuns[]append\Symuns[]rad);
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]partitions\Symuns[]for\Symuns[]rads %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] enum\Symuns[]partitions (array\Symuns[]type    =\Symgt[] array\Symuns[]of\Symuns[]naturals,
                           apply\Symuns[]to\Symuns[]each =\Symgt[] enum\Symuns[]subrads\Symuns[]for\Symuns[]rads);
\tyxtstxbf[]begin\tyxtstxendbf[]
   enum\Symuns[]partitions\Symuns[]for\Symuns[]rads (sum\Symuns[]of\Symuns[]elements =\Symgt[] i-1,
                             nbr\Symuns[]of\Symuns[]elements =\Symgt[] 3,
                             min\Symuns[]element     =\Symgt[] 0,
                             max\Symuns[]element     =\Symgt[] i-1);
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 \Xref[\def\XrefName{body-of-generate-radicals-of-size}]. We see there
\LstList[]
\LstItem[]the self-specifying body of a local procedure, %
\tyxffmxmono[]make\Symuns[]and\Symuns[]append\Symuns[]rad%
\tyxffmxendmono[], that takes an array of three radicals, makes a
new radical with them as subradicals, and appends the new radical
to \tyxffmxmono[]r\Symuns[]array(i)\tyxffmxendmono[], where %
\tyxffmxmono[]i\tyxffmxendmono[] is the formal parameter of %
\tyxffmxmono[]generate\Symuns[]radicals\Symuns[]of\Symuns[]size%
\tyxffmxendmono[];\LstEnditem[]
\LstItem[]an instantiation of the generic procedure %
\tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples\tyxffmxendmono[] (visible
because it is declared in the parent unit, \tyxffmxmono[]paraffins%
\tyxffmxendmono[]) with \tyxffmxmono[]make\Symuns[]and\Symuns[]append\Symuns[]rad%
\tyxffmxendmono[] as generic actual parameter, to yield the ordinary
procedure \tyxffmxmono[]enum\Symuns[]sub\tyxdishyph[]rads\Symuns[]for\Symuns[]rads%
\tyxffmxendmono[];\LstEnditem[]
\LstItem[]an instantiation of the generic procedure %
\tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[] (visible because
of the context clause) with \tyxffmxmono[]enum\Symuns[]subrads\Symuns[]for\Symuns[]rads%
\tyxffmxendmono[] and \tyxffmxmono[]array\Symuns[]of\Symuns[]naturals%
\tyxffmxendmono[]\NtFoot[]\NtNtpar[]This unconstrained array type
was declared in the parent unit, \tyxffmxmono[]paraffins%
\tyxffmxendmono[]. We explained in the preceding paragraph why %
\tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[] was invested
with the generic formal type \tyxffmxmono[]array\Symuns[]type%
\tyxffmxendmono[], with which \tyxffmxmono[]array\Symuns[]of\Symuns[]naturals%
\tyxffmxendmono[] is here associated. The other generic procedure,
\tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples\tyxffmxendmono[], needs
\tyxffmxmono[]array\Symuns[]of\Symuns[]naturals\tyxffmxendmono[] as
well; however, since that generic procedure is quite problem specific
anyway, and for that reason is nested within \tyxffmxmono[]paraffins%
\tyxffmxendmono[], it obtains visibility of \tyxffmxmono[]array\Symuns[]of\Symuns[]naturals%
\tyxffmxendmono[] by virtue of that nesting and does not need to import
\tyxffmxmono[]array\Symuns[]of\Symuns[]naturals\tyxffmxendmono[] by
generic parameter association.\NtEndntpar[]\NtEndfoot[] as generic
actual parameters, to yield the ordinary procedure %
\tyxffmxmono[]enum\Symuns[]partitions\Symuns[]for\Symuns[]rads%
\tyxffmxendmono[]; and\LstEnditem[]
\LstItem[]the call of \tyxffmxmono[]enum\Symuns[]partitions\Symuns[]for\Symuns[]rads%
\tyxffmxendmono[] with appropriate expressions involving %
\tyxffmxmono[]i\tyxffmxendmono[] as actual parameters.%
\LstEnditem[]
\LstEndlist[]
Note that there is only one executable statement in %
\tyxffmxmono[]generate\Symuns[]radicals\Symuns[]of\Symuns[]size%
\tyxffmxendmono[].\Endpara[]
\Para[]The proper body of \tyxffmxmono[]generate\Symuns[]ccps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] is shown in Figure \Xref[\def\XrefName{body-of-generate-ccps-of-size}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-generate-ccps-of-size}]Proper body of
the \tyxffmxmono[]generate\Symuns[]ccps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] procedure\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] enum\Symuns[]partitions;
\tyxtstxbf[]separate\tyxtstxendbf[] (paraffins)
\tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]ccps\Symuns[]of\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]procedure\tyxtstxendbf[] make\Symuns[]and\Symuns[]append\Symuns[]ccp (quad : %
\tyxtstxbf[]in\tyxtstxendbf[] four\Symuns[]radicals) %
\tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]begin\tyxtstxendbf[]
      append (molecule\Symuns[]made\Symuns[]from(quad), to =\Symgt[] m\Symuns[]array(i));
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rads\Symuns[]for\Symuns[]ccps %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (apply\Symuns[]to\Symuns[]each =\Symgt[] make\Symuns[]and\Symuns[]append\Symuns[]ccp);
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]partitions\Symuns[]for\Symuns[]ccps %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] enum\Symuns[]partitions (array\Symuns[]type    =\Symgt[] array\Symuns[]of\Symuns[]naturals,
                           apply\Symuns[]to\Symuns[]each =\Symgt[] enum\Symuns[]rads\Symuns[]for\Symuns[]ccps);
\tyxtstxbf[]begin\tyxtstxendbf[]
   enum\Symuns[]partitions\Symuns[]for\Symuns[]ccps (sum\Symuns[]of\Symuns[]elements =\Symgt[] i-1,
                             nbr\Symuns[]of\Symuns[]elements =\Symgt[] 4,
                             min\Symuns[]element     =\Symgt[] 0,
                             max\Symuns[]element     =\Symgt[] (i-1)/2);
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 Its contents are analogous to those of \tyxffmxmono[]generate\Symuns[]radicals\Symuns[]of\Symuns[]size%
\tyxffmxendmono[], differing only in the procedure %
\tyxffmxmono[]make\Symuns[]and\Symuns[]append\Symuns[]ccp%
\tyxffmxendmono[] at the head of the chain of instantiations and in
the expressions involving \tyxffmxmono[]i\tyxffmxendmono[] in the
call of the procedure at the tail of the chain of instantiations.%
\Endpara[]
\Para[]The analogous proper body of \tyxffmxmono[]generate\Symuns[]bcps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] is shown in Figure \Xref[\def\XrefName{body-of-generate-bcps-of-size}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-generate-bcps-of-size}]Proper body of
the \tyxffmxmono[]generate\Symuns[]bcps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] procedure\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] enum\Symuns[]partitions;
\tyxtstxbf[]separate\tyxtstxendbf[] (paraffins)
\tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]bcps\Symuns[]of\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]procedure\tyxtstxendbf[] make\Symuns[]and\Symuns[]append\Symuns[]bcp (pair : %
\tyxtstxbf[]in\tyxtstxendbf[] two\Symuns[]radicals) \tyxtstxbf[]is%
\tyxtstxendbf[] 
   \tyxtstxbf[]begin\tyxtstxendbf[]
      append (molecule\Symuns[]made\Symuns[]from(pair), to =\Symgt[] m\Symuns[]array(i));
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rads\Symuns[]for\Symuns[]bcps %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (apply\Symuns[]to\Symuns[]each =\Symgt[] make\Symuns[]and\Symuns[]append\Symuns[]bcp);
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]partitions\Symuns[]for\Symuns[]bcps %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] enum\Symuns[]partitions (array\Symuns[]type    =\Symgt[] array\Symuns[]of\Symuns[]naturals,
                           apply\Symuns[]to\Symuns[]each =\Symgt[] enum\Symuns[]rads\Symuns[]for\Symuns[]bcps);
\tyxtstxbf[]begin\tyxtstxendbf[]
   enum\Symuns[]partitions\Symuns[]for\Symuns[]bcps (sum\Symuns[]of\Symuns[]elements =\Symgt[] i,
                             nbr\Symuns[]of\Symuns[]elements =\Symgt[] 2,
                             min\Symuns[]element     =\Symgt[] i/2,
                             max\Symuns[]element     =\Symgt[] i/2);
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 Incidentally, the three procedures just discussed are so similar
in structure that they could all be obtained by generic instantiation,
with appropriate generic actual parameters, of one generic procedure.
Little would be gained, however, so we do not pursue that here.%
\Endpara[]
\Para[]The total number of executable statements we have shown is
still surprisingly small. The bulk of the executable statements in
our solution is to be found in the bodies of the generic procedures
\tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[] and %
\tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples\tyxffmxendmono[], which
are all the pieces of our solution that remain to be presented. The
body of \tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[], which
(as will be recalled) was designed as an application-independent library
unit, is shown in Figure \Xref[\def\XrefName{body-of-enum-partitions}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-enum-partitions}]Body of the %
\tyxffmxmono[]enum\Symuns[]partitions\tyxffmxendmono[] generic procedure%
\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] min\Symuns[]and\Symuns[]max;
\tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]partitions (sum\Symuns[]of\Symuns[]elements : %
\tyxtstxbf[]in\tyxtstxendbf[] natural;
                           nbr\Symuns[]of\Symuns[]elements : %
\tyxtstxbf[]in\tyxtstxendbf[] positive;
                           min\Symuns[]element     : %
\tyxtstxbf[]in\tyxtstxendbf[] natural;
                           max\Symuns[]element     : %
\tyxtstxbf[]in\tyxtstxendbf[] natural) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]package\tyxtstxendbf[] integer\Symuns[]min\Symuns[]and\Symuns[]max %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] min\Symuns[]and\Symuns[]max (integer);
   \tyxtstxbf[]use\tyxtstxendbf[]     integer\Symuns[]min\Symuns[]and\Symuns[]max;
   p : array\Symuns[]type (1 .. nbr\Symuns[]of\Symuns[]elements);
   \tyxtstxbf[]procedure\tyxtstxendbf[] recursively\Symuns[]partition (level        : %
\tyxtstxbf[]in\tyxtstxendbf[] positive;
                                    remainder    : \tyxtstxbf[]in%
\tyxtstxendbf[] natural;
                                    prev\Symuns[]element : %
\tyxtstxbf[]in\tyxtstxendbf[] natural) \tyxtstxbf[]is%
\tyxtstxendbf[]
      remaining\Symuns[]levels : \tyxtstxbf[]constant%
\tyxtstxendbf[] natural := nbr\Symuns[]of\Symuns[]elements - level;
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]if\tyxtstxendbf[] remaining\Symuns[]levels \Symgt[] 0 %
\tyxtstxbf[]then\tyxtstxendbf[]
         \tyxtstxbf[]for\tyxtstxendbf[] element \tyxtstxbf[]in%
\tyxtstxendbf[] max(remainder - max\Symuns[]element*remaining\Symuns[]levels,
                            prev\Symuns[]element) ..
                        min(remainder - min\Symuns[]element*remaining\Symuns[]levels,
                            remainder / (remaining\Symuns[]levels + 1)) %
\tyxtstxbf[]loop\tyxtstxendbf[]
            p(level) := element;
            recursively\Symuns[]partition (level + 1,
                                   remainder - element,
                                   element);
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]else\tyxtstxendbf[]
         p(level) := remainder;
         apply\Symuns[]to\Symuns[]each (p);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   recursively\Symuns[]partition (1, sum\Symuns[]of\Symuns[]elements, min\Symuns[]element);
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 The code in \tyxffmxmono[]enum\Symuns[]partitions%
\tyxffmxendmono[] is tricky, but not profound. An inner procedure,
\tyxffmxmono[]recursively\Symuns[]partition\tyxffmxendmono[], is called
to assign the first element of the partition; it calls itself recursively
to assign successive elements, until the last element is reached.
At each level of recursion, it computes\NtFoot[]\NtNtpar[]This computation
requires \tyxffmxmono[]min\tyxffmxendmono[] and \tyxffmxmono[]max%
\tyxffmxendmono[] functions, which are obtained by generic instantiation,
with the predefined type \tyxffmxmono[]integer\tyxffmxendmono[], of
the same application-independent generic library package, %
\tyxffmxmono[]min\Symuns[]and\Symuns[]max\tyxffmxendmono[], used in
the solution of Hamming\rsquo[]s problem. The type %
\tyxffmxmono[]integer\tyxffmxendmono[] is used as the generic actual
parameter, rather than a subtype thereof, like \tyxffmxmono[]positive%
\tyxffmxendmono[] or \tyxffmxmono[]natural\tyxffmxendmono[], because
the argument expressions in the present invocations of %
\tyxffmxmono[]min\tyxffmxendmono[] and \tyxffmxmono[]max%
\tyxffmxendmono[] can yield negative values.\NtEndntpar[]%
\NtEndfoot[] the range\EmDash[]possibly empty\EmDash[]of element values
acceptable at that level, and it loops\NtFoot[]\NtNtpar[]The loop
at each level of recursion contrasts with the statically nested loops
and lack of recursion found in some other solutions; it has the advantage
that it simulates an arbitrary level of nesting. Of course, this strategy
was motivated by the desire to write a single generic procedure that
could serve for the binary, ternary, and quaternary partitions needed
for the problem solution.\NtEndntpar[]\NtEndfoot[] through those values
(ascending to the next higher level for each in turn). At the highest
level, when a partition has been enumerated, it applies the operation
passed parametrically to the partition.\Endpara[]
\Para[]The proper body of the remaining generic procedure, %
\tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples\tyxffmxendmono[] (a
subunit of \tyxffmxmono[]paraffins\tyxffmxendmono[]), is shown in
Figure \Xref[\def\XrefName{body-of-enum-rad-tuples}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-enum-rad-tuples}]Proper body of the %
\tyxffmxmono[]enum\Symuns[]rad\Symuns[]tuples\tyxffmxendmono[] generic
procedure\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (paraffins)
\tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (p : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals) %
\tyxtstxbf[]is\tyxtstxendbf[]
   radical\Symuns[]tuple : array\Symuns[]of\Symuns[]radicals (1 .. p\rsquo[]length);
   \tyxtstxbf[]procedure\tyxtstxendbf[] recursively\Symuns[]enumerate (level        : %
\tyxtstxbf[]in\tyxtstxendbf[] positive;
                                    remainder    : \tyxtstxbf[]in%
\tyxtstxendbf[] radical\Symuns[]list;
                                    prev\Symuns[]element : %
\tyxtstxbf[]in\tyxtstxendbf[] natural) \tyxtstxbf[]is%
\tyxtstxendbf[]
      levels\Symuns[]radical\Symuns[]list : radical\Symuns[]list;
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]if\tyxtstxendbf[] p(level) = prev\Symuns[]element %
\tyxtstxbf[]then\tyxtstxendbf[]
         levels\Symuns[]radical\Symuns[]list := remainder;
      \tyxtstxbf[]else\tyxtstxendbf[]
         levels\Symuns[]radical\Symuns[]list := r\Symuns[]array(p(level));
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
      \tyxtstxbf[]while\tyxtstxendbf[] \tyxtstxbf[]not%
\tyxtstxendbf[] is\Symuns[]empty(levels\Symuns[]radical\Symuns[]list) %
\tyxtstxbf[]loop\tyxtstxendbf[]
         radical\Symuns[]tuple(level) := head(levels\Symuns[]radical\Symuns[]list);
         \tyxtstxbf[]if\tyxtstxendbf[] level \Symlt[] p\rsquo[]length %
\tyxtstxbf[]then\tyxtstxendbf[]
            recursively\Symuns[]enumerate (level + 1,
                                   levels\Symuns[]radical\Symuns[]list,
                                   p(level));
         \tyxtstxbf[]else\tyxtstxendbf[]
            apply\Symuns[]to\Symuns[]each (radical\Symuns[]tuple);
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
         levels\Symuns[]radical\Symuns[]list := tail(levels\Symuns[]radical\Symuns[]list);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   recursively\Symuns[]enumerate (1, r\Symuns[]array(p(1)), p(1));
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 It has a structure similar to \tyxffmxmono[]enum\Symuns[]partitions%
\tyxffmxendmono[]. An inner procedure, \tyxffmxmono[]recursively\Symuns[]enumerate%
\tyxffmxendmono[], is called to assign the first element of the radical
tuple; it calls itself recursively to assign successive elements,
until the last element is reached. At each level of recursion, it
determines the list of radicals available for assignments at that
level, and it loops through those values (ascending to the next higher
level for each in turn); that list is the entire list of radicals
of the size needed for the level, unless the level has the same size
as the previous level, in which case the list is \txtxemph[]the remaining
portion\txtxendemph[] of the list from the previous level, starting
from the radical that was assigned at the previous level.%
\NtFoot[]\NtNtpar[]This is a subtle consequence of the need to deliver
a tuple of lexicographically ordered radicals.\NtEndntpar[]%
\NtEndfoot[] At the highest level, when a tuple has been enumerated,
it applies the operation passed parametrically to the tuple.%
\Endpara[]
\Para[]Finally, it is worth emphasizing that the trees we construct
to represent radicals and molecules share components. Thus, the subradicals
of a radical do not occupy storage independently from their occurrences
as top-level radicals in their own right, or from other occurrences
of themselves as subradicals of a different radical. The creation
of a new radical does not require the copying of subradicals, nor
does the creation of a molecule require the copying of radicals; they
require only the allocation of a single new root node, which is initialized
with pointers to the appropriate subnodes. Each radical is, in general,
pointed to many times. Only one instance of the hydrogen radical is
created.\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Parallel Solution\HdMinEndiv[]
\Para[]There are many ways that one could introduce explicit parallelism,
if one desired, to gain speedup. The most obvious and straightforward
way is to perform all the iterations of the molecule-constructing
loop of \tyxffmxmono[]paraffins\tyxffmxendmono[] in parallel (say,
each by a separate task), since the list of paraffin molecules of
size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] is completely independent of the list for
any other size.\NtFoot[]\NtNtpar[]Admittedly, this strategy does not
have good load-balancing properties. One could get by with fewer tasks,
since one task could create several lists of molecules of small size
sequentially in the time that it takes another task to create a list
of molecules of large size.\NtEndntpar[]\NtEndfoot[] However, it is
not necessary to wait until all the radical lists are complete before
starting on the molecule lists. Since molecules of size %
\InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] involve radicals of sizes not larger than %
\InlEqn[]\LmthEqn[]
\left\lfloor {{{i-1} \over {2}}}
\right\rfloor 
\LmthEndeqn[]\EndInlEqn[], it is possible to start the generation of molecules
of size \InlEqn[]\LmthEqn[]2i
\LmthEndeqn[]\EndInlEqn[] (if \InlEqn[]\LmthEqn[]i>0
\LmthEndeqn[]\EndInlEqn[]) and those
of size \InlEqn[]\LmthEqn[]2i+1
\LmthEndeqn[]\EndInlEqn[] (if \InlEqn[]\LmthEqn[]2i<n
\LmthEndeqn[]\EndInlEqn[]) as soon as
the radicals of size \InlEqn[]\LmthEqn[]i
\LmthEndeqn[]\EndInlEqn[] are finished. A parallel
version of the \tyxffmxmono[]paraffins\tyxffmxendmono[] function capitalizing
on this observation is shown in Figure \Xref[\def\XrefName{body-of-paraffins-parallel}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-paraffins-parallel}]Self-specifying body
of the \tyxffmxmono[]paraffins\tyxffmxendmono[] function (parallel
version)\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] radicals, molecules;
\tyxtstxbf[]use\tyxtstxendbf[]  radicals, molecules;
\tyxtstxbf[]function\tyxtstxendbf[] paraffins (n : positive) %
\tyxtstxbf[]return\tyxtstxendbf[] array\Symuns[]of\Symuns[]molecule\Symuns[]lists %
\tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (positive %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] natural;
   \tyxtstxbf[]use\tyxtstxendbf[] radical\Symuns[]lists, molecule\Symuns[]lists;
   r\Symuns[]array : array\Symuns[]of\Symuns[]radical\Symuns[]lists  (0 .. n/2);
   m\Symuns[]array : array\Symuns[]of\Symuns[]molecule\Symuns[]lists (1 .. n);
   \tyxtstxbf[]generic\tyxtstxendbf[]
      \tyxtstxbf[]with\tyxtstxendbf[] \tyxtstxbf[]procedure%
\tyxtstxendbf[] apply\Symuns[]to\Symuns[]each (tuple : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]radicals);
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (p : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals);
   \tyxtstxbf[]task\tyxtstxendbf[] type worker\Symuns[]task %
\tyxtstxbf[]is\tyxtstxendbf[]
      \tyxtstxbf[]entry\tyxtstxendbf[] start\Symuns[]on\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive);
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] enum\Symuns[]rad\Symuns[]tuples (p : %
\tyxtstxbf[]in\tyxtstxendbf[] array\Symuns[]of\Symuns[]naturals)  %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]separate%
\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]radicals\Symuns[]of\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]ccps\Symuns[]of\Symuns[]size     (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]procedure\tyxtstxendbf[] generate\Symuns[]bcps\Symuns[]of\Symuns[]size     (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] worker\Symuns[]task                                 %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]separate%
\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]declare\tyxtstxendbf[]
      molecule\Symuns[]list\Symuns[]generator : \tyxtstxbf[]array%
\tyxtstxendbf[] (1 .. n) \tyxtstxbf[]of\tyxtstxendbf[] worker\Symuns[]task;
   \tyxtstxbf[]begin\tyxtstxendbf[]
      append (hydrogen\Symuns[]radical, to =\Symgt[] r\Symuns[]array(0));
      molecule\Symuns[]list\Symuns[]generator(1).start\Symuns[]on\Symuns[]size (1);
      \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n/2 \tyxtstxbf[]loop\tyxtstxendbf[]
         generate\Symuns[]radicals\Symuns[]of\Symuns[]size (i);
         molecule\Symuns[]list\Symuns[]generator(2*i).start\Symuns[]on\Symuns[]size (2*i);
         \tyxtstxbf[]if\tyxtstxendbf[] 2*i \Symlt[] n %
\tyxtstxbf[]then\tyxtstxendbf[]
            molecule\Symuns[]list\Symuns[]generator(2*i+1).start\Symuns[]on\Symuns[]size (2*i+1);
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]return\tyxtstxendbf[] m\Symuns[]array;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 The only additions to the declarative part of the function are the
specification and body stub of a task type, \tyxffmxmono[]worker\Symuns[]task%
\tyxffmxendmono[], whose proper body is shown in the next figure.
The block statement in the statement list of the function declares
an array, \tyxffmxmono[]molecule\Symuns[]list\Symuns[]generator%
\tyxffmxendmono[], of tasks of the type \tyxffmxmono[]worker\Symuns[]task%
\tyxffmxendmono[], all of which wait for a rendezvous with their %
\tyxffmxmono[]start\Symuns[]on\Symuns[]size\tyxffmxendmono[] entry
before proceeding. The block statement then sequentially creates the
radical lists and, as each is completed, signals one or two of the
tasks to start on their molecule lists; it does not wait at that point
for those tasks to complete. Each task continues without any further
interaction until it completes. The block statement waits at its end
until all of its dependent tasks have completed; then the return statement
is finally executed.\Endpara[]
\Para[]The proper body of the \tyxffmxmono[]worker\Symuns[]task%
\tyxffmxendmono[] task is shown in Figure \Xref[\def\XrefName{body-of-worker-task}].
After receiving its signal to proceed, during which it records the
size of the molecules
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-worker-task}]Proper body of the %
\tyxffmxmono[]worker\Symuns[]task\tyxffmxendmono[] task%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (paraffins)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] worker\Symuns[]task %
\tyxtstxbf[]is\tyxtstxendbf[]
   my\Symuns[]size : positive;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]accept\tyxtstxendbf[] start\Symuns[]on\Symuns[]size (i : %
\tyxtstxbf[]in\tyxtstxendbf[] positive) \tyxtstxbf[]do%
\tyxtstxendbf[]
      my\Symuns[]size := i;
   \tyxtstxbf[]end\tyxtstxendbf[];
   generate\Symuns[]ccps\Symuns[]of\Symuns[]size (my\Symuns[]size);
   \tyxtstxbf[]if\tyxtstxendbf[] my\Symuns[]size \tyxtstxbf[]mod%
\tyxtstxendbf[] 2 = 0 \tyxtstxbf[]then\tyxtstxendbf[]
      generate\Symuns[]bcps\Symuns[]of\Symuns[]size (my\Symuns[]size);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 on which it is to work, the task simply calls \tyxffmxmono[]generate\Symuns[]ccps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] to generate the CCPs of its size. Following that,
if its size is even, it calls \tyxffmxmono[]generate\Symuns[]bcps\Symuns[]of\Symuns[]size%
\tyxffmxendmono[] to generate the BCPs of that size. Of course, the
BCPs and CCPs of a given size are also independent of each other and
could be constructed in parallel. As it stands, our program is not
so amenable to that, but one can imagine simple changes that would
facilitate further enhancement.\Endpara[]
\Para[]Applicative languages have an obvious advantage over Ada\EmDash[]namely,
that opportunities for parallelism such as we have seized here (and
others on a more microscopic scale) are exploited implicitly and automatically
to the extent permitted by the dataflow properties of the problem
at hand.\Endpara[]
\DivEndiv[]
\DivEndiii[]
\DivLiii[]\HdMjLiii[]The Doctor\rsquo[]s Office Problem%
\HdMjEndiii[]
\Para[]Given a set of patients, a set of doctors, and a receptionist,
the problem is to model the following interactions. Initially, all
patients are well, and all doctors are in a queue waiting to treat
sick patients. At random times, patients become sick and enter a queue
for treatment by one of the doctors. The receptionist handles the
two queues, assigning patients to doctors in a FIFO manner. Once a
doctor and patient are paired, the doctor diagnoses the illness and,
in a randomly chosen period of time, cures the patient. Then, the
doctor and patient return to the receptionist\rsquo[]s desk, where
the receptionist records pertinent information. The patient is then
released until such time as he or she becomes sick again, and the
doctor returns to the queue to await another patient. Any distribution
functions may be used for the patients\rsquo[] healthy times and doctors\rsquo[]
cure times, but the code that models doctors must have no knowledge
of the distribution function for patients, and vice versa, and that
for the receptionist should know nothing of either.\Endpara[]
\Para[]The doctor\rsquo[]s office problem seems tailor-made for Ada;
in fact, the solution is so concise that it is greatly eclipsed by
our discussion of it. The solution employs a collection of tasks interacting
in ways that model the interactions of the patients, doctors, and
receptionist as defined in the problem statement; indeed, there is
a receptionist task and one task for each patient and each doctor.
No difficulties are encountered in constructing the model in Ada;
in particular, Ada allows the task modeling the receptionist to respond
directly to interactions initiated by either patient or doctor tasks,
with no regard to which occurs first. Some other languages have difficulty
responding asynchronously to signals from a union of dissimilar sources.%
\Endpara[]
\DivLiv[]\HdMinLiv[]Characteristics of Alternative Approaches%
\HdMinEndiv[]
\Para[]This problem can be solved in either of two distinctly different
ways. One can write a \ldquo[]real-time program,\rdquo[] in which
the periods of health and sickness are modeled by the suspension of
patient (or, in the latter case, both patient and doctor) tasks for
directly proportional periods of real time. Or, one can write a \ldquo[]discrete-event
simulation program,\rdquo[] in which the time to the next scheduled
\ldquo[]event\rdquo[] (such as the expiration of a healthy period)
is elided. In the former, the interacting tasks spend most of their
time waiting for the expiration of one delay or another; and since
they will all typically be doing so simultaneously, the program as
a whole runs very inefficiently. The latter approach is far more efficient,
since whenever all the tasks would otherwise be waiting for the expiration
of various delays, the clock is effectively reset instantaneously
to the time at which the next delay is due to expire. The program
as a whole is consequently never in the \ldquo[]wait state,\rdquo[]
and its total duration is dominated not by the lengths of the simulated
waits but rather by the number of simulated nonwaiting events and
the computational resources required to model each one of them.%
\Endpara[]
\Para[]Both approaches have in common the need to suspend individual
tasks for some period of time before they can proceed with their next
action. (In the real-time program, tasks are suspended for a predetermined
amount of time that is not influenced by what other tasks do during
the wait; in the discrete-event simulation, tasks are suspended for
an amount of time not known in advance, the suspension ending at a
moment determined by what all the tasks do until then). Thus, as far
as the logical behavior of each task is concerned, there is very little
difference between the two approaches: tasks interact with each other
and occasionally become suspended until awakened by the expiration
of a delay or by a rendezvous. Since the interactions and suspensions
to be modeled are adequately and equally demonstrated by either approach,
we have chosen the simpler (albeit less efficient) approach involving
a real-time program. The discrete-event simulation would have the
added complexity of an ordered-time-queue manager, which is neither
germane to the problem nor instrumental in determining the interactions
among the other tasks. The real-time program can be changed to a discrete-event
simulation merely by making systematic, local changes at all the places
where a delay statement is found and adding an ordered-time-queue
manager component; the details are omitted for lack of space.%
\Endpara[]
\Para[]The problem statement does not say anything about when or how
the modeling of the doctor\rsquo[]s office is to end; presumably,
such details only complicate the essential behavior to be demonstrated.
In that spirit, we have simplified our solution by ignoring termination
questions; the modeled interactions continue forever. Termination
can, of course, be designed in, after one defines appropriate termination
criteria; depending on the criteria adopted, achieving termination
might require additional communication among some of the tasks.%
\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Structure of the Solution\HdMinEndiv[]
\Para[]The solution presented here is in the form of a generic procedure
called \tyxffmxmono[]doctors\Symuns[]office\tyxffmxendmono[]. The
generic procedure is parameterized by two function subprograms, which
are random-number generators for selecting the random periods of health
enjoyed by each patient and the intervening random periods of diagnosis
and cure (once the patient has been assigned a doctor). The specification
for the generic procedure is shown in Figure \Xref[\def\XrefName{spec-of-doctors-office}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-doctors-office}]Specification of the %
\tyxffmxmono[]doctors\Symuns[]office\tyxffmxendmono[] generic procedure%
\FgEndcap[]
\Comp[]\tyxtstxbf[]generic\tyxtstxendbf[]
   \tyxtstxbf[]with\tyxtstxendbf[] \tyxtstxbf[]function%
\tyxtstxendbf[] random\Symuns[]healthy\Symuns[]period   %
\tyxtstxbf[]return\tyxtstxendbf[] duration;
   \tyxtstxbf[]with\tyxtstxendbf[] \tyxtstxbf[]function%
\tyxtstxendbf[] random\Symuns[]treatment\Symuns[]period %
\tyxtstxbf[]return\tyxtstxendbf[] duration;
\tyxtstxbf[]procedure\tyxtstxendbf[] doctors\Symuns[]office (number\Symuns[]of\Symuns[]patients : %
\tyxtstxbf[]in\tyxtstxendbf[] natural;
                          number\Symuns[]of\Symuns[]doctors  : %
\tyxtstxbf[]in\tyxtstxendbf[] natural);\Endcomp[]
\EndParbox[]
\FgEndblock[]
 To use this machinery, one instantiates the generic procedure, supplying
the names of the two random-number generators, to get a (nongeneric)
procedure, which one then calls with two actual parameters representing
the number of patients and number of doctors.\Endpara[]
\Para[]In the solution, we use the predefined fixed-point type %
\tyxffmxmono[]duration\tyxffmxendmono[] for the result of the random-number
generators, since that is the type required for the operand of a delay
statement, where the result is used. We use the predefined subtype
\tyxffmxmono[]natural\tyxffmxendmono[] of the predefined type %
\tyxffmxmono[]integer\tyxffmxendmono[] for the number of patients
and number of doctors. The body of the generic procedure is shown
in Figure \Xref[\def\XrefName{body-of-doctors-office}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-doctors-office}]Body of the %
\tyxffmxmono[]doctors\Symuns[]office\tyxffmxendmono[] generic procedure%
\FgEndcap[]
\Comp[]\tyxtstxbf[]procedure\tyxtstxendbf[] doctors\Symuns[]office (number\Symuns[]of\Symuns[]patients : %
\tyxtstxbf[]in\tyxtstxendbf[] natural;
                          number\Symuns[]of\Symuns[]doctors  : %
\tyxtstxbf[]in\tyxtstxendbf[] natural) \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]type%
\tyxtstxendbf[] patient\Symuns[]task;
   \tyxtstxbf[]type\tyxtstxendbf[] doctor\Symuns[]task;
   \tyxtstxbf[]type\tyxtstxendbf[] doctor \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]access\tyxtstxendbf[] doctor\Symuns[]task;
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]type%
\tyxtstxendbf[] doctor\Symuns[]task \tyxtstxbf[]is%
\tyxtstxendbf[]
      \tyxtstxbf[]entry\tyxtstxendbf[] identify\Symuns[]self (myself : %
\tyxtstxbf[]in\tyxtstxendbf[] doctor);
      \tyxtstxbf[]entry\tyxtstxendbf[] patient\Symuns[]visiting\Symuns[]for\Symuns[]treatment;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]task\tyxtstxendbf[] receptionist \tyxtstxbf[]is%
\tyxtstxendbf[]
      \tyxtstxbf[]entry\tyxtstxendbf[] patient\Symuns[]becoming\Symuns[]sick;
      \tyxtstxbf[]entry\tyxtstxendbf[] doctor\Symuns[]requesting\Symuns[]patient (d1 : %
\tyxtstxbf[]in\tyxtstxendbf[]  doctor);
      \tyxtstxbf[]entry\tyxtstxendbf[] patient\Symuns[]requesting\Symuns[]doctor (d2 : %
\tyxtstxbf[]out\tyxtstxendbf[] doctor);
   \tyxtstxbf[]end\tyxtstxendbf[];
   patient    : \tyxtstxbf[]array\tyxtstxendbf[] (1 .. number\Symuns[]of\Symuns[]patients) %
\tyxtstxbf[]of\tyxtstxendbf[] patient\Symuns[]task;
   new\Symuns[]doctor : doctor;
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] patient\Symuns[]task \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] doctor\Symuns[]task  \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]separate\tyxtstxendbf[];
   \tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] receptionist \tyxtstxbf[]is\tyxtstxendbf[] %
\tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. number\Symuns[]of\Symuns[]doctors %
\tyxtstxbf[]loop\tyxtstxendbf[]
      new\Symuns[]doctor := \tyxtstxbf[]new\tyxtstxendbf[] doctor\Symuns[]task;
      new\Symuns[]doctor.identify\Symuns[]self (new\Symuns[]doctor);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 Places for the bodies of the task types \tyxffmxmono[]patient\Symuns[]task%
\tyxffmxendmono[] and \tyxffmxmono[]doctor\Symuns[]task%
\tyxffmxendmono[] and for the single task \tyxffmxmono[]receptionist%
\tyxffmxendmono[] are held by body stubs, whose corresponding proper
bodies are shown later.\Endpara[]
\Para[]Note that the collection of patients is managed differently
from the collection of doctors. In our solution, patients perform
entry calls\NtFoot[]\NtNtpar[]For convenience throughout the remainder
of this section, we refer to objects of type \tyxffmxmono[]patient\Symuns[]task%
\tyxffmxendmono[] as \ldquo[]patients,\rdquo[] objects of type %
\tyxffmxmono[]doctor\Symuns[]task\tyxffmxendmono[] as \ldquo[]doctors,\rdquo[]
and the single \tyxffmxmono[]receptionist\tyxffmxendmono[] task as
\ldquo[]the receptionist\rdquo[] when discussing the behavior of our
program units. We occasionally use the same words to refer to the
people that they model, as when we discuss the problem statement.%
\NtEndntpar[]\NtEndfoot[] but have no need to accept them; since no
task calls an entry of a patient, the identity of any individual patient
is never needed. The easiest and most straightforward way of allocating
the required number of patients is to declare an array of %
\tyxffmxmono[]patient\Symuns[]task\tyxffmxendmono[]s having the appropriate
bounds; subscripted components of this array are never referenced.
Doctors, on the other hand, both perform and accept entry calls, so
there \txtxemph[]is\txtxendemph[] a need to identify individual doctors.
We choose to identify them by allocating each one individually, obtaining
a pointer to the newly allocated \tyxffmxmono[]doctor\Symuns[]task%
\tyxffmxendmono[] and then passing that pointer value to the task
itself (via its \tyxffmxmono[]identify\Symuns[]self%
\tyxffmxendmono[] entry), which saves it in a task-local variable;
no collective record of all the doctors is retained outside of them,
because none is needed. A doctor passes its own identity to the receptionist
when it becomes free and requests a patient to treat. The receptionist
accepts such a call from a doctor only when some patient is sick,
at which time it passes the doctor\rsquo[]s identity on to the patient,
who then interacts with the doctor to receive treatment.%
\Endpara[]
\Para[]After the allocation and initialization of all the doctors,
all the subsequent action occurs inside the dependent tasks of %
\tyxffmxmono[]doctors\Symuns[]office\tyxffmxendmono[]; consequently,
before returning to its caller, \tyxffmxmono[]doctors\Symuns[]office%
\tyxffmxendmono[] waits (at its end) for all its dependent tasks to
terminate. Since they never do, in this implementation, %
\tyxffmxmono[]doctors\Symuns[]office\tyxffmxendmono[] never returns.%
\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Behavior of Patients\HdMinEndiv[]
\Para[]The code implementing the behavior of patients is shown in
Figure \Xref[\def\XrefName{body-of-patient}]. A patient\rsquo[]s behavior
is very simple. Repetitively, a patient enjoys a random period of
health,
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-patient}]Proper body of the %
\tyxffmxmono[]patient\Symuns[]task\tyxffmxendmono[] task type%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (doctors\Symuns[]office)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] patient\Symuns[]task %
\tyxtstxbf[]is\tyxtstxendbf[]
   assigned\Symuns[]doctor : doctor;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]loop\tyxtstxendbf[]
      \tyxtstxbf[]delay\tyxtstxendbf[] random\Symuns[]healthy\Symuns[]period;
      receptionist.patient\Symuns[]becoming\Symuns[]sick;
      receptionist.patient\Symuns[]requesting\Symuns[]doctor (assigned\Symuns[]doctor);
      assigned\Symuns[]doctor.patient\Symuns[]visiting\Symuns[]for\Symuns[]treatment;
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 checks in with the receptionist (announcing sickness), requests from
the receptionist the services of a doctor, is assigned a doctor when
one becomes available, and visits the doctor to receive treatment.
The problem statement says that, after the cure, the patient and the
doctor are to return to the receptionist; the patient does not do
so here, simply because there is no relevant action (affecting doctors
or patients) that the receptionist needs to take on behalf of the
patient at that point. Depending on the record keeping expected of
the receptionist, additional interactions with it might be desirable.%
\Endpara[]
\Para[]As we will see upon examining the detailed behavior of the
receptionist, the call that a patient makes to inform the receptionist
of sickness does not cause an indefinite suspension of the patient;
it might cause a very brief suspension (i.e., if the receptionist
is currently occupied), akin to the wait for a monitor lock. The point
to note is that the receptionist is designed so that, each time through
its loop, it is receptive to a call from a patient to its %
\tyxffmxmono[]patient\Symuns[]becoming\Symuns[]sick%
\tyxffmxendmono[] entry. On the other hand, a patient might very well
become suspended when it immediately thereafter calls the receptionist
at the latter\rsquo[]s \tyxffmxmono[]patient\Symuns[]requesting\Symuns[]doctor%
\tyxffmxendmono[] entry, since the receptionist might not be in a
state in which it is executing (or can execute) its accept statement
for that entry. The availability of a doctor is a prerequisite to
the execution of that accept statement. Eventually a doctor will become
available to treat the patient (patients remain suspended not just
until a doctor becomes available, but also until all prior requests
by patients for doctors have been satisfied), at which time the patient\rsquo[]s
entry call to \tyxffmxmono[]patient\Symuns[]requesting\Symuns[]doctor%
\tyxffmxendmono[] will result in a rendezvous with the receptionist,
who will pass to the patient the identity of the available doctor.
After concluding its \tyxffmxmono[]patient\Symuns[]requesting\Symuns[]doctor%
\tyxffmxendmono[] rendezvous with the receptionist, the patient will
straightaway call the assigned doctor at the latter\rsquo[]s %
\tyxffmxmono[]patient\Symuns[]visiting\Symuns[]for\Symuns[]treatment%
\tyxffmxendmono[] entry, remaining suspended in a rendezvous until
the cure has been effected.\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Behavior of Doctors\HdMinEndiv[]
\Para[]The code implementing the behavior of doctors is shown in Figure
\Xref[\def\XrefName{body-of-doctor}]. The repetitive behavior of a
doctor, after receiving and storing its own identity,
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-doctor}]Proper body of the %
\tyxffmxmono[]doctor\Symuns[]task\tyxffmxendmono[] task type%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (doctors\Symuns[]office)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] doctor\Symuns[]task %
\tyxtstxbf[]is\tyxtstxendbf[]
   self : doctor;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]accept\tyxtstxendbf[] identify\Symuns[]self (myself : %
\tyxtstxbf[]in\tyxtstxendbf[] doctor) \tyxtstxbf[]do%
\tyxtstxendbf[]
      self := myself;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]loop\tyxtstxendbf[]
      receptionist.doctor\Symuns[]requesting\Symuns[]patient (self);
      \tyxtstxbf[]accept\tyxtstxendbf[] patient\Symuns[]visiting\Symuns[]for\Symuns[]treatment %
\tyxtstxbf[]do\tyxtstxendbf[]
         \tyxtstxbf[]delay\tyxtstxendbf[] random\Symuns[]treatment\Symuns[]period;
      \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 is to announce to the receptionist its availability to treat patients,
then (once a patient has come to it for treatment) to render service
in the form of a treatment that takes a random period of time. The
problem statement says that a doctor (as well as its patient) returns
to the receptionist at the conclusion of treatment; the doctor\rsquo[]s
return to the receptionist, at least, is adequately modeled by our
solution, because after treating a patient the doctor\rsquo[]s next
action is to inform the receptionist immediately that it is again
available to treat patients. An additional interaction with the receptionist
could be programmed (at the bottom of the loop) to signal, for record-keeping
purposes, the doctor\rsquo[]s conclusion of treatment, but there is
no relevant action (affecting doctors or patients) that the receptionist
needs to take on behalf of the doctor at that point.\Endpara[]
\Para[]As we will see upon examining the detailed behavior of the
receptionist, a doctor might very well become suspended when it calls
the receptionist to request a patient, since the receptionist is not
always receptive to such calls; that happens when no patient is sick
and is an essential part of the behavior to be modeled. Eventually
a patient becomes sick (the doctor remains suspended not just until
a patient becomes sick, but also until all prior requests for patients
by doctors have been satisfied), at which time the doctor\rsquo[]s
entry call to \tyxffmxmono[]doctor\Symuns[]requesting\Symuns[]patient%
\tyxffmxendmono[] will result in a rendezvous with the receptionist,
who will receive the identity of the doctor. The receptionist passes
that identity to the patient with whom the doctor is being paired,
and the patient calls the doctor so identified (at the doctor\rsquo[]s
\tyxffmxmono[]patient\Symuns[]visiting\Symuns[]for\Symuns[]treatment%
\tyxffmxendmono[] entry). Thus, after completing its rendezvous with
the receptionist, the doctor will treat a patient without further
delay. Finally, note that the delay statement that causes the doctor\rsquo[]s
suspension for the duration of the treatment keeps the patient suspended
for the same time, since that delay statement is executed as part
of the rendezvous between patient and doctor.\Endpara[]
\DivEndiv[]
\DivLiv[]\HdMinLiv[]Behavior of the Receptionist\HdMinEndiv[]
\Para[]The code implementing the behavior of the receptionist is shown
in Figure \Xref[\def\XrefName{body-of-receptionist}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-receptionist}]Proper body of the %
\tyxffmxmono[]receptionist\tyxffmxendmono[] task\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (doctors\Symuns[]office)
\tyxtstxbf[]task\tyxtstxendbf[] \tyxtstxbf[]body\tyxtstxendbf[] receptionist %
\tyxtstxbf[]is\tyxtstxendbf[]
   sick\Symuns[]patients : natural := 0;
\tyxtstxbf[]begin\tyxtstxendbf[]
   \tyxtstxbf[]loop\tyxtstxendbf[]
      \tyxtstxbf[]select\tyxtstxendbf[]
         \tyxtstxbf[]accept\tyxtstxendbf[] patient\Symuns[]becoming\Symuns[]sick;
         sick\Symuns[]patients := sick\Symuns[]patients + 1;
      \tyxtstxbf[]or\tyxtstxendbf[]
      \tyxtstxbf[]when\tyxtstxendbf[] sick\Symuns[]patients \Symgt[] 0 =\Symgt[]
         \tyxtstxbf[]accept\tyxtstxendbf[] doctor\Symuns[]requesting\Symuns[]patient (d1 : %
\tyxtstxbf[]in\tyxtstxendbf[] doctor) \tyxtstxbf[]do%
\tyxtstxendbf[]
            \tyxtstxbf[]accept\tyxtstxendbf[] patient\Symuns[]requesting\Symuns[]doctor (d2 : %
\tyxtstxbf[]out\tyxtstxendbf[] doctor) \tyxtstxbf[]do%
\tyxtstxendbf[]
               d2 := d1;
            \tyxtstxbf[]end\tyxtstxendbf[];
         \tyxtstxbf[]end\tyxtstxendbf[];
         sick\Symuns[]patients := sick\Symuns[]patients - 1;
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]select%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 The behavior of the receptionist is subtle, but straightforward.
Repetitively, the receptionist just waits for, and then acts on, either
a notification that a patient has become sick or a request by a free
doctor for a patient to treat. The receptionist processes one patient\rsquo[]s
notification or doctor\rsquo[]s request each time through its loop,
waiting if necessary for one to arrive. It is always receptive to
the notification, but it is receptive to the request only when certain
conditions are satisfied. Specifically, it will accept the request
by a doctor for a patient to treat only if a patient is available
to satisfy the request (i.e., only if a patient is sick). If, on some
iteration of the loop, no patients are awaiting treatment, then the
receptionist will remain suspended until being notified of the arrival
of a sick patient, even if there is an outstanding request by a doctor
for a patient to treat.\Endpara[]
\Para[]The wait for either of two entry calls is achieved by coding
a selective wait inside a loop. The second of the selective wait\rsquo[]s
two accept alternatives is, furthermore, guarded so that, on some
iterations of the loop (in particular, those in which the guard is
false), a call to the guarded entry will not be accepted and will
remain queued. When the guard is true (that is, when the second selective
wait alternative is \ldquo[]open\rdquo[]), and calls to both of the
entries have been made, then either entry call may be accepted; the
one not accepted will remain pending and will be accepted on a subsequent
execution of the selective
\TyPbrkNewp[]
 wait (i.e., on a subsequent iteration of the loop). The logical behavior
and the correctness of the program are insensitive to the nondeterminism
of the choice, which gives one confidence that precisely the right
language feature is being employed here.\Endpara[]
\Para[]It should be noted that only two selective wait alternatives,
representing two communication channels, are needed in the selective
wait, rather than one for each doctor and each patient. The receptionist
handles its interactions with all the doctors identically, and likewise
its interactions with all the patients. The two selective wait alternatives
are used to discriminate between two reasons why other tasks might
interact with the receptionist, rather than to identify the interacting
tasks. When the identity of a doctor is needed, that identity is passed
as data by the doctor, during its interaction.\Endpara[]
\Para[]If multiple patients are sick and are requesting doctors, their
entry calls remain queued in FIFO order by Ada, and one call is taken
out of the queue for the \tyxffmxmono[]patient\Symuns[]requesting\Symuns[]doctor%
\tyxffmxendmono[] entry each time the accept statement for that entry
is executed. Thus, patients are treated in the order in which they
requested doctors, as required by the problem statement. By the same
token, if multiple doctors are trying to request patients from the
receptionist, \txtxemph[]their\txtxendemph[] entry calls remain queued
in FIFO order by Ada, and one call is taken out of the queue for the
\tyxffmxmono[]doctor\Symuns[]requesting\Symuns[]patient%
\tyxffmxendmono[] entry each time the accept statement for that entry
is executed. The problem statement does not specify which of several
available doctors should treat a patient, so our FIFO assignment of
available doctors is only one of many that would have sufficed; this
assignment is the easiest to provide, since it comes for free. Note
that all the queuing required by this problem is performed implicitly
by Ada, and no explicit maintenance of any queues is required.%
\NtFoot[]\NtNtpar[]The solution demonstrated during the conference
in 1988 was far less elegant; it \txtxemph[]did\txtxendemph[] involve
explicit queuing.\NtEndntpar[]\NtEndfoot[]\Endpara[]
\Para[]When the receptionist accepts an entry call from a doctor requesting
a patient, which it does only when a patient is known to be sick,
and while it is still engaged in a rendezvous with the doctor, it
also accepts an entry call from a patient requesting a doctor (and
performs a rendezvous with it). The receptionist thus acts as the
intermediary through which information\EmDash[]an available doctor\rsquo[]s
identity\EmDash[]is passed from doctor to patient. Note that, if the
receptionist were to accept an entry call from an available doctor
without knowing that a patient is sick (as would happen, for example,
if the second selective wait alternative were unguarded), then the
receptionist could become suspended at the accept statement for %
\tyxffmxmono[]patient\Symuns[]requesting\Symuns[]doctor%
\tyxffmxendmono[], and would indeed do so, if no patient were sick
(i.e., no \tyxffmxmono[]patient\Symuns[]task\tyxffmxendmono[] were
calling that entry). While that would have the desired effect of causing
a doctor requesting a patient to become suspended when no patient
were sick, the request could never be satisfied, because the receptionist
would be unable to take note of a patient\rsquo[]s becoming sick.
In fact, the program would deadlock. The use of a guard on the second
selective wait alternative avoids this while still causing a doctor
requesting a patient to become suspended when no patient is sick.%
\Endpara[]
\Para[]In summary, the \tyxffmxmono[]receptionist%
\tyxffmxendmono[] task is characterized by a loop containing a selective
wait, allowing the task repeatedly to wait for, and then respond to,
any of several alternative events. Guards are used to make it unreceptive
to the occurrence of some of those events at times, while remaining
receptive to the occurrence of others; the latter, in fact, determine
its receptivity to the former. This is a common and important tasking
paradigm in Ada. It is worth noting also the use of nested accept
statements in the \tyxffmxmono[]receptionist\tyxffmxendmono[] task,
which illustrates the power that can be achieved through appropriate
coupling of tasking constructs (rather than trying to record temporal
\ldquo[]state\rdquo[] in data).\Endpara[]
\Para[]It can be argued that the solution shown here gives patients,
doctors, and the receptionist too much visibility to things they don\rsquo[]t
need. We hasten to point out inspection reveals that no use is made
of unnecessary visibility. Nevertheless, one can indeed structure
the solution differently, so that each task sees \txtxemph[]only%
\txtxendemph[] what it needs to know. Such a solution would make additional
use of library packages and generic library packages to encapsulate
the behavior of the tasks, with limited visibility provided by disciplined
use of context clauses and by importation into the generic library
packages. The interactions of the tasks, which is really the essence
of this problem, would remain unchanged.\Endpara[]
\DivEndiv[]
\DivEndiii[]
\DivLiii[\def\DivLiiiId{skyline}]\HdMjLiii[]The Skyline Matrix Problem%
\HdMjEndiii[]
\Para[]The problem is to solve the matrix equation \InlEqn[]\LmthEqn[]Ax=b
\LmthEndeqn[]%
\EndInlEqn[], where \InlEqn[]\LmthEqn[]A
\LmthEndeqn[]\EndInlEqn[] is a skyline matrix of order
\InlEqn[]\LmthEqn[]n
\LmthEndeqn[]\EndInlEqn[] and \InlEqn[]\LmthEqn[]x
\LmthEndeqn[]\EndInlEqn[] and \InlEqn[]\LmthEqn[]b
\LmthEndeqn[]%
\EndInlEqn[] are vectors of order \InlEqn[]\LmthEqn[]n
\LmthEndeqn[]\EndInlEqn[]. Skyline matrices
are square matrices having varying numbers of leading zeros in their
subdiagonal rows and supradiagonal columns, and interest in such matrices
centers on the economies that can accrue from treating them as a kind
of sparse matrix and not storing the leading zeros. Their special
structure suggests the use of \ldquo[]ragged arrays\rdquo[]\EmDash[]two-dimensional
arrays (matrices) whose rows or columns do not all have the same bounds.
The main purpose of the problem is to test whether the language has
ragged arrays or, at least, primitive features that can be used to
define and implement them. A secondary purpose of the problem is to
see whether the language permits references to dimension-reducing
cross sections of multidimensional arrays, such as (partial) rows
or columns of matrices, and whether it permits operations on whole
arrays.\Endpara[]
\Para[]We solve this problem using Doolittle\rsquo[]s method of LU
decomposition \Cit[\def\CitId{Fox:Doolittle}]\Endcit[] (a variation
of Crout\rsquo[]s method in which L, rather than U, is unit triangular).
In Section \Xref[\def\XrefName{crout-standard}] we present a solution
for ordinary matrices (not having the skyline property). That solution
reveals that Ada does not have a built-in capability for referencing
cross sections (not to be confused with what Ada calls \ldquo[]slices,\rdquo[]
which do not reduce dimensionality). However, since Ada has array-valued
functions, one can define appropriate cross-section abstractions,
at least to the extent that they are required for this problem.%
\NtFoot[]\NtNtpar[]There is no getting around the inability to define
an array with nonunity stride, so the closest one can come to providing
cross sections is to define a function that returns a (partial) row
or column of a matrix by \txtxemph[]copying\txtxendemph[] its components
into a unity-stride vector. Fortunately, that suffices here.%
\NtEndntpar[]\NtEndfoot[] Ada also does not have component-wise arithmetic
operations on arrays, but such operations do not figure in the solution
anyway. We use Ada\rsquo[]s ability to overload operators to define
an inner-product operation denoted by the usual infix operator for
multiplication. Then, in Section \Xref[\def\XrefName{crout-skyline}],
we replace the type definitions for ordinary matrices by others for
skyline matrices, and we refine the accompanying code to take account
of the special structure of the matrices without obscuring the code\rsquo[]s
underlying ties to Doolittle\rsquo[]s method.\Endpara[]
\DivLiv[\def\DivLivId{crout-standard}]\HdMinLiv[]Solution for Ordinary
Matrices\HdMinEndiv[]
\Para[]We present in Figure \Xref[\def\XrefName{spec-of-matrices}]
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-matrices}]Specification of the %
\tyxffmxmono[]matrices\tyxffmxendmono[] generic package%
\FgEndcap[]
\Comp[]\tyxtstxbf[]generic\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] float\Symuns[]type %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]digits\tyxtstxendbf[] \Symlt[]\Symgt[];
   n : \tyxtstxbf[]in\tyxtstxendbf[] positive;
\tyxtstxbf[]package\tyxtstxendbf[] matrices \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[]    vector     \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (positive %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] float\Symuns[]type;
   \tyxtstxbf[]subtype\tyxtstxendbf[] n\Symuns[]vector   %
\tyxtstxbf[]is\tyxtstxendbf[] vector (1 .. n);
   \tyxtstxbf[]type\tyxtstxendbf[]    nxn\Symuns[]matrix %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (1 .. n, 1 .. n) %
\tyxtstxbf[]of\tyxtstxendbf[] float\Symuns[]type;
   \tyxtstxbf[]function\tyxtstxendbf[] row (row\Symuns[]index : positive;
                 of\Symuns[]matrix : nxn\Symuns[]matrix;
                 from      : positive;
                 to        : natural) \tyxtstxbf[]return%
\tyxtstxendbf[] vector;
   \tyxtstxbf[]function\tyxtstxendbf[] col (col\Symuns[]index : positive;
                 of\Symuns[]matrix : nxn\Symuns[]matrix;
                 from      : positive;
                 to        : natural) \tyxtstxbf[]return%
\tyxtstxendbf[] vector;
   \tyxtstxbf[]function\tyxtstxendbf[] \quot[]*\quot[] (left, right : vector) %
\tyxtstxbf[]return\tyxtstxendbf[] float\Symuns[]type;
   \tyxtstxbf[]function\tyxtstxendbf[] solve (a : nxn\Symuns[]matrix; b : n\Symuns[]vector) %
\tyxtstxbf[]return\tyxtstxendbf[] n\Symuns[]vector;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 the specification of a generic package called \tyxffmxmono[]matrices%
\tyxffmxendmono[] that imports a floating-point type and a positive
number \tyxffmxmono[]n\tyxffmxendmono[] and exports types and subprograms
for vectors and matrices of order \tyxffmxmono[]n%
\tyxffmxendmono[] (called \tyxffmxmono[]n\Symuns[]vector%
\tyxffmxendmono[] and \tyxffmxmono[]nxn\Symuns[]matrix%
\tyxffmxendmono[], respectively) whose components are of the given
floating-point type. The exported function \tyxffmxmono[]solve%
\tyxffmxendmono[] solves the matrix problem. Different instantiations
of this generic package are required to obtain matrices of different
sizes. The need for multiple instantiations could have been avoided
by defining only unconstrained types for two-dimensional arrays, requiring
the user to supply appropriate bounds in object declarations. By providing
constrained types or subtypes for these arrays, we simplify the code
by eliminating the need to check for matching bounds. We do provide
an unconstrained type (named \tyxffmxmono[]vector%
\tyxffmxendmono[]) for one-dimensional arrays to use as the result
type of the \tyxffmxmono[]row\tyxffmxendmono[] and %
\tyxffmxmono[]col\tyxffmxendmono[] functions, which return partial
rows and columns, respectively, and as the operand type of the %
\tyxffmxmono[]*\tyxffmxendmono[] (inner-product) operator, which accepts
partial rows and columns as operands. We do not use private types
because we want the user to be able to exploit the fact that %
\tyxffmxmono[]nxn\Symuns[]matrix\tyxffmxendmono[] is a two-dimensional
array\EmDash[]for example, by using the normal subscript notation
for references to a component of such an object. Also, were the auxiliary
\tyxffmxmono[]row\tyxffmxendmono[] and \tyxffmxmono[]col%
\tyxffmxendmono[] functions and the \tyxffmxmono[]*%
\tyxffmxendmono[] operator meant to be used only by the %
\tyxffmxmono[]solve\tyxffmxendmono[] function, they could have been
defined in the body of \tyxffmxmono[]matrices\tyxffmxendmono[]; we
define them, however, in its specification because they are likely
to be of use elsewhere in the user\rsquo[]s application.%
\Endpara[]
\Para[]The body of \tyxffmxmono[]matrices\tyxffmxendmono[] is shown
in Figure \Xref[\def\XrefName{body-of-matrices}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-matrices}]Body of the \tyxffmxmono[]matrices%
\tyxffmxendmono[] generic package\FgEndcap[]
\Comp[]\tyxtstxbf[]package\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] matrices \tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]function\tyxtstxendbf[] row (row\Symuns[]index : positive;
                 of\Symuns[]matrix : nxn\Symuns[]matrix;
                 from      : positive;
                 to        : natural) \tyxtstxbf[]return%
\tyxtstxendbf[] vector \tyxtstxbf[]is\tyxtstxendbf[]
      result : vector (from .. to);
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] from .. to \tyxtstxbf[]loop\tyxtstxendbf[]
         result(i) := of\Symuns[]matrix(row\Symuns[]index,i);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]return\tyxtstxendbf[] result;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] col (col\Symuns[]index : positive;
                 of\Symuns[]matrix : nxn\Symuns[]matrix;
                 from      : positive;
                 to        : natural) \tyxtstxbf[]return%
\tyxtstxendbf[] vector \tyxtstxbf[]is\tyxtstxendbf[]
      result : vector (from .. to);
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] from .. to \tyxtstxbf[]loop\tyxtstxendbf[]
         result(i) := of\Symuns[]matrix(i,col\Symuns[]index);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]return\tyxtstxendbf[] result;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] \quot[]*\quot[] (left, right : vector) %
\tyxtstxbf[]return\tyxtstxendbf[] float\Symuns[]type %
\tyxtstxbf[]is\tyxtstxendbf[]
      sum : float\Symuns[]type := 0.0;
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] left\rsquo[]range \tyxtstxbf[]loop%
\tyxtstxendbf[]
         sum := sum + left(i) * right(i);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]return\tyxtstxendbf[] sum;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] solve (a : nxn\Symuns[]matrix;
                   b : n\Symuns[]vector) \tyxtstxbf[]return%
\tyxtstxendbf[] n\Symuns[]vector \tyxtstxbf[]is\tyxtstxendbf[] %
\tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 The full bodies of the auxiliary functions are included, but that
of \tyxffmxmono[]solve\tyxffmxendmono[], which is somewhat larger,
is here represented merely by a body stub, and its proper body is
presented in the next figure. The
\TyPbrkNewp[]
 \tyxffmxmono[]row\tyxffmxendmono[] and \tyxffmxmono[]col%
\tyxffmxendmono[] functions have been designed to return a partial
row or column, extending from position \tyxffmxmono[]from%
\tyxffmxendmono[] to position \tyxffmxmono[]to\tyxffmxendmono[]. (Note
that \txtxemph[]null arrays\txtxendemph[]\EmDash[]arrays having no
components\EmDash[]are allowed in Ada; \tyxffmxmono[]row%
\tyxffmxendmono[] and \tyxffmxmono[]col\tyxffmxendmono[] return null
vectors when \tyxffmxmono[]to\tyxffmxendmono[] \mthxsyxlt[] %
\tyxffmxmono[]from\tyxffmxendmono[], as it does at several places
in our realization of Doolittle\rsquo[]s method.) In the function
implementing the \tyxffmxmono[]*\tyxffmxendmono[] (inner-product)
operator for vectors, it is implicitly assumed, for simplicity of
presentation, that the index ranges of the two operands, %
\tyxffmxmono[]left\tyxffmxendmono[] and \tyxffmxmono[]right%
\tyxffmxendmono[], are identical. The inner product of two null vectors
is defined to be zero.\Endpara[]
\Para[]The heart of Doolittle\rsquo[]s method is, of course, localized
in the \tyxffmxmono[]solve\tyxffmxendmono[] function, whose proper
body is shown in Figure \Xref[\def\XrefName{body-of-solve-normal}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{body-of-solve-normal}]Proper body of the %
\tyxffmxmono[]solve\tyxffmxendmono[] function, for normal matrices%
\FgEndcap[]
\Comp[]\tyxtstxbf[]separate\tyxtstxendbf[] (matrices)
\tyxtstxbf[]function\tyxtstxendbf[] solve (a : nxn\Symuns[]matrix; b : n\Symuns[]vector) %
\tyxtstxbf[]return\tyxtstxendbf[] n\Symuns[]vector \tyxtstxbf[]is%
\tyxtstxendbf[]
   x, y : n\Symuns[]vector;
   lu   : nxn\Symuns[]matrix;
   l    : nxn\Symuns[]matrix \tyxtstxbf[]renames\tyxtstxendbf[] lu;
   u    : nxn\Symuns[]matrix \tyxtstxbf[]renames\tyxtstxendbf[] lu;
\tyxtstxbf[]begin\tyxtstxendbf[]
   -- Factorization step (compute l and u).
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] j \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. i-1 \tyxtstxbf[]loop\tyxtstxendbf[]
         l(i,j) :=
            (a(i,j) - row(i,l,1,j-1) * col(j,u,1,j-1)) / u(j,j);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]for\tyxtstxendbf[] j \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. i \tyxtstxbf[]loop\tyxtstxendbf[]
         u(j,i) := a(j,i) - row(j,l,1,j-1) * col(i,u,1,j-1);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Forward substitution step (compute y).
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      y(i) := b(i) - row(i,l,1,i-1) * y(1..i-1);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Backward substitution step (compute x).
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] \tyxtstxbf[]reverse\tyxtstxendbf[] 1 .. n %
\tyxtstxbf[]loop\tyxtstxendbf[]
      x(i) := (y(i) - row(i,u,i+1,n) * x(i+1..n)) / u(i,i);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Return the result.
   \tyxtstxbf[]return\tyxtstxendbf[] x;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 As usual, the \tyxffmxmono[]l\tyxffmxendmono[] and %
\tyxffmxmono[]u\tyxffmxendmono[] matrices, which are lower and upper
triangles in shape, share the storage of an order-\tyxffmxmono[]n%
\tyxffmxendmono[] matrix, \tyxffmxmono[]lu\tyxffmxendmono[]. (The
names \tyxffmxmono[]l\tyxffmxendmono[] and \tyxffmxmono[]u%
\tyxffmxendmono[] are both made synonymous with \tyxffmxmono[]lu%
\tyxffmxendmono[] and play only documentary roles in the algorithm.)
The diagonal of \tyxffmxmono[]u\tyxffmxendmono[] is that of %
\tyxffmxmono[]lu\tyxffmxendmono[]; the diagonal of %
\tyxffmxmono[]l\tyxffmxendmono[], which is unit triangular, is all
ones and is not stored. The triangles \tyxffmxmono[]l%
\tyxffmxendmono[] and \tyxffmxmono[]u\tyxffmxendmono[] are computed
in the factorization step of our version of Doolittle\rsquo[]s method
by alternately filling increasingly higher rows of %
\tyxffmxmono[]l\tyxffmxendmono[] and columns of \tyxffmxmono[]u%
\tyxffmxendmono[]. Note how the use of a simple abstraction for partial
rows and columns and a
\TyPbrkNewp[]
 familiar notation for inner products result in a clear and concise
expression of the algorithm. For simplicity of presentation, no test
for singularity is provided, and no provision for the raising of a
user-defined exception signaling singularity is made.\Endpara[]
\Para[]It should be pointed out that the type \tyxffmxmono[]nxn\Symuns[]matrix%
\tyxffmxendmono[] could have been defined as a one-dimensional array
(with bounds \tyxffmxmono[]1\tyxinterwordxsp[]..%
\tyxinterwordxsp[]n\tyxffmxendmono[]) whose components are of the
type \tyxffmxmono[]n\Symuns[]vector\tyxffmxendmono[]. One would have
to pick an interpretation for such a definition as either a vector
of row vectors or a vector of column vectors. Assuming the former
for purposes of illustration, a reference to the \tyxffmxmono[]i%
\tyxffmxendmono[],\tyxffmxmono[]j\tyxffmxendmono[]-th component of
\tyxffmxmono[]u\tyxffmxendmono[] would be written \tyxffmxmono[]u(i)(j)%
\tyxffmxendmono[]. Such an interpretation would allow a reference
to a whole row (but not a whole column) of an \tyxffmxmono[]nxn\Symuns[]matrix%
\tyxffmxendmono[]. By the same token, a partial row (but not a partial
column) could be denoted by combining subscripting and slicing. For
example, the \tyxffmxmono[]i\tyxffmxendmono[]th row of %
\tyxffmxmono[]u\tyxffmxendmono[] extending from position %
\tyxffmxmono[]i+1\tyxffmxendmono[] to position \tyxffmxmono[]n%
\tyxffmxendmono[], as needed in the backward substitution step, would
be denoted by \tyxffmxmono[]u(i)(i+1..n)\tyxffmxendmono[]. Defining
\tyxffmxmono[]nxn\Symuns[]matrix\tyxffmxendmono[] as a vector of %
\tyxffmxmono[]n\Symuns[]vector\tyxffmxendmono[]s would allow one to
dispose of either the \tyxffmxmono[]row\tyxffmxendmono[] function
or the \tyxffmxmono[]col\tyxffmxendmono[] function, but not both.%
\Endpara[]
\DivEndiv[]
\DivLiv[\def\DivLivId{crout-skyline}]\HdMinLiv[]Solution for Skyline
Matrices\HdMinEndiv[]
\Para[]The solution for ordinary matrices is now modified to exploit
the special properties of skyline matrices. First, we replace the
generic package \tyxffmxmono[]matrices\tyxffmxendmono[] with one called
\tyxffmxmono[]skyline\Symuns[]matrices\tyxffmxendmono[], whose specification
is shown in Figure \Xref[\def\XrefName{spec-of-skyline-matrices}].
\FgBlock[\def\FgBlockPlace{H}]
\Parbox[]
\FgCap[\def\FgCapId{spec-of-skyline-matrices}]Specification of the
\tyxffmxmono[]skyline\Symuns[]matrices\tyxffmxendmono[] generic package%
\FgEndcap[]
\Comp[]\tyxtstxbf[]generic\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[] float\Symuns[]type %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]digits\tyxtstxendbf[] \Symlt[]\Symgt[];
   n : \tyxtstxbf[]in\tyxtstxendbf[] positive;
\tyxtstxbf[]package\tyxtstxendbf[] skyline\Symuns[]matrices %
\tyxtstxbf[]is\tyxtstxendbf[]
   \tyxtstxbf[]type\tyxtstxendbf[]    vector   \tyxtstxbf[]is%
\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (positive %
\tyxtstxbf[]range\tyxtstxendbf[] \Symlt[]\Symgt[]) \tyxtstxbf[]of%
\tyxtstxendbf[] float\Symuns[]type;
   \tyxtstxbf[]subtype\tyxtstxendbf[] n\Symuns[]vector %
\tyxtstxbf[]is\tyxtstxendbf[] vector (1 .. n);
   \tyxtstxbf[]type\tyxtstxendbf[] bounded\Symuns[]vector (lo : positive; hi : natural) %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]record\tyxtstxendbf[]
      e : vector (lo .. hi);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]record%
\tyxtstxendbf[];
   \tyxtstxbf[]type\tyxtstxendbf[] vector\Symuns[]ptr         %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]access\tyxtstxendbf[] bounded\Symuns[]vector;
   \tyxtstxbf[]type\tyxtstxendbf[] vector\Symuns[]ptrs        %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]array\tyxtstxendbf[] (1 .. n) %
\tyxtstxbf[]of\tyxtstxendbf[] vector\Symuns[]ptr;
   \tyxtstxbf[]type\tyxtstxendbf[] nxn\Symuns[]skyline\Symuns[]matrix %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]record\tyxtstxendbf[]
      lower, upper : vector\Symuns[]ptrs;
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]record%
\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] row (row\Symuns[]index : positive;
                 of\Symuns[]cols   : vector\Symuns[]ptrs;
                 from      : positive) \tyxtstxbf[]return%
\tyxtstxendbf[] vector;
   \tyxtstxbf[]function\tyxtstxendbf[] \quot[]*\quot[] (left, right : vector) %
\tyxtstxbf[]return\tyxtstxendbf[] float\Symuns[]type;
   \tyxtstxbf[]function\tyxtstxendbf[] solve (a : nxn\Symuns[]skyline\Symuns[]matrix;
                   b : n\Symuns[]vector) \tyxtstxbf[]return%
\tyxtstxendbf[] n\Symuns[]vector;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 In place of the type \tyxffmxmono[]nxn\Symuns[]matrix%
\tyxffmxendmono[], we now define a type \tyxffmxmono[]nxn\Symuns[]skyline\Symuns[]matrix%
\tyxffmxendmono[], which is a record of two components, each an array
of pointers: the component \tyxffmxmono[]lower\tyxffmxendmono[] is
a vector of pointers to the rows of the lower triangle, while the
component \tyxffmxmono[]upper\tyxffmxendmono[] is a vector of pointers
to the columns of the upper triangle. Pointers are used, of course,
to permit the rows and columns to be allocated dynamically with just
the right \ldquo[]size\rdquo[] once that size is known (dynamically
allocated storage is accessed through the pointer value obtained when
it is allocated). Each row or column is represented by the type %
\tyxffmxmono[]bounded\Symuns[]vector\tyxffmxendmono[], which is a
discriminated record containing one component, \tyxffmxmono[]e%
\tyxffmxendmono[], and two discriminants, \tyxffmxmono[]lo%
\tyxffmxendmono[] and \tyxffmxmono[]hi\tyxffmxendmono[]. The component
\tyxffmxmono[]e\tyxffmxendmono[] is an object of the unconstrained
array type \tyxffmxmono[]vector\tyxffmxendmono[] (whose definition
has not changed) constrained by the bounds \tyxffmxmono[]lo%
\tyxffmxendmono[] and \tyxffmxmono[]hi\tyxffmxendmono[]\EmDash[]that
is, by the values of the discriminants. Each object of the type %
\tyxffmxmono[]bounded\Symuns[]vector\tyxffmxendmono[] is thus self-describing
as far as the bounds of the contained vector \tyxffmxmono[]e%
\tyxffmxendmono[] are concerned. The bounds are supplied at the time
of allocation of the object and remain fixed throughout its lifetime.%
\Endpara[]
\Para[]A comparison of Figures \Xref[\def\XrefName{spec-of-skyline-matrices}]
and \Xref[\def\XrefName{spec-of-matrices}] will reveal that we dropped
the \tyxffmxmono[]col\tyxffmxendmono[] function and simplified the
\tyxffmxmono[]row\tyxffmxendmono[] function somewhat (i.e., by changing
its parameters). We no longer need the \tyxffmxmono[]col%
\tyxffmxendmono[] function because all the columns we need to reference
are in upper triangles and are therefore now just one-dimensional
arrays instead of one-dimensional cross sections of two-dimensional
arrays (to be utterly precise, we should say that they are records
that contain one-dimensional arrays). References to partial columns
are easily obtained by using the slicing notation on column vectors.
Unfortunately, not all of the rows referenced in Doolittle\rsquo[]s
method are rows of lower triangles; if they were, we could dispense
with the \tyxffmxmono[]row\tyxffmxendmono[] function for similar reasons.
The backward substitution step references a row of %
\tyxffmxmono[]u\tyxffmxendmono[]. That row cuts across the column
vectors representing the upper triangle of \tyxffmxmono[]lu%
\tyxffmxendmono[], and it might even have some components lying outside
the skyline envelope of \tyxffmxmono[]lu\tyxffmxendmono[]. Thus the
\tyxffmxmono[]row\tyxffmxendmono[] function is retained for the sole
purpose of extracting a row from an upper triangle, and it is particularized
to that aim. The partial row needed in the backward substitution step
always extends to the end of the row, so we no longer need to pass
the row\rsquo[]s upper bound as a parameter. Furthermore, since %
\tyxffmxmono[]row\tyxffmxendmono[] is asked to extract a row only
from the upper triangle of a skyline matrix, we no longer pass an
entire skyline matrix to it; we merely pass the desired upper triangle,
represented by the vector of pointers to its columns.\Endpara[]
\Para[]Turning now to the body of \tyxffmxmono[]skyline\Symuns[]matrices%
\tyxffmxendmono[] (Figure \Xref[\def\XrefName{body-of-skyline-matrices}]),
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-skyline-matrices}]Body of the %
\tyxffmxmono[]skyline\Symuns[]matrices\tyxffmxendmono[] generic package%
\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] min\Symuns[]and\Symuns[]max;
\tyxtstxbf[]package\tyxtstxendbf[] \tyxtstxbf[]body%
\tyxtstxendbf[] skyline\Symuns[]matrices \tyxtstxbf[]is%
\tyxtstxendbf[]
   \tyxtstxbf[]package\tyxtstxendbf[] natural\Symuns[]min\Symuns[]and\Symuns[]max %
\tyxtstxbf[]is\tyxtstxendbf[] \tyxtstxbf[]new\tyxtstxendbf[] min\Symuns[]and\Symuns[]max (natural);
   \tyxtstxbf[]use\tyxtstxendbf[]     natural\Symuns[]min\Symuns[]and\Symuns[]max;
   \tyxtstxbf[]function\tyxtstxendbf[] row (row\Symuns[]index : positive;
                 of\Symuns[]cols   : vector\Symuns[]ptrs;
                 from      : positive) \tyxtstxbf[]return%
\tyxtstxendbf[] vector \tyxtstxbf[]is\tyxtstxendbf[]
      result : vector (from .. n);
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] from .. n \tyxtstxbf[]loop\tyxtstxendbf[]
         \tyxtstxbf[]if\tyxtstxendbf[] row\Symuns[]index \Symgt[]= of\Symuns[]cols(i).lo %
\tyxtstxbf[]then\tyxtstxendbf[]
            result(i) := of\Symuns[]cols(i).e(row\Symuns[]index);
         \tyxtstxbf[]else\tyxtstxendbf[]
            result(i) := 0.0;
         \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]if%
\tyxtstxendbf[];
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]return\tyxtstxendbf[] result;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] \quot[]*\quot[] (left, right : vector) %
\tyxtstxbf[]return\tyxtstxendbf[] float\Symuns[]type %
\tyxtstxbf[]is\tyxtstxendbf[]
      sum : float\Symuns[]type := 0.0;
   \tyxtstxbf[]begin\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] max(left\rsquo[]first, right\rsquo[]first) ..
               min(left\rsquo[]last,  right\rsquo[]last) %
\tyxtstxbf[]loop\tyxtstxendbf[]
         sum := sum + left(i) * right(i);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]return\tyxtstxendbf[] sum;
   \tyxtstxbf[]end\tyxtstxendbf[];
   \tyxtstxbf[]function\tyxtstxendbf[] solve (a : nxn\Symuns[]skyline\Symuns[]matrix;
                   b : n\Symuns[]vector) \tyxtstxbf[]return%
\tyxtstxendbf[] n\Symuns[]vector \tyxtstxbf[]is\tyxtstxendbf[] %
\tyxtstxbf[]separate\tyxtstxendbf[];
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 we note the following changes from its predecessor:
\LstList[]
\LstItem[]The body of the \tyxffmxmono[]row\tyxffmxendmono[] function
now returns a row vector containing, in each position, either a component
of the skyline matrix whose upper triangle is passed as an argument
(if within the skyline envelope) or zero (if outside it). The bounds
of the vector it returns could be shortened if zeros lie at either
end, but that optimization hardly seems worthwhile.\LstEnditem[]
\LstItem[]The \tyxffmxmono[]*\tyxffmxendmono[] operator (inner-product
function) can now receive a pair of vectors of different lengths;
because the missing components are zero, they do not contribute to
the inner product, and the loop can extend from the greater of the
lower bounds of the two vectors to the lesser of their upper bounds.%
\LstEnditem[]
\LstEndlist[]
\Endpara[]
\Para[]The revised proper body of the \tyxffmxmono[]solve%
\tyxffmxendmono[] function is shown in Figure \Xref[\def\XrefName{body-of-solve-skyline}].
\FgBlock[]
\Parbox[]
\FgCap[\def\FgCapId{body-of-solve-skyline}]Proper body of the %
\tyxffmxmono[]solve\tyxffmxendmono[] function, for skyline matrices%
\FgEndcap[]
\Comp[]\tyxtstxbf[]with\tyxtstxendbf[] unchecked\Symuns[]deallocation;
\tyxtstxbf[]separate\tyxtstxendbf[] (skyline\Symuns[]matrices)
\tyxtstxbf[]function\tyxtstxendbf[] solve (a : nxn\Symuns[]skyline\Symuns[]matrix;
                b : n\Symuns[]vector) \tyxtstxbf[]return%
\tyxtstxendbf[] n\Symuns[]vector \tyxtstxbf[]is\tyxtstxendbf[]
   x, y : n\Symuns[]vector;
   lu   : nxn\Symuns[]skyline\Symuns[]matrix;
   l    : vector\Symuns[]ptrs \tyxtstxbf[]renames\tyxtstxendbf[] lu.lower;
   u    : vector\Symuns[]ptrs \tyxtstxbf[]renames\tyxtstxendbf[] lu.upper;
   \tyxtstxbf[]procedure\tyxtstxendbf[] free \tyxtstxbf[]is%
\tyxtstxendbf[]
      \tyxtstxbf[]new\tyxtstxendbf[] unchecked\Symuns[]deallocation (bounded\Symuns[]vector, vector\Symuns[]ptr);
\tyxtstxbf[]begin\tyxtstxendbf[]
   -- Allocate the rows and columns of lu with the shape of a.
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      l(i) := \tyxtstxbf[]new\tyxtstxendbf[] bounded\Symuns[]vector (lo =\Symgt[] a.lower(i).lo, hi =\Symgt[] i-1);
      u(i) := \tyxtstxbf[]new\tyxtstxendbf[] bounded\Symuns[]vector (lo =\Symgt[] a.upper(i).lo, hi =\Symgt[] i);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Factorization step (compute l and u).
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      \tyxtstxbf[]for\tyxtstxendbf[] j \tyxtstxbf[]in%
\tyxtstxendbf[] l(i).lo .. i-1 \tyxtstxbf[]loop\tyxtstxendbf[]
         l(i).e(j) := (a.lower(i).e(j) -
            l(i).e(l(i).lo..j-1) * u(j).e(u(j).lo..j-1)) / u(j).e(j);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
      \tyxtstxbf[]for\tyxtstxendbf[] j \tyxtstxbf[]in%
\tyxtstxendbf[] u(i).lo .. i \tyxtstxbf[]loop\tyxtstxendbf[]
         u(i).e(j) := a.upper(i).e(j) -
            l(j).e(l(j).lo..j-1) * u(i).e(u(i).lo..j-1);
      \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Forward substitution step (compute y).
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      y(i) := b(i) - l(i).e(l(i).lo..i-1) * y(1..i-1);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Backward substitution step (compute x).
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] \tyxtstxbf[]reverse\tyxtstxendbf[] 1 .. n %
\tyxtstxbf[]loop\tyxtstxendbf[]
      x(i) := (y(i) - row(i,u,i+1) * x(i+1..n)) / u(i).e(i);
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Deallocate the rows and columns of lu.
   \tyxtstxbf[]for\tyxtstxendbf[] i \tyxtstxbf[]in%
\tyxtstxendbf[] 1 .. n \tyxtstxbf[]loop\tyxtstxendbf[]
      free (l(i));
      free (u(i));
   \tyxtstxbf[]end\tyxtstxendbf[] \tyxtstxbf[]loop%
\tyxtstxendbf[];
   -- Return the result.
   \tyxtstxbf[]return\tyxtstxendbf[] x;
\tyxtstxbf[]end\tyxtstxendbf[];\Endcomp[]
\EndParbox[]
\FgEndblock[]
 One small change is that \tyxffmxmono[]l\tyxffmxendmono[] and %
\tyxffmxmono[]u\tyxffmxendmono[] are now made synonymous with the
lower and upper triangular components of \tyxffmxmono[]lu%
\tyxffmxendmono[], respectively, rather than with the entire object
\tyxffmxmono[]lu\tyxffmxendmono[], as was done before. This simplifies
the expressions we are required to write to denote components, rows,
or columns of \tyxffmxmono[]lu\tyxffmxendmono[] (e.g., we write %
\tyxffmxmono[]l(i).e(j)\tyxffmxendmono[] to denote the %
\tyxffmxmono[]i\tyxffmxendmono[],\tyxffmxmono[]j%
\tyxffmxendmono[]-th component of the lower triangle of %
\tyxffmxmono[]lu\tyxffmxendmono[]). Similar renaming declarations
could be given for the lower and upper triangles of %
\tyxffmxmono[]a\tyxffmxendmono[], but there are few references to
\tyxffmxmono[]a\tyxffmxendmono[] in \tyxffmxmono[]solve%
\tyxffmxendmono[], so the savings would not be significant. The %
\tyxffmxmono[]solve\tyxffmxendmono[] function includes two steps not
previously required: one to allocate the rows and columns of the local
\tyxffmxmono[]lu\tyxffmxendmono[] skyline matrix before filling them
in the factorization step, and one to deallocate them just before
returning the result. It is a consequence of Doolittle\rsquo[]s method
that the skyline envelope of \tyxffmxmono[]lu\tyxffmxendmono[] is
the same as that of \tyxffmxmono[]a\tyxffmxendmono[]. Thus, we allocate
the \tyxffmxmono[]i\tyxffmxendmono[]th row of \tyxffmxmono[]lu%
\tyxffmxendmono[] to have the same lower bound as the %
\tyxffmxmono[]i\tyxffmxendmono[]th row of \tyxffmxmono[]a%
\tyxffmxendmono[] and an upper bound of \tyxffmxmono[]i-1%
\tyxffmxendmono[] (recall that the lower triangle stops just short
of the diagonal); similarly, we allocate the \tyxffmxmono[]i%
\tyxffmxendmono[]th column of \tyxffmxmono[]lu\tyxffmxendmono[] to
have the same lower bound as the \tyxffmxmono[]i%
\tyxffmxendmono[]th column of \tyxffmxmono[]a\tyxffmxendmono[] and
an upper bound of \tyxffmxmono[]i\tyxffmxendmono[] (the upper triangle
includes the diagonal).\Endpara[]
\Para[]In the factorization step, we see that the two inner loops
now start at the index of the first nonzero component of the row or
column being filled, instead of at 1, since preceding components (those
outside the skyline envelope) do not exist. The backward substitution
step contains the only remaining reference to the \tyxffmxmono[]row%
\tyxffmxendmono[] function.\Endpara[]
\Para[]Our solution for skyline matrices obviously saves space by
not storing zeros outside the envelope of a skyline matrix. It also
saves time by not computing them. Surprisingly, it is more efficient
than the solution for normal matrices in yet another way: it calls
far fewer subprograms to obtain (partial) rows or columns, and in
so doing copies much less data.\Endpara[]
\Para[]In view of the similarities between the two solutions, it is
reasonable to ask whether one can write a single version of %
\tyxffmxmono[]solve\tyxffmxendmono[] that is suitable either for normal
matrices or for skyline matrices. The answer is yes, but we only sketch
the details here. One starts by separating the \tyxffmxmono[]solve%
\tyxffmxendmono[] function from the rest of the matrix abstraction,
leaving a generic library package called \tyxffmxmono[]matrices%
\tyxffmxendmono[] and a generic library function called %
\tyxffmxmono[]solve\tyxffmxendmono[]. The matrix type would be exported
from \tyxffmxmono[]matrices\tyxffmxendmono[] and imported into %
\tyxffmxmono[]solve\tyxffmxendmono[]; the two different implementations
of the matrix type would be provided by two different realizations
of \tyxffmxmono[]matrices\tyxffmxendmono[]. To gain the desired degree
of reusability, the single version of \tyxffmxmono[]solve%
\tyxffmxendmono[] would have to be written so that it makes no assumptions
about the implementation of the matrix type that it imports. Thus,
the generic formal type by which it imports the matrix type would
have to be a private type. Subscript and slice notation could then
no longer be used in \tyxffmxmono[]solve\tyxffmxendmono[] to denote
components, rows, or columns of matrices; hence these operations would
have to be exported (in the form of subprograms) by %
\tyxffmxmono[]matrices\tyxffmxendmono[], and imported by %
\tyxffmxmono[]solve\tyxffmxendmono[].\NtFoot[]\NtNtpar[]In addition
to a function for fetching a component of a matrix, given the matrix
and its component indices, a procedure for storing into a component
of a matrix\EmDash[]given the matrix, its component indices, and the
value to be stored\EmDash[]would have to be provided by the matrix
abstraction.\NtEndntpar[]\NtEndfoot[] If the rest of the client\rsquo[]s
application (exclusive of \tyxffmxmono[]solve\tyxffmxendmono[]) is
also to be independent of the matrix type, then it, too, would have
to use the abstract operations exported from \tyxffmxmono[]matrices%
\tyxffmxendmono[]. The abstraction could \txtxemph[]force%
\txtxendemph[] the client to be independent of the details of the
matrix type by defining that type as a private type. Clearly, the
benefits of reusability come at some cost\EmDash[]the substitution
of explicit operations (and their incurred overheads) for predefined
operations.\Endpara[]
\Para[]But there is another cost as well. In the factorization step
of the skyline adaptation of \tyxffmxmono[]solve%
\tyxffmxendmono[], we skipped over the computation of components of
\tyxffmxmono[]l\tyxffmxendmono[] and \tyxffmxmono[]u%
\tyxffmxendmono[] lying outside the skyline envelope, thus saving
time as well as space. In the \ldquo[]generalized\rdquo[] version
being contemplated here, we cannot know in advance whether a component
lies outside the envelope, so we must compute it, even if it turns
out to be zero. In order to retain the storage savings represented
by not storing zeros outside the skyline envelope, the procedure (exported
by \tyxffmxmono[]matrices\tyxffmxendmono[]) that stores a value into
a component of a matrix would be given, in the skyline case, the responsibility
for allocating a row (if the component being set is in the lower triangle)
or a column (if it is in the upper triangle) upon the first attempt
to store a nonzero value into a particular component; it would just
discard zeros destined for a row or column that it has not yet allocated.
(Note that pointers are initialized to \tyxffmxmono[]%
\tyxtstxbf[]null\tyxtstxendbf[]\tyxffmxendmono[] in Ada, making it
easy to detect that a row or column has never been allocated.) This
responsibility of the component-storing procedure meshes well with
our realization of Doolittle\rsquo[]s method, since the components
of the rows and columns of \tyxffmxmono[]lu\tyxffmxendmono[] are set
in increasing order\EmDash[]that is, it is \txtxemph[]possible%
\txtxendemph[] to defer allocating a row or column of %
\tyxffmxmono[]lu\tyxffmxendmono[] until an attempt is made to store
its first nonzero component. In conjunction with this, the %
\tyxffmxmono[]row\tyxffmxendmono[] and \tyxffmxmono[]col%
\tyxffmxendmono[] functions must be prepared to return null arrays
if their arguments denote rows or columns that have not yet been allocated.
Although the responsibility for allocating rows and columns can be
built into the skyline version of the component-storing procedure
that would be exported with the matrix type, there is no way to handle
the \ldquo[]automatic\rdquo[] deallocation of the rows and columns
of a matrix (in the skyline case) upon leaving the scope of the object
declaration for the matrix. Of course, Ada allows for such dynamically
allocated storage to be reclaimed automatically (in this case, when
\tyxffmxmono[]solve\tyxffmxendmono[] returns); but as we said earlier
in this chapter, such garbage collection is not routinely implemented
in Ada.\NtFoot[]\NtNtpar[]Ada 9X will likely introduce \ldquo[]finalization\rdquo[]
of objects or types, which will solve this problem elegantly.%
\NtEndntpar[]\NtEndfoot[] If explicit deallocation is desired, a procedure
to deallocate a matrix could be exported with the type, imported by
\tyxffmxmono[]solve\tyxffmxendmono[], and called by %
\tyxffmxmono[]solve\tyxffmxendmono[] just before it returns. In the
case of normal matrices, the deallocation procedure would do nothing,
while for skyline matrices it would have the behavior shown in Figure
\Xref[\def\XrefName{body-of-solve-skyline}].\Endpara[]
\Para[]The expense of computing and then discarding zeros outside
the skyline envelope can, actually, be saved if we are willing to
export additional operations with the matrix type, as part of the
matrix abstraction. That is, we could export a pair of functions that
give the lower bound of a row or a column of a matrix. They would
be used in the factorization step to skip over components of %
\tyxffmxmono[]l\tyxffmxendmono[] and \tyxffmxmono[]u%
\tyxffmxendmono[] outside the skyline envelope (in the skyline case).
The rows and columns of \tyxffmxmono[]l\tyxffmxendmono[] and %
\tyxffmxmono[]u\tyxffmxendmono[] would still be allocated by the component-storing
procedure discussed above. Thus, in the factorization step, we would
not ask for the lower bounds of the rows and columns of %
\tyxffmxmono[]lu\tyxffmxendmono[] (since they will not have been allocated
yet); rather, we would ask for the lower bounds of the rows and columns
of \tyxffmxmono[]a\tyxffmxendmono[]. In the case of normal matrices,
these enquiry functions would be designed so that they always return
1, of course. Clearly, such functions are not very elegant as part
of a reusable abstraction, but they do allow us to retain some of
the speed economies in the skyline case.\Endpara[]
\Para[]Finally, the matrix type should really be declared %
\tyxffmxmono[]\tyxtstxbf[]limited\tyxtstxendbf[]%
\tyxffmxendmono[] \tyxffmxmono[]\tyxtstxbf[]private%
\tyxtstxendbf[]\tyxffmxendmono[], and not just \tyxffmxmono[]%
\tyxtstxbf[]private\tyxtstxendbf[]\tyxffmxendmono[], in %
\tyxffmxmono[]matrices\tyxffmxendmono[]. The assignment operation
and the predefined equality comparison operation, which %
\txtxemph[]are\txtxendemph[] among the few operations implicitly declared
for private types, are \txtxemph[]not\txtxendemph[] implicitly declared
for limited types, and that can be important to us. When pointers
are used in the implementation of an abstraction, one needs to determine
whether assignment and equality comparison make sense. In our case,
they do not. Assignment of one skyline matrix to another would copy
only the contained pointer values; it would not replicate the rows
and columns of the source value. Because the rows and columns of the
target would therefore be the same as those of the source, after the
assignment, changes to one would affect the other. By the same token,
two skyline matrices with different, but equal, rows and columns would
not compare equal, because the predefined operation for equality comparison
would compare only the pointer values. Sharing of storage is desired
in some applications, but not here. In a reusable abstraction, it
is important to suppress the implicit declaration of operations that
do not make sense, so that the abstraction will not be misused. Declaring
the matrix type in \tyxffmxmono[]matrices\tyxffmxendmono[] as %
\tyxffmxmono[]\tyxtstxbf[]limited\tyxtstxendbf[]%
\tyxffmxendmono[] \tyxffmxmono[]\tyxtstxbf[]private%
\tyxtstxendbf[]\tyxffmxendmono[] will accomplish that. (We were not
concerned in Section \Xref[\def\XrefName{crout-skyline}] with the
risks of \txtxemph[]not\txtxendemph[] making the matrix type limited
because, as we said there, we specifically wanted the user to be able
to exploit knowledge of its implementation, which required us to forgo
the use of private types and therefore also limited types; we tacitly
assumed that the user would not misuse that knowledge by, for example,
assigning or comparing skyline matrices.) Although assignment and
equality comparison of matrices are not needed in \tyxffmxmono[]solve%
\tyxffmxendmono[], no such assumption should be made by the designer
of \tyxffmxmono[]matrices\tyxffmxendmono[], if its two versions are
truly meant to be reused in a variety of applications. Thus, the designer
of \tyxffmxmono[]matrices\tyxffmxendmono[] would be compelled to provide
those operations explicitly as part of the matrix abstraction, using
subprograms or operator overloading; of course, the designer of %
\tyxffmxmono[]matrices\tyxffmxendmono[] could then also ensure that
the operations have the desired behavior in the skyline case. These
considerations dictate that the generic formal type by which %
\tyxffmxmono[]solve\tyxffmxendmono[] imports the matrix type must
also be declared \tyxffmxmono[]\tyxtstxbf[]limited%
\tyxtstxendbf[]\tyxffmxendmono[] \tyxffmxmono[]\tyxtstxbf[]private%
\tyxtstxendbf[]\tyxffmxendmono[], but that is possible precisely because
\tyxffmxmono[]solve\tyxffmxendmono[] does not need assignment or the
predefined equality comparison operation for the matrix type.%
\Endpara[]
\DivEndiv[]
\DivEndiii[]
\DivLiii[]\HdMjLiii[\def\HdMjLiiiFntGenlTsz{H}\def\HdMjLiiiNumPostpunc{}\def\HdMjLiiiNumFirstdisp{99}]Acknowledgments%
\HdMjEndiii[]
\Para[]The preparation of this chapter was supported by the Strategic
Defense Initiative Organization, Office of the U. S. Secretary of
Defense, under PMA E2304.\Endpara[]
\DivEndiii[]
\Bib[\BibHdPosPostvskp=7pt plus3pt minus1pt \BibHdPosPrevskp=20pt plus7pt minus4pt \def\BibHdFntTsz{H}\BibHspaceWAmt=26pt ]%
\Bibdat[]global\BibEnddat[]\Endbib[]
\DivEndii[]
\DivEndbod[]
\Enddoc[]

